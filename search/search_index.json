{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":"<p>Welcome to the sc-machine documentation! This comprehensive guide is designed to help you navigate the features, functionalities, and applications of sc-machine, a C++ software package that emulates semantic computer behavior through the storage and processing of knowledge in a semantic network.</p>"},{"location":"#what-is-sc-machine","title":"What is sc-machine?","text":"<p>At its core, sc-machine operates as a graph database management system, enabling users to efficiently store, retrieve, and manipulate knowledge graphs in common shared memory known as sc-memory. By leveraging an agent-based approach, it processes these graphs to facilitate complex tasks and workflows. The underlying technology is grounded in the OSTIS Technology, which allows for the representation of both declarative and procedural knowledge using a unified language known as SC-code (Semantic Computer code).</p> <p>Table of contents:</p> <ul> <li>Quick Start - get up and running with sc-machine quickly</li> <li>Docker - get up and running with sc-machine in docker</li> <li>User Guides - detailed instructions on implementing agents<ul> <li>C++ Guides - guidelines for implementing agents on C++<ul> <li>C++ Simple Guide for Implementing Agent</li> </ul> </li> <li>Migrate to New Agent API - description of script that can be used to migrate to new C++ Agents API</li> </ul> </li> <li>API - comprehensive documentation for C++, Python, and TypeScript APIs<ul> <li>C++ API - detailed guides on using the core and extended APIs for interacting with sc-memory<ul> <li>C++ Core API - documentation of C++ core API for creating, retrieving and erasing sc-elements in sc-memory</li> <li>C++ Extended API - documentation of C++ extended API for manipulating with system identifiers of sc-elements and sc-templates<ul> <li>C++ System Identifier API - documentation of C++ extended API for manipulating with system identifiers of sc-elements</li> <li>C++ ScTemplate API - documentation of C++ extended API for creating and retrieving graphs (it is very useful when you want to work big sc-constructions)</li> <li>C++ User Permissions API - documentation of handling users and their permissions in knowledge base</li> <li>C++ Agents API - documentation of C++ Agents API for creating agents<ul> <li>C++ Events API - enables developers to create and manage events within the sc-machine, allowing agents to respond dynamically to various triggers</li> <li>C++ Event Subscriptions API - details how agents can subscribe to specific events and receive notifications when those events occur</li> <li>C++ Waiters API - allows developers to implement wait conditions that pause agent execution until specified conditions are met or events are triggered</li> <li>C++ Keynodes API - provides functionality for creating, retrieving, and manipulating keynodes, which represent significant concepts within the knowledge graph</li> <li>C++ Actions API - outlines how to define and initiate actions that agents can perform, detailing their arguments and results</li> <li>C++ Agents API - focuses on agent creation and management</li> <li>C++ Agent Context API - explains how to manage the context in which agents operate</li> <li>C++ Modules API - describes how to register agents in an application</li> </ul> </li> </ul> </li> </ul> </li> <li>Python API - documentation on using the Python client for interacting with sc-memory<ul> <li>Python Core API - documentation of Python core API for creating, retrieving and erasing sc-elements and sc-events in sc-memory</li> <li>Python Extended API - documentation of Python extended API for manipulating with large graphs</li> </ul> </li> <li>TypeScript API - documentation on using the TypeScript client for interacting with sc-memory<ul> <li>TypeScript Core API - documentation of TypeScript core API for creating, retrieving and erasing sc-elements and sc-events in sc-memory</li> </ul> </li> <li>sc-element Types - detailed description of supported element types</li> <li>SCs-code - documentation on SCs Language with examples</li> </ul> </li> <li>Tools - information on various tools that enhance your experience with sc-machine<ul> <li>Knowledge Base Builder - description of options of sc-builder for knowledge base sources</li> <li>Knowledge Base Repo File - description of configuration of knowledge base sources</li> <li>sc-machine Runner - description of options of sc-machine runner</li> </ul> </li> <li>Build Instructions - guidelines for building the project, configuring settings<ul> <li>Quick Start for Developers - get up and start developing sc-machine quickly</li> <li>Build System - how to build the project and use it as a library</li> <li>CMake Flags - description of CMake flags used to configure sc-machine</li> <li>Configuration File - description of a configuration file of sc-machine</li> </ul> </li> <li>Development - guidelines for contributing to development<ul> <li>Contributing Guide - guide for those who wants to make contribution into sc-machine</li> <li>Code Style Guide - guide for those who wants to write code for sc-machine</li> <li>Dev Container - guide for those who wants to develop sc-machine via docker</li> </ul> </li> <li>License</li> <li>Changelog</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing Guide","text":"<p>This page describes rules to contribute changes and features by Pull Requests creating.</p>"},{"location":"CONTRIBUTING/#initialize","title":"Initialize","text":"<p>To initialize your repo do:</p> <ul> <li>Fork <code>https://github.com/ostis-ai/sc-machine</code>.</li> <li>Clone your fork to your machine and prepare (see Readme).</li> </ul> <pre><code>git clone git@github.com:yourlogin/sc-machine.git\ncd sc-machine\ngit remote add upstream git@github.com:ostis-ai/sc-machine.git\n</code></pre> <ul> <li>To update your <code>main</code> from <code>upstream</code> use:</li> </ul> <pre><code>git fetch upstream\ngit checkout upstream/main\n</code></pre> <ul> <li>Use <code>git rebase</code> instead of <code>merge</code>. See documentation about this command. To rebase your branch against main use:</li> </ul> <pre><code>git checkout &lt;yourbranch&gt;\ngit rebase upstream/main\n</code></pre> <ul> <li>If you have any problems, then redo:</li> </ul> <pre><code>git rebase --abort\n</code></pre> <ul> <li>Or ask in Element.</li> </ul>"},{"location":"CONTRIBUTING/#commits-message-format","title":"Commits message format","text":"<p>Each commit message should be formed as: <code>[tag1]...[tagN] Message text (#issue)</code>.</p> <p>Message text should start from an upper case letter. If commit doesn't fix or implement any #issue, then it shouldn't be pointed in commit message.</p> <p>Examples:</p> <pre>\n[cpp] Colored log output\n[cpp][test] Add unit test for ScEvent class\n[kpm][search] Relation type check added\n</pre> <p>Possible tags:</p> <ul> <li><code>[build]</code> - changes in build system;</li> <li><code>[memory]</code> - changes in <code>sc-memory</code> module;</li> <li><code>[kpm]</code> - changes in <code>sc-kpm</code> module;</li> <li><code>[tests]</code> or <code>[test]</code> - changes in tests;</li> <li><code>[tools]</code> - changes in <code>sc-tools</code>;</li> <li><code>[server]</code> - changes in <code>sc-server</code> module;</li> <li><code>[builder]</code> - changes in <code>sc-builder</code> module;</li> <li><code>[config]</code> - commits with changes in configuration;</li> <li><code>[review]</code> - commits with review fixes;</li> <li><code>[refactor]</code> - commits with some code refactoring;</li> <li><code>[changelog]</code> - use when you update changelog;</li> <li><code>[docs]</code> or <code>[doc]</code> - use when you update documentation;</li> <li><code>[docker]</code> - changes in Dockerfile, .dockerignore or Docker image build pipeline;</li> <li><code>[scripts]</code> - updates in the <code>sc-machine/scripts</code> files;</li> <li><code>[ci]</code> - changes in <code>ci</code> configuration or scripts;</li> <li><code>[git]</code> - changes in <code>git</code> configuration;</li> <li><code>[cmake]</code> - changes in <code>cmake</code> build system.</li> </ul> <p>Each commit in Pull Request should be an atomic. In other words, it should implement or fix one feature. For example:</p> <pre>\nLast commit\n...\n[cpp] Colored log output\n[cpp] Add class to work with console\n...\nInit commit\n</pre> <p>In this example we add class to work with console (where implemented colored output), then in another commit we add implementation of colored log output.</p> <p>Each commit should have not much differences excluding cases, with:</p> <ul> <li>CodeStyle changes; </li> <li>Renames; </li> <li>Code formatting.</li> </ul> <p>Do atomic commits for each changes. For example if you rename some members in <code>ClassX</code> and <code>ClassY</code>, then do two commits:</p> <pre>\n[refactor] Rename members in ClassX according to codestyle\n[refactor] Rename members in ClassY according to codestyle\n</pre> <p>Do not mix codestyle changes and any logical fixes in one commit.</p> <p>All commits that not follow these rules should be split according to these rules. Otherwise they will be rejected with Pull Request.</p>"},{"location":"CONTRIBUTING/#pull-request","title":"Pull request","text":""},{"location":"CONTRIBUTING/#pull-request-preparation","title":"Pull Request Preparation","text":"<ul> <li>Read rules to create PR in documentation;</li> <li>Update changelog;</li> <li>Update documentation;</li> <li>Cover new functionality by tests;</li> <li>Your code should be written according to a codestyle.</li> </ul>"},{"location":"CONTRIBUTING/#pull-request-creation","title":"Pull Request creation","text":"<ul> <li>Create PR on GitHub;</li> <li>Check that CI checks were passed successfully;</li> </ul>"},{"location":"CONTRIBUTING/#pull-request-review","title":"Pull Request Review","text":"<ul> <li>Reviewer tests code from PR if CI doesn't do it;</li> <li>Reviewer submits review as set of conversations;</li> <li>Author makes review fixes at <code>Review fixes</code> commits;</li> <li>Author re-requests review;</li> <li>Reviewer resolves conversations and approves PR if conversations were fixed.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#0105-08092025","title":"[0.10.5] - 08.09.2025","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>sc-server endpoint to parse SCs text into JSON ASTs</li> <li><code>SCsASTErrorListener</code> to collect SCs parsing errors into a JSON array</li> <li><code>SCsASTJsonListener</code> to construct AST from SCs input and serialize it to JSON</li> <li><code>GetElementsByRoles</code> method for <code>ScSet</code> class to get all elements of set by their roles</li> <li><code>GetElements</code> method for <code>ScSet</code> class to get all elements of set</li> <li>ScOrientedSet class to work with sets of sc-elements ordered by nrel_basic_sequence relation</li> <li>Methods for <code>ScSet</code> class: <code>Next</code>, <code>Reset</code>, <code>ForEach</code></li> <li>Operator for converting ScAddr to string</li> <li>Stream output operator for ScAddr</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Optimize grouping connectors by level in <code>ScTemplateBuilder</code></li> <li>Rename method <code>HasElement</code> in <code>ScSet</code> class to <code>Has</code></li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Constructor call for context template argument class provided in ScAgent class </li> </ul>"},{"location":"changelog/#0104-03062025","title":"[0.10.4] - 03.06.2025","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Flag for ScLogger to enable appending logs to existing log file</li> </ul>"},{"location":"changelog/#0103-01052025","title":"[0.10.3] - 01.05.2025","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Validate project version after parsing from CMakeLists.txt</li> <li>Add step about installation of development tools in quick start for contributors</li> <li>Make temporary override for libffi in ostis-ai until updated in conan-center-index</li> <li>Pin asio version 3.10.2 for macOS native installation</li> </ul>"},{"location":"changelog/#0102-22042025","title":"[0.10.2] - 22.04.2025","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Increase MAX_TRIPLES_COUNT for json-translators to 1.000.000</li> <li>Support included structures translation in scn2json-translator</li> <li>Iterate included structures in searching semantic neighborhood agent</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Mark translated sc-element main in semantic neighborhood agent</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Translating links with content size &lt; 100</li> <li>Add using --dev flag during launching install_deps_ubuntu.sh in quick_start for users</li> </ul>"},{"location":"changelog/#0101-15032025","title":"[0.10.1] - 15.03.2025","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Support direct quasibinary relations in semantic neighborhood agent</li> <li>Developer tool to review PRs -- Ellipsis</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Rename Conan remote repository url to https://conan.ostis.net/artifactory/api/conan/ostis-ai-library</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Translating sc-structures to json in sc2scn-json-translator</li> <li>Take into account order relations between sc-elements in quasibinary tuples in sc2scn-json-translator</li> <li>SC_LOG_INFO_COLOR uses correct enum value</li> <li>Move CONTRIBUTING.md to docs folder</li> <li>Don't install transitive dependencies of libxml2: zlib and iconv</li> <li>Fix typos in C++ Simple Guide for Implementing Agent and User permissions API</li> <li>Migration script does not affect agent logs</li> </ul>"},{"location":"changelog/#0100-21012025","title":"[0.10.0] - 21.01.2025","text":""},{"location":"changelog/#breaking-changes","title":"Breaking changes","text":"<ul> <li>Python dependencies are set up locally in <code>.venv</code> environment. Therefore, you should make the following changes: <ul> <li>fix <code>docker-compose.yml</code> file to run <code>healthcheck.py</code> for sc-server in <code>.venv</code> or use <code>scripts/healthcheck.sh</code> that encapsulates this logic;</li> <li>and use <code>.venv</code> to launch your python scripts if they use sc-machine python dependencies.</li> </ul> </li> <li>Build system of the sc-machine was upgraded:<ul> <li>The way to manage build dependencies was changed to Conan. You can install sc-machine and its dependencies with Conan. You don't have to worry about installing sc-machine dependencies on your OS anymore. See how to do it -- Build System.</li> <li>CMake presets should be used to build the sc-machine. They are located in <code>CMakePresets.json</code>.</li> <li>Location of the sc-machine build was changed. The following new locations are:<ul> <li>build tree -- <code>build/&lt;Debug|Release&gt;</code>, </li> <li>binaries -- <code>build/&lt;Debug|Release&gt;/bin</code>, </li> <li>libraries -- <code>build/&lt;Debug|Release&gt;/lib</code>,</li> <li>extensions -- <code>build/&lt;Debug|Release&gt;/lib/extensions</code>.</li> </ul> </li> <li>Using sc-machine as a library is much more optimized: adding it to the CMake tree is no longer necessary. You can install sc-machine packages and import sc-machine targets into your cmake using <code>find_package(sc-machine REQUIRED)</code>. See how to do it -- Build System</li> <li>Each release sc-machine binaries are being compiled for supported OS and formed as an archives on Github. Minimum required version of macOS is macOS-14 (arm), of ubuntu is ubuntu-22.04. The sc-machine doesn't support ubuntu-20.04 anymore. You can use sc-machine binaries to work with sc-memory or you can use <code>RunMachine</code> method from <code>sc-machine-runner.so</code> to create your own entry point to initialize sc-memory instead of using compiled <code>sc-machine</code> binary.</li> <li>Script for the project build (<code>build_sc_machine.sh</code>), scripts for running binaries (<code>run_sc_server.sh</code>, <code>build_kb.sh</code>) were removed from the sc-machine repository scripts. You should use sc-machine binaries directly.</li> <li>sc-server is no longer entry point of the sc-machine, it is an extension (<code>sc-server-lib.so</code>), that is loaded dynamically when the machine is started. So, <code>sc-server</code> binary was removed, <code>sc-machine</code> binary was added instead. To specify host and port for sc-server without using config, use environment variables <code>SC_SERVER_HOST</code> and <code>SC_SERVER_PORT</code> accordingly.</li> </ul> </li> <li>Config was changed:<ul> <li><code>repo_path</code> option in <code>[sc-memory]</code> group was deprecated, <code>storage</code> option was added instead;</li> <li><code>extensions_path</code> option in <code>[sc-memory]</code> group was deprecated, <code>extensions</code> option was added instead.</li> </ul> </li> <li>Sources of the sc-machine were separated into public and private ones. Public sources of targets are located in <code>include</code> directory, private ones - in <code>src</code> directory, tests for code - in <code>tests</code> directory. Private sources can't be included into project's code directly. Besides that there are changes of location of some API classes of the sc-machine:<ul> <li><code>ScTest</code> class was made a part of <code>sc-memory</code> target. Use <code>#include &lt;sc-memory/test/sc_test.hpp&gt;</code> to include it into code.</li> <li>To include <code>ScsLoader</code> class into code, use <code>#include &lt;sc-builder/sc_loader.hpp&gt;</code>.</li> </ul> </li> <li>Configuration of sc-machine tests was changed:<ul> <li>Paths to test sources of the knowledge base, test configs, etc. are being configured at the pre-run stage, not at the stage of compiling tests.</li> <li>Working directory for tests was changed to a directory where tests are located. To run the tests, please use <code>ctest</code> rather than the test binaries themselves.</li> <li>Scripts for running tests (<code>run_tests.sh</code>) was removed. Go to <code>build/&lt;Debug|Release&gt;</code> and use <code>ctest</code> instead.</li> </ul> </li> <li>All questions was renamed to actions.</li> <li>ScAddrHashFunc with template argument was removed. Use non-template ScAddrHashFunc without arguments. It is more safe in use.</li> <li>Constructors for ScMemoryContext with string and int parameters were removed. Use the one without parameters instead.</li> <li>HelperSearchTemplateInStruct was removed from ScMemoryContext API. Use SearchByTemplate with callbacks.</li> <li>Deprecated sc-utils in 0.9.0 were removed from sc-kpm.</li> <li>Questions were renamed to actions, answers were renamed to results.</li> <li><code>m_memoryCtx</code> in ScAgent renamed to <code>m_context</code>.</li> <li>\u0421ode generation is no longer used as metaprogramming. The API for agents has been completely redesigned. See the documentation section on how to implement an agent with the new API -- C++ Agent Guide. We have<ul> <li>completely moved from code generation to template programming;</li> <li>improved the API and aligned with our description of how it should be;</li> <li>simplified the API. Now it will be much easier to create agents, go right now and see how to work with the new API -- C++ Agents API.</li> </ul> </li> <li>All <code>ScMemoryContext</code> methods were redesigned to a common style. All methods with not correct names were deprecated, and new ones were added. See the table below to see which methods have been replaced.</li> </ul> Deprecated method Substitution method CreateNode GenerateNode CreateLink GenerateLink CreateEdge GenerateConnector GetElementOutputArcsCount GetElementEdgesAndOutgoingArcsCount GetElementInputArcsCount GetElementEdgesAndIncomingArcsCount GetEdgeSource GetArcSourceElement GetEdgeTarget GetArcTargetElement GetEdgeInfo GetConnectorIncidentElements Iterator3 CreateIterator3 Iterator5 CreateIterator5 ForEachIter3 ForEach ForEachIter5 ForEach HelperCheckEdge CheckConnector FindLinksByContent SearchLinksByContent FindLinksByContentSubstring SearchLinksByContentSubstring FindLinksContentsByContentSubstring SearchLinksContentsByContentSubstring HelperSetSystemIdtf SetElementSystemIdentifier HelperGetSystemIdtf GetElementSystemIdentifier HelperResolveSystemIdtf ResolveElementSystemIdentifier HelperFindBySystemIdtf SearchElementBySystemIdentifier HelperGenTemplate GenerateByTemplate HelperSearchTemplate SearchByTemplate HelperSmartSearchTemplate SearchByTemplateInterruptibly HelperBuildTemplate BuildTemplate CalculateStat CalculateStatistics Removed method Substitution method BeingEventsPending BeginEventsPending <ul> <li>All C++ sc-types were also redesigned to a common style. They were deprecated, new ones were added. See changes in the table below.</li> </ul> Deprecated Substitution ScType::EdgeUCommon ScType::CommonEdge ScType::EdgeDCommon ScType::CommonArc ScType::EdgeUCommonConst ScType::ConstCommonEdge ScType::EdgeDCommonConst ScType::ConstCommonArc ScType::EdgeAccess ScType::MembershipArc ScType::EdgeAccessConstPosPerm ScType::ConstPermPosArc ScType::EdgeAccessConstNegPerm ScType::ConstPermNegArc ScType::EdgeAccessConstFuzPerm ScType::ConstFuzArc ScType::EdgeAccessConstPosTemp ScType::ConstTempPosArc ScType::EdgeAccessConstNegTemp ScType::ConstTempNegArc ScType::EdgeAccessConstFuzTemp ScType::ConstFuzArc ScType::EdgeUCommonVar ScType::VarCommonEdge ScType::EdgeDCommonVar ScType::VarCommonArc ScType::EdgeAccessVarPosPerm ScType::VarPermPosArc ScType::EdgeAccessVarNegPerm ScType::VarPermNegArc ScType::EdgeAccessVarFuzPerm ScType::VarFuzArc ScType::EdgeAccessVarPosTemp ScType::VarTempPosArc ScType::EdgeAccessVarNegTemp ScType::VarTempNegArc ScType::EdgeAccessVarFuzTemp ScType::VarFuzArc ScType::NodeConst ScType::ConstNode ScType::NodeVar ScType::VarNode ScType::Link ScType::NodeLink ScType::LinkClass ScType::NodeLinkClass ScType::NodeStruct ScType::NodeStructure ScType::LinkConst ScType::ConstNodeLink ScType::LinkConstClass ScType::ConstNodeLinkClass ScType::NodeConstTuple ScType::ConstNodeTuple ScType::NodeConstStruct ScType::ConstNodeStructure ScType::NodeConstRole ScType::ConstNodeRole ScType::NodeConstNoRole ScType::ConstNodeNonRole ScType::NodeConstClass ScType::ConstNodeClass ScType::NodeConstMaterial ScType::ConstNodeMaterial ScType::LinkVar ScType::VarNodeLink ScType::LinkVarClass ScType::VarNodeLinkClass ScType::NodeVarStruct ScType::VarNodeStructure ScType::NodeVarTuple ScType::VarNodeTuple ScType::NodeVarRole ScType::VarNodeRole ScType::NodeVarNoRole ScType::VarNodeNonRole ScType::NodeVarClass ScType::VarNodeClass ScType::NodeVarMaterial ScType::VarNodeMaterial <p>From now on, all sc-links are sc-nodes. Types of actual and inactual temporal membership sc-arc were added.    Also, all possible combinations of subtypes in sc-types have been added to the API of ScMemoryContext and to the SCs-code.</p> <ul> <li>Incorrect sc.s-connectors were replaced by correct ones.</li> </ul> Deprecated Substitution <code>&gt;</code> <code>?=&gt;</code> <code>&lt;</code> <code>&lt;=?</code> <code>&lt;&gt;</code> <code>?&lt;=&gt;</code> <code>_&lt;=</code> <code>&lt;=_</code> <code>_&lt;-</code> <code>&lt;-_</code> <code>_&lt;|-</code> <code>&lt;|-_</code> <code>_&lt;~</code> <code>&lt;~_</code> <code>_&lt;|~</code> <code>&lt;|~_</code> <ul> <li> <p>It is no longer possible to specify permanency for fuzzy arcs, because it may lead to misunderstanding of the non-factor denoted by this sc-arc. So, designations <code>-/&gt;</code>, <code>&lt;/-</code>, <code>_-/&gt;</code>, <code>_&lt;/-</code>, <code>&lt;/-_</code>, <code>~/&gt;</code>, <code>&lt;/~</code>, <code>_~/&gt;</code>, <code>_&lt;/~</code>, <code>&lt;/~_</code> were removed. Use <code>/&gt;</code>, <code>&lt;/</code>, <code>_/&gt;</code>, <code>&lt;/_</code> instead.</p> </li> <li> <p>Incorrect system identifiers of sc.s-keynodes were also replaced by correct ones.</p> </li> </ul> Deprecated Substitution sc_edge sc_common_edge sc_edge_ucommon sc_common_edge sc_arc_common sc_common_arc sc_edge_dcommon sc_common_arc sc_arc_access sc_membership_arc sc_edge_access sc_membership_arc sc_arc_main sc_main_arc sc_edge_main sc_main_arc sc_node_struct sc_node_structure sc_node_norole_relation sc_node_non_role_relation <ul> <li>Type <code>ScType::NodeAbstract</code> and sc.s-keynode <code>sc_node_abstract</code> were removed.</li> </ul> <p>See documentation, to learn more about using new API.</p>"},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Environment variables <code>SC_SERVER_HOST</code> and <code>SC_SERVER_PORT</code> for sc-server</li> <li><code>SearchLinksByContentSubstring</code> method with <code>ScLinkFilter</code> parameter</li> <li><code>ScLinkFilter</code> class to specify search criteria for sc-links</li> <li>Intro for documentation</li> <li>Quick start section for developers in docs</li> <li>Quick start section for users in docs</li> <li>Documentation for user permissions</li> <li>Allow multiple extension directories for sc-memory</li> <li>CD for publishing sc-machine binaries as archive on Github </li> <li>CI for checking sc-machine tests build with Conan dependencies</li> <li>Install target to prepare consuming sc-machine targets</li> <li>Conan support for managing sc-machine dependencies</li> <li>Handling required options for sc-machine and sc-builder</li> <li>Display versions for sc-machine and sc-builder</li> <li>Doc strings for sc-config classes</li> <li>Implement gwf2scs-translator in cpp</li> <li><code>GetSCsElementKeynode</code> method for sc-types to get their sc.s-keynode system identifiers</li> <li><code>GetDirectSCsConnector</code> and <code>GetReverseSCsConnector</code> for sc-types to get their designations in SCs-code</li> <li>std::string operator for ScType</li> <li>All possible semantic combinations of subtypes in sc-types into the SCs-code</li> <li>All possible combinations of subtypes in sc-types into ScMemoryContext API</li> <li>Type <code>ScType::NodeSuperclass</code> and sc.s-keynode <code>sc_node_superclass</code></li> <li>Types: <code>ScType::Connector</code>, <code>ScType::Arc</code></li> <li>Types of actual and inactual temporal sc-arcs into ScMemoryContext API and the SCs-code</li> <li>Methods in ScMemoryContext: GenerateNode, GenerateLink, GenerateConnector, GetElementEdgesAndOutgoingArcsCount, GetElementEdgesAndIncomingArcsCount, GetArcSourceElement, GetArcTargetElement, GetConnectorIncidentElements, CreateIterator3, CreateIterator5, ForEach, CheckConnector, SearchLinksByContent, SearchLinksByContentSubstring, SearchLinksContentsByContentSubstring, SetElementSystemIdentifier, GetElementSystemIdentifier, ResolveElementSystemIdentifier, SearchElementBySystemIdentifier, GenerateByTemplate, SearchByTemplate, SearchByTemplateInterruptibly, BuildTemplate, CalculateStatistics, BeginEventsPending</li> <li>Simple guide for implementing agent in C++</li> <li>Documentation for agents, keynodes, modules, events, subscriptions, waiters, actions and agent context</li> <li>Full tests for C++ Agents API</li> <li>Opportunity to implement agents with static, dynamic and semi-dynamic specifications</li> <li>Implement <code>ScAgentContext</code> class to work with sc-event, subscriptions and waiters</li> <li>Implement <code>ScAction</code> class to work with sc-actions in sc-memory</li> <li>Implement <code>ScAgentBuilder</code> to handle dynamic specifications for agents</li> <li>Implement <code>ScModule</code> to register agents</li> <li>New implementation of <code>ScKeynodes</code> class to enumerate sc-keynodes</li> <li>Implement <code>ScTemplateKeynode</code> class to represent static object of sc-template</li> <li>Implement <code>ScKeynode</code> class to represent static object of key sc-element used in agents</li> <li>New implementation of <code>ScAgent</code> class for any types of agents</li> <li>Implement <code>ScActionInitiatedAgent</code> class to implement agents interpreting initiated actions</li> <li>Implement sc-event classes hierarchy</li> <li>Implement new C++ Agents API based on template programming</li> <li>Add unordered_map type with <code>ScAddr</code> as key</li> <li>Implement protected method in ScMemoryContext to translate object of <code>ScTemplate</code> to sc-template in sc-memory</li> <li>Doc strings for public template classes</li> <li>Usings <code>ScAddrStack</code>, <code>ScAddrQueue</code>, <code>ScAddrSet</code> and <code>ScAddrHashSet</code></li> <li>Doc strings for iterator classes</li> <li>Clean monitor tables by size threshold</li> <li>Compile option to optimize checking local user permissions</li> <li>Check incidence between sc-connectors and sc-elements substituted into sc-template from sc-template params</li> <li>Generate and search by sc-templates with constant sc-connectors</li> <li>Build sc-templates with constant sc-connectors</li> <li>Opportunity to substitute sc-connectors as params in sc-templates</li> <li>Script <code>healthcheck.sh</code> for <code>healthcheck.py</code></li> <li>Check build and tests on runner-image <code>ubuntu-24.04</code></li> <li>Support for ubuntu-24.04 and macOS 14.4.1</li> <li>Block events mode for sc-memory context; methods <code>BeginEventsBlocking</code> and <code>EndEventsBlocking</code> in <code>ScMemoryContext</code></li> <li>Opportunity to set permissions for set of users</li> <li>Guests identification</li> <li>Create guest users during creating sc-memory context</li> <li>Get user address for sc-server session and sc-memory context</li> <li>Docker entrypoint run to launch binary <code>sc-machine</code> in docker</li> <li>Binary <code>sc-machine</code> instead of binary <code>sc-server</code> that loads extension sc-server</li> <li>Collect user permissions during sc-memory initialize</li> <li>Throw exceptions in get values methods of iterators if sc-element is not accessed</li> <li>Callback to get and collect sc-links by its contents from fs-memory</li> <li>Local user permissions for actions within sc-structures</li> <li>List in sc-element for input arcs from sc-structures</li> <li>Provide sc-arc types for sc-event callbacks</li> <li>User permissions for handling permissions for actions in sc-memory</li> <li>Global user permissions for actions in sc-memory</li> <li>ScType::ConstNodeLinkClass and ScType::VarNodeLinkClass</li> <li>User authentication checks</li> <li>Denote sc-machine with sc-element <code>myself</code></li> <li>Provide users for sc-memory, sc-events and sc-agents</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Improve docs usability: add search, edit links, coping code blocks, logo, text justifying, move sections to header and other </li> <li>SCsParser no longer generates sc-arcs from types of sc-elements to sc-elements</li> <li>Allow multiple instances of <code>ScLogger</code> class</li> <li>Rename <code>ScLog</code> to <code>ScLogger</code></li> <li>Description of project in Readme</li> <li>Working directory for each test has been changed to the test's source dir</li> <li><code>gtest</code> and <code>benchmark</code> are installed via Conan or OS package managers instead of using them as git submodules</li> <li>Location of the sc-machine build tree, binaries, libraries and extensions</li> <li>Bumped minimum required cmake version to 3.24.0</li> <li>Help messages for sc-machine and sc-builder</li> <li>Clarify sc-machine and sc-builder options</li> <li>Specify dependencies near targets, not in overall file</li> <li>Make glib dependencies private</li> <li>Replace public sc-base defines with methods</li> <li>Separate public and private sources</li> <li>Rename action answer to action result</li> <li>Rename <code>ScWait</code> to <code>ScWaiter</code></li> <li>Rename <code>ScEvent</code> to <code>ScEventSubscription</code></li> <li>Make template build methods to throw exceptions instead of return errors</li> <li>Rename questions to actions</li> <li>Use queues in monitors statically</li> <li>Implement array-based sc-queue</li> <li>Clarify error message for building sc-template, generating and searching by sc-template: provide sc-template item features in error message</li> <li>Reformat code style according to clang-format-18</li> <li>Use runner-image <code>macos-14</code> instead of runner-image <code>macos-latest</code> in CI</li> <li>Don't check extensions when loading dynamic modules (<code>g_open_module</code> does it automatically)</li> <li>Use venv for python dependencies in scripts and docker</li> <li>Don't emit events after kb build</li> <li>Allows assigns sc-link to its system identifier</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Validate parameters in handle link content sc-json-command in sc-server</li> <li>Iterating sc-connectors with sc-edge loop</li> <li>Checking of all syntactic and semantic subtypes for types in <code>ScMemoryContext::SetElementSubtype</code> and <code>ScType::CanExtendTo</code> methods.</li> <li>Now sc-link is sc-node</li> <li>sc-arcs and sc-elements are removed after agents have worked with them</li> <li>fs-memory uses monitor to resolve string offset</li> <li>fs-memory searches for new strings in all channels instead of only in last channel</li> <li>Separate implementation from declarations in templates</li> <li>Separate specializations from declarations in iterators</li> <li>Fix duplication of iterator specializations</li> <li>Make sc_addr_hash equal to sc_uint32</li> <li>Make core literal types platform-independent</li> <li>Erasing sc-connectors during iterating</li> <li>Clear result of generating by sc-template if error is occurred</li> <li>Check that template params sc-type can be extended to template item sc-type</li> <li>No discard return types for sc-template API</li> <li>C++ warnings for ubuntu-24.04 and macOS-14.4.1 when building project</li> <li>Use <code>snprintf(3)</code> instead of <code>sprintf(2)</code></li> <li>Private and public dependencies between cmake targets</li> <li>Use reenterable strtok</li> <li>Resolve sc.g-links with the same system identifier</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Config option <code>repo_path</code> in <code>[sc-memory]</code>, add option <code>storage</code> instead</li> <li>Config option <code>extensions_path</code> in <code>[sc-memory]</code>, add option <code>extensions</code> instead</li> <li>Incorrect designations of sc.s-connectors: <code>&gt;</code>, <code>&lt;</code>, <code>&lt;&gt;</code>, <code>_&lt;=</code>, <code>_&lt;-</code>, <code>_&lt;|-</code>, <code>_&lt;~</code>, <code>_&lt;|~</code></li> <li>Incorrect sc.s-keynodes: <code>sc_edge</code>, <code>sc_edge_ucommon</code>, <code>sc_arc_common</code>, <code>sc_edge_dcommon</code>, <code>sc_arc_access</code>, <code>sc_edge_access</code>, <code>sc_arc_main</code>, <code>sc_edge_main</code>, <code>sc_node_struct</code>, <code>sc_node_norole_relation</code></li> <li>C++ sc-types: <code>ScType::EdgeUCommon</code>, <code>ScType::EdgeDCommon</code>, <code>ScType::EdgeUCommonConst</code>, <code>ScType::EdgeDCommonConst</code>, <code>ScType::EdgeAccess</code>, <code>ScType::EdgeAccessConstPosPerm</code>, <code>ScType::EdgeAccessConstNegPerm</code>, <code>ScType::EdgeAccessConstFuzPerm</code>, <code>ScType::EdgeAccessConstPosTemp</code>, <code>ScType::EdgeAccessConstNegTemp</code>, <code>ScType::EdgeAccessConstFuzTemp</code>, <code>ScType::EdgeUCommonVar</code>, <code>ScType::EdgeDCommonVar</code>, <code>ScType::EdgeAccessVarPosPerm</code>, <code>ScType::EdgeAccessVarNegPerm</code>, <code>ScType::EdgeAccessVarFuzPerm</code>, <code>ScType::EdgeAccessVarPosTemp</code>, <code>ScType::EdgeAccessVarNegTemp</code>, <code>ScType::EdgeAccessVarFuzTemp</code>, <code>ScType::NodeConst</code>, <code>ScType::NodeVar</code>, <code>ScType::Link</code>, <code>ScType::LinkClass</code>, <code>ScType::NodeStruct</code>, <code>ScType::LinkConst</code>, <code>ScType::LinkConstClass</code>, <code>ScType::NodeConstTuple</code>, <code>ScType::NodeConstStruct</code>, <code>ScType::NodeConstRole</code>, <code>ScType::NodeConstNoRole</code>, <code>ScType::NodeConstClass</code>, <code>ScType::NodeConstMaterial</code>, <code>ScType::LinkVar</code>, <code>ScType::LinkVarClass</code>, <code>ScType::NodeVarStruct</code>, <code>ScType::NodeVarTuple</code>, <code>ScType::NodeVarRole</code>, <code>ScType::NodeVarNoRole</code>, <code>ScType::NodeVarClass</code>, <code>ScType::NodeVarMaterial</code></li> <li>Methods of <code>ScMemoryContext</code>: CreateNode, CreateLink, CreateEdge,GetElementOutputArcsCount, GetElementInputArcsCount, GetEdgeSource, GetEdgeTarget, GetEdgeInfo, Iterator3, Iterator5, ForEachIter3, ForEachIter5, HelperCheckEdge, FindLinksByContent, FindLinksByContentSubstring, FindLinksContentsByContentSubstring, HelperSetSystemIdtf, HelperGetSystemIdtf, HelperResolveSystemIdtf, HelperFindBySystemIdtf, HelperGenTemplate, HelperSearchTemplate, HelperSmartSearchTemplate, HelperBuildTemplate, CalculateStat</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Support for ubuntu-20.04</li> <li>Config options <code>update_period</code> and <code>save_period</code> in <code>[sc-memory]</code> deprecated in 0.9.0</li> <li>Config option <code>sync_actions</code> in <code>[sc-server]</code> deprecated in 0.9.0</li> <li>Scripts: <code>build_sc_machine.sh</code>, <code>build_kb.sh</code>, <code>run_sc_server.sh</code>, <code>set_vars.sh</code> and <code>run_tests.sh</code></li> <li><code>sc-server</code> binary and docker entrypoint command <code>serve</code></li> <li>gwf2scs-translator in python</li> <li>Designations of fuzzy sc.s-arcs: <code>-/&gt;</code>, <code>&lt;/-</code>, <code>_-/&gt;</code>, <code>_&lt;/-</code>, <code>&lt;/-_</code>, <code>~/&gt;</code>, <code>&lt;/~</code>, <code>_~/&gt;</code>, <code>_&lt;/~</code>, <code>&lt;/~_</code></li> <li>Type <code>ScType::NodeAbstract</code> and sc.s-keynode <code>sc_node_abstract</code></li> <li>Methods of <code>BeingEventsPending</code>: BeingEventsPending</li> <li>Codegen and C++ Agents API based on code generation</li> <li>Deprecated sc-utils in 0.9.0</li> <li>Constructors for ScMemoryContext with string and int parameters</li> <li>HelperSearchTemplateInStruct from ScMemoryContext</li> <li>Template argument for <code>ScAddrHashFunc</code></li> <li>Throw <code>utils::ExceptionInvalidParams</code> if template params have sc-connectors substitution for generating by sc-template</li> <li>GetDecompositionAgent</li> <li>Sc-links lists translation from C API to C++ API</li> </ul>"},{"location":"changelog/#090-unlock-22012024","title":"[0.9.0-Unlock] - 22.01.2024","text":""},{"location":"changelog/#breaking-changes_1","title":"Breaking changes","text":"<ul> <li>All methods in C++ API for managing sc-memory throws exceptions if passed params are not valid or memory state is not valid</li> <li>All methods in C API for managing sc-memory returns error codes if passed params are not valid or memory state is not valid</li> <li>Removed deprecated sc-utils in 0.6.0, 0.7.0 and 0.8.0</li> <li>Removed deprecated make_all.sh</li> </ul>"},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Config option <code>limit_max_threads_by_max_physical_cores</code> in <code>[sc-memory]</code> to limit max threads by max physical threads</li> <li>Config options <code>dump_memory</code> and <code>dump_memory_statistics</code> in <code>[sc-memory]</code> for enabling sc-memory dumps</li> <li>Full md docs for sc-memory API on C++ with examples</li> <li>ScTemplate replacement presence check using varAddr</li> <li>CreateIterator5 AAAAF</li> <li>Divide params errors handling and memory state handling</li> <li>Provide errors and exceptions information into C and C++ sc-memory API</li> <li>Support for gwf &lt;0.4.0</li> <li>Monitors for processes and thread synchronization</li> <li>Monitors tables for sc-addresses monitors and sc-event monitors</li> <li>Distribution of sc-segments by active processes and threads</li> <li>Internal sc-storage sc-segment-built-in lists for not engaged and freed sc-elements</li> <li>Clarify events managers for sc-storage: pick out subscription and emission managers</li> <li>Clarify context manager for sc-memory</li> <li>Common secured interface for sc-memory</li> <li>GetDecompositionAgent</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Optimize and move sc-memory dumps from sc-server to sc-memory</li> <li>Refactor all code by .clang-format 18.0.0</li> <li>Replace hyphens by underscores in files</li> <li>Replace underscores by hyphens in folders</li> <li>Update codestyle guide</li> <li>Update contributing guide</li> <li>Update .clang-format to 18.0.0</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Separate setups for sc-server and sc-builder from main.cpp and test</li> <li>Script scg.min.js styles handling for sc.g-element types of KBE &gt;0.4.0</li> <li>Sc.g-elements images in docs</li> <li>Support recursive curl braces in SCs-code level 2</li> <li>Support semantic sc-types for sc-node in SCs-code level 1</li> <li>Support sc-links for SCs-code level 1</li> <li>HelperBuildTemplate with params that have varAddr replacements</li> <li>Warnings for GNU compilers</li> <li>Warnings in sc-machine about deprecated methods</li> <li>Behavior of the agent_erase_elements on not his action classes</li> <li>Deleting existing and translated .scs sources with the same name</li> <li>Parse contours identifiers by gwf2scs-translator</li> <li>Symmetric sc-edges search</li> <li>sc-machine crashes when trying to view a picture in sc-web (311)</li> <li>No tests for ScMemory::Initialize(sc_memory_params) with different parameters (216)</li> <li>Too big number in websocket request crusher sc-server (309)</li> <li>Handle crush errors (63)</li> <li>Usage of invalid addresses after rerun failed sc-server (79)</li> <li>Invalid addrs crushes sc-iterator methods usages (66)</li> <li>All deadlocks and segfaults in sc-storage, sc-events and fs-memory (111)</li> <li>Processes and thread starvation</li> <li>Active waiting during sc-events deletion</li> <li>List items semicolons for sc.s-contours</li> <li>Internal sentences after sc.s-contour assignment</li> <li>Success of finishing the action is marked first and only then that it was finished</li> <li>Finish agent wait time</li> </ul>"},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li>Config option <code>sync_actions</code> in <code>[sc-server]</code>, add option <code>parallel_actions</code> instead of</li> <li>Config option <code>update_period</code> in <code>[sc-memory]</code>, add option <code>dump_memory_statistics_period</code> instead of</li> <li>Config option <code>save_period</code> in <code>[sc-memory]</code>, add option <code>dump_memory_period</code> instead of</li> <li>Method <code>getLinkContent</code> in sc-utils </li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li><code>sc::ResolveRelationTuple</code> and <code>sc::SetRelationValue</code></li> <li>Deprecated sc-utils in 0.6.0, 0.7.0 and 0.8.0</li> <li>Deprecated make_all.sh</li> <li>Runtime asserts usage in sc-storage</li> <li>Atomic operations usage in sc-storage</li> <li>Locks usage in sc-storage</li> </ul>"},{"location":"changelog/#080-fusion-24092023","title":"[0.8.0-Fusion] - 24.09.2023","text":""},{"location":"changelog/#breaking-changes_2","title":"Breaking changes","text":"<ul> <li>Now we use C++17 instead of C++14</li> <li>We support compatibility with old memory binaries</li> </ul>"},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Add and get addresses by variable addresses in ScTemplateParams API</li> <li>Check sc-types in sc-memory API sc-elements creation methods</li> <li>Ability do not search for sc-links by substrings globally, passing config param <code>search_by_substring</code></li> <li>Ability do not search for sc-links by strings locally, passing param in SetLinkContent <code>is_searchable</code></li> <li>Generalize all scripts for applied projects</li> <li>Script <code>build_sc_machine.sh</code> with arguments <code>-f</code> <code>-t</code> and <code>-r</code> instead of <code>make_all.sh</code></li> <li>View kb fragment in scn if it is keyword</li> <li>Tests for repo-path parser and sources collector in <code>sc-builder</code></li> <li>Support for deprecated memory binaries build in 0.7.0 version</li> <li>Synchronize processes that works with file memory and sc-dictionary</li> <li>Get replacements in template result by variable addresses</li> <li>Divide strings file into more small files with fixed size by requested configs <code>max_strings_channels</code> and <code>max_strings_channel_size</code></li> <li>Configuration of docker-compose.yml using .env file</li> <li>Script <code>run_tests.sh</code></li> <li>Full tests for file memory API</li> <li>Intersect/unite search sc-links by strings and substrings in file memory</li> <li>Search strings and sc-link hashes by terms in file memory</li> <li>File memory on file system, save strings in file system disks</li> <li>Configure events and agents threads in sc-memory, passing config param <code>max_events_and_agents_threads</code></li> <li>Loop-ranged API method for sc-template search (78)</li> <li>Full tests for sc-template API</li> <li>Sc-template cycle preventing search</li> <li>Sc-template equal triples search</li> <li>Sc-template search API to get and use constructions step by step</li> <li>Sc-template search API to custom filter constructions with step by step search</li> <li>Sc-template search API with request commands (continue search, stop search and error during search)</li> <li>Cover all sc-template search and gen API with tests</li> <li>Order triples by type and dependencies with other triples</li> <li>Count input/output edges in elements during edges adding</li> <li>Order triples by input/output edges count for triple items</li> <li>Determined sc-template depth-first search</li> <li>Sc-template safe API without exceptions handling</li> <li>Extend create elements by SCs in <code>sc-server</code> with outputStructure field</li> <li>Write docs for system identifier set/get/find/resolve sc-memory API</li> <li>Extend set/get/find/resolve sc-memory API with out system identifier fiver parameters</li> <li>Insert sc-keynodes in global knowledge base during sc-memory initiation</li> <li>Save sc-memory by period in sc-server, passing config param <code>save_period</code> in seconds</li> <li>Dump statistics by period in sc-server, passing config param <code>update_period</code> in seconds</li> <li>Agent for erasing sc-elements not belonging to the global structure <code>init_memory_generated_structure</code></li> <li>Transfer init memory generated structure to modules initialization, passing config params <code>init_memory_generated_upload</code> and <code>init_memory_generated_structure</code></li> <li>Possibility to skip keys defined in .ini config file in ScConfig</li> <li>Pre-commit code style checks for C++ and Python</li> <li>Add reversed edges according to standart</li> <li>Sc-links classes <code>![]!</code> in SCs</li> <li>Insert sc-keynodes and their system identifiers in global knowledge base during sc-memory initiation</li> <li>Extend create elements by SCs in <code>sc-server</code> with outputStructure field</li> <li>Write docs for system identifier set/get/find/resolve sc-memory API</li> <li>Extend set/get/find/resolve sc-memory API with outer system identifier fiver parameters</li> <li>CI for documentation build</li> <li>Add output structure builder feature to config</li> <li>Add validation of system identifier</li> <li>Append generated elements by <code>SCs-helper</code> into requested output structure</li> <li>Oriented sets representation () in SCs <li>Build docs in SCn format separately from <code>ostis-web-platform</code></li>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Replace asserts in sc-memory API by exceptions throwing</li> <li>Refactor sc-server logs</li> <li>Decrease wait time for sc-element referencing in iterators</li> <li>Call gwf-translator in sc-builder</li> <li>Move repo path parser from Python to C++ in sc-builder</li> <li>Unite ScTemplateGenResult and ScTemplateSearchResultItem into ScTemplateResultItem</li> <li>Remove list to array translations in C API for file memory</li> <li>Upload text and binary files in realtime by get API</li> <li>Remove string lengths recount in file memory</li> <li>Optimize int to string translation in file memory</li> <li>Use iterators instead of sc-template in <code>getNextFromSet</code> util</li> <li>Generalized <code>docker_entrypoint.sh</code>, this script can be used by external projects now</li> <li>Now in tests all agents works in single thread</li> <li>Replace asserts in sc-template search and gen API by exceptions throwing</li> <li><code>ScsLoader::loadScsFile</code> return bool instead void</li> <li>Update garbage deletion agent logic, add check if element belongs to init memory structure</li> <li>Make scsi pre-processor migrations script</li> <li>Move to C++17</li> <li>Remove 1 minute assert in <code>ScWait</code></li> <li>Add language parameter for sc2scs-json-translator to get elements identifiers</li> <li>Append to sc2scs-json elements main/system identifiers</li> <li>Replace row strings by nlohmann-json in sc2scs-json-translator</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Check OS type in <code>install_dependencies.sh</code></li> <li>Check apt command for Linux OS in <code>install_deps_ubuntu.sh</code></li> <li>Create sc-links with ScType::Link type in Debug mode</li> <li>Change memory statistics fields types from sc_uint32 to sc_uint64</li> <li>Return empty sc_addr if not found by identifier in <code>sc-helper</code></li> <li>Build kb script doesn't ignore whitespace (239)</li> <li>Docker entrypoint throws integer expression expected (267)</li> <li>KB directory coping to prepare gwf and scsi sources </li> <li>Tests for template build and gen with params</li> <li>Aliases checking in build by scs</li> <li>Not use system identifiers of vars in sc-template-build</li> <li>Sc-template search by empty template (65)</li> <li>Segfaults in test sc-client</li> <li>Creating sc-keynodes without defining type. Now they will be created with const node type.</li> <li>Converting to string params from configs</li> <li>Fix hashes size in fs-storage (45)</li> <li>GetLinkContent skip whitespaces in strings</li> <li>No inserting system identifiers of keynodes to output structure (223)</li> <li><code>SCs-helper</code> doesn't return generated identifier links (207)</li> <li>No json string message parsing in <code>sc-server</code> (WebSocket request dumps sc-machine) (190)</li> <li>SCs-file dumps kb-builder by WebSocket (189)</li> <li><code>SCs-parser</code> create structure twice</li> <li><code>SCs-parser</code> doesn't unite all generated elements into structure (205)</li> <li>Link deletion (193)</li> <li>Add curl to installation script</li> <li>Fix memory clear parameter reading from .ini config file</li> <li>Merging identifiers in sc-dictionary (192)</li> <li>Dependence order in var template search triples (186)</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Windows files and cmake dependencies</li> <li>Prepare kb step and <code>prepare_kb.py</code></li> <li>Rocksdb file memory</li> <li>Garbage deletion agent</li> </ul>"},{"location":"changelog/#070-rebirth-12102022","title":"[0.7.0-Rebirth] - 12.10.2022","text":""},{"location":"changelog/#breaking-changes_3","title":"Breaking changes","text":"<ul> <li>Binaries are built in the <code>bin</code> folder located near the CMake build tree. This will affect any project using sc-machine as a CMake subproject.</li> <li>Add <code>;</code> after <code>SC_LOG_INFO</code>, <code>SC_LOG_DEBUG</code>, <code>SC_LOG_WARNING</code> and <code>SC_LOG_ERROR</code> calls in projects that use sc-machine.</li> <li>Add <code>;</code> after <code>SC_ASSERT</code> calls in projects that use sc-machine.</li> <li>Remind that all binary content are stored in sc-fs-storage as base64 string.</li> <li>sctp-server was removed, move to sc-server usage.</li> <li>sc-machine doesn't support ubuntu versions lower than 20.04.</li> </ul>"},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Implement sc-link content removing from sc-storage</li> <li>Add command to find links contents by content substring into sc-server</li> <li>Implement find links contents by content substring into sc-server</li> <li>CI for docker build and run</li> <li>CI for ubuntu-22.04 and latest macOS</li> <li>Add ScExec class to execute system commands</li> <li>Test for utils for work with actions and their results</li> <li>Handle and save sc-server subcommands errors</li> <li>Add sc-server healthcheck</li> <li>Add tests for sc-search agents in sc-kpm</li> <li>Write sc-machine idea into readme</li> <li>Add create elements by scs-helper through sc-server</li> <li>Add CI workflow for sanitizers</li> <li>Add find links by substring in sc-server</li> <li>Initial development container support</li> <li>You can now run sc-machine in Docker</li> <li>Unite configuration for sc-server and sc-builder</li> <li>Write docs in scn-latex for sc-server</li> <li>Implement sc-memory configurator</li> <li>Implement sc-options for sc-server and sc-builder usages</li> <li>Implement sc-server on C++</li> <li>Add string API for set and get link content</li> <li>Add opportunity to search sc-links in <code>sc-dictionary</code> by content substr</li> <li>Excludes for files and folders in repo.path</li> <li>Automatic usage of ccache to speed up builds</li> <li>Add CI for <code>rocksdb</code> and <code>sc-dictionary</code></li> <li>Implement <code>sc-dictionary</code>. Add opportunity to switch <code>rocksdb</code> and <code>sc-dictionary</code></li> <li>Wrap and separate allocating, assertion, notification and atomic lock free procedures</li> <li>Add tests module for sc-agents-utils</li> <li>Add opportunity to configure sc-machine version from CMakeLists.txt</li> <li>Add scripts to build kb, run sctp-server and run sc-server</li> <li>New flag options for build_kb</li> <li>Add default python modules paths to python initialization</li> <li>United config file</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Fix sc-server json casts to strings</li> <li>Check sc-server run in tests</li> <li>Flag --tests for sc-server to run and quick stop it</li> <li>Fix glib casts on ubuntu-20.04 and macOS</li> <li>Store binary content as base64 string</li> <li>Update action utils to use the new logic for waiting for action results</li> <li>Fix logic of waiting for action results</li> <li>Entrypoint of Docker image is now easier to work with</li> <li>Update commit badges</li> <li>Up codecov target from 40% to 75%</li> <li>Up codecov level from 62% to 78%</li> <li>Separate ci workflow: check pr-commit, codestyle and tests</li> <li>Revamped README.md</li> <li>Unify sc-builder and sc-server config and params usage</li> <li>Change sc-machine config file structure</li> <li>Fix gwf2scs-translator. Add opportunity to parse russian identifiers</li> <li>Simplify main CMakeLists.txt</li> <li>Add tools macros for main CMakeLists.txt</li> <li>Separate dependencies specifying from main CMakeLists.txt</li> <li>Correct typos</li> <li>Fix warnings in sc-memory modules</li> <li>Fix scs-grammar. Add opportunity to specificate a structure into this structure itself</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li>Remove find by substring logic from sc-dictionary</li> <li>Remove legacy gwf-translator for 0.3.0 gwf sources from sc-builder</li> <li>Remove legacy glib-based tests</li> <li>Remove boost usage for options parsing in sc-server and sc-builder</li> <li>Unlink boost-python-lib from sc-machine</li> <li>Remove mkdocs for sc-server</li> <li>Remove sc-python-interpreter support</li> <li>Remove sc-python-module support</li> <li>Remove python sc-server</li> <li>Move logic rule utils and keynodes to ostis-inference</li> <li>Remove sctp-server</li> <li>Remove scp-interpreter</li> </ul>"},{"location":"changelog/#061-27042022","title":"[0.6.1] - 27.04.2022","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Search by template with params in C++ API</li> <li>Sanitizers</li> <li>Benchmarks</li> <li>Clang code formatting</li> <li>Common utils for C++ API</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Migrate test system to <code>gtest</code></li> <li>Update macOS install_deps script</li> <li>Multithreaded build process used by default</li> <li>Move changelog to Keep a Changelog format</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":"<ul> <li>Moved React web interface in a separate new repository.</li> <li>Remove optional search triples support</li> </ul>"},{"location":"changelog/#v060","title":"v0.6.0","text":"<ul> <li> <p>Build system:</p> </li> <li> <p>Add support of OSX platform</p> </li> <li>Fix compilation with <code>clang</code></li> <li>Disable <code>SCP</code> and <code>SCTP</code> compilation by default</li> <li>Support of C++14</li> <li>Use Ubuntu 18.04 on Travis CI</li> <li> <p>Upgrade <code>libclang</code> to version 7</p> </li> <li> <p>Tools:</p> </li> <li> <p>Support custom extensions loading in <code>sc-builder</code></p> </li> <li>Add <code>sc-server</code> application to run claen <code>sc-memory</code> with extensions</li> <li>Refactored code generation tool</li> <li> <p>Refactored knowledge base tool</p> </li> <li> <p>Core:</p> </li> <li> <p>Support list of enabled extensions</p> </li> <li>Support all possible combinations of <code>sc_iterator3</code></li> <li>Support variable <code>sc-links</code></li> <li>Fix bug with repo directory write attributes</li> <li>Fix issue with extension loading on windows</li> <li>Fix issue with empty content of <code>sc-link</code></li> <li> <p>Refactored file memory to use rocksdb</p> </li> <li> <p>C++:</p> </li> <li> <p>Implement optional search triples support</p> </li> <li>Fix random crash of unittest</li> <li>Improve test system</li> <li>Replace <code>antlr3</code> with <code>antlr4</code> for <code>SCs-text</code> parsing</li> <li>Support of <code>SCs-text</code> aliases</li> <li>Support of 5 and 6 levels of <code>SCs-text</code></li> <li>Refactored test system</li> <li>Refactored API of <code>ScLink</code> and <code>ScStream</code></li> <li> <p>Add generation of structure from <code>SCs-text</code></p> </li> <li> <p>Python:</p> </li> <li> <p>Refactored test system</p> </li> <li>Support SCs-templates in WebSocket protocol</li> <li>Add support of template building from <code>SCs-code</code> string</li> <li>Add <code>Aliases</code> method to <code>ScTemplateSearchResult</code> and <code>ScTemplateGenResult</code></li> <li>Fix issue with float/double values support</li> <li>Add support of logs inside python modules</li> <li> <p>Support <code>ActionAgent</code> states</p> </li> <li> <p>KPM:</p> </li> <li> <p>web:</p> <ul> <li>Implement <code>http</code> module to access memory via Web interface</li> <li>Implement web browser interface to access <code>sc-memory</code></li> </ul> </li> <li> <p>Remove of <code>sc-merge</code> module</p> </li> <li> <p>Documentation:</p> </li> <li>Improve <code>SCs-code</code> documentation. Add levels <code>5</code> and <code>6</code></li> </ul>"},{"location":"changelog/#v050","title":"v0.5.0","text":"<ul> <li> <p>Build system:</p> </li> <li> <p>Add Visual Studio 2017 support</p> </li> <li> <p>Core:</p> </li> <li> <p>Fix bug with repository save (case when it output directory doesn't exist)</p> </li> <li> <p>C++:</p> </li> <li> <p>Fix bugs in python GIL work</p> </li> <li>Fix python threading</li> <li>Fix problem with twicely pass of edge in template search</li> <li>Fix problem with stack overflow on large template search</li> <li>Fix some python wrapping functions</li> <li>Improve <code>ScType</code> class</li> <li>Add types support in SCs-parser</li> <li>Add keynode cache</li> <li>Add <code>ScTemplate</code> build from SCs-text</li> <li> <p>Add support of pending events. Now events emit after whole template generated</p> </li> <li> <p>Python:</p> </li> <li> <p>Add <code>ScAgent</code> class</p> </li> <li>Improve custom main cycle in <code>ScModule</code></li> <li>Improve python testing</li> <li> <p>Implement <code>ScHelper</code> class</p> </li> <li> <p>Tools:</p> </li> <li> <p>Fix error handling in sc-builder</p> </li> <li> <p>Fix <code>show-filenames</code> parameter processing in sc-builder</p> </li> <li> <p>Documentation</p> </li> <li>Update documentation theme</li> <li>Improve python library documentation</li> <li>Support <code>SCs-syntax</code> highlight in documentation</li> </ul>"},{"location":"changelog/#v041","title":"v0.4.1","text":"<ul> <li>Add <code>ScSet</code> and <code>ScRelationSet</code> in python common library</li> <li>Add <code>ScPythonService</code> into C++ (allow to implement threaded python services)</li> <li>Add <code>GetType</code> and <code>AsBinary</code> functions into Python for a link content</li> <li>Add colors to python output</li> <li>Add signal handler to handle <code>Ctrl + C</code></li> <li>Fix bug with python modules search path initialization</li> <li>Fix bug with python threading</li> <li>Fix bug with builder run</li> <li>Fix bug with <code>ScLock</code></li> <li>Fix bug with Python interpreter shutdown</li> <li>Fix bug with <code>int8_t</code> type support in python bindings</li> <li>Fix bug with template generation, when pass parameter to triple with type that has no constancy flag</li> <li>Fix errors catch during collect python modules</li> <li>Refactoring of C++ Python bridge</li> </ul>"},{"location":"changelog/#v040","title":"v0.4.0","text":"<ul> <li>Add events support in Python scripts</li> <li>Improve Python scripts run</li> <li>Add common libraries for a Python</li> <li>Fix memory leaks in core</li> <li>Improve test logging</li> <li>Improve work with memory buffers</li> <li>Cleanup API</li> <li>Add support of python 3 code</li> <li>Add <code>ScLockScope</code> class</li> <li>Implement multithreaded python script run</li> <li>Pass <code>cpp_bridge</code> into python script</li> <li>Extract <code>ScWaitEvent</code> as a separated class from <code>ScWait</code></li> <li>Some fixes in template search</li> <li>Make log thread safe</li> <li>Implement <code>ScLink</code> wrapper class</li> <li>Add <code>ScBase64</code> encode/decode functions</li> <li>Add common templates generation (see <code>sc_common_templ.hpp</code>)</li> </ul>"},{"location":"changelog/#v031","title":"v0.3.1","text":"<ul> <li>Fix templates search error (problems was with triples search order)</li> <li>Implement logging for load extension module problems</li> <li>Remove <code>nl</code>, <code>iot</code> modules from kpm, because they are project specific (moved to a separate repo)</li> <li>Add <code>ForEach</code> function into template search result</li> <li>Add <code>ForEachIter</code> functions into <code>ScMemoryContext</code></li> <li>Add <code>ScSet</code> class</li> <li>Add support of http requests</li> </ul>"},{"location":"changelog/#v030","title":"v0.3.0","text":"<ul> <li>Implement search for elements, that has no constancy flag in a type</li> <li>Fix template search error (#251)</li> <li>Fix problem with <code>SC_ASSERT</code> compilation in release mode (#249)</li> <li>Implement SCs-text parser (levels 1 - 4)</li> <li>Agent <code>AApiAiParseUserTextAgent</code> can run commands</li> <li>Implement common function to work with commands in knowledge base</li> <li>Add support of keynode types in codegenerator. Now you can specify type of keynode that would be used to create it: <code>ForceCreate(ScType::Node...)</code></li> <li>Rename module funcitons from <code>initialize</code>, <code>shutdown</code>, <code>load_priority</code> to <code>sc_module_initialize</code>, <code>sc_module_shutdown</code>, <code>sc_module_load_priority</code></li> <li>Update code to codestyle. Most functions was renamed from <code>functionName</code> to <code>FunctionName</code>. Iterator <code>value</code> function replaced with <code>Get</code>.</li> <li>Implement support of result codes for action agents</li> <li>Improve unit test system</li> <li>Add MkDocs documentation generator support</li> <li>Add <code>clang-format</code> config</li> <li>Add codestyle document</li> <li>Add documentation for <code>C++</code> API</li> <li>Implement multithreaded emit of sc-events</li> <li>Implement ref counter for sc-elements</li> <li>Cover whole functionality of <code>C++</code> API by unit tests</li> <li>Implement <code>C++</code> API</li> </ul>"},{"location":"docker/","title":"Docker","text":""},{"location":"docker/#using-sc-machine-inside-docker","title":"Using sc-machine inside Docker","text":"<p>All our releases are automatically uploaded to Docker Hub, so to start using our latest release it's enough to have Docker installed and configured (please note that Docker from <code>snap</code> and Debian's/Ubuntu's repo are known to be broken, install using the official guide).</p>"},{"location":"docker/#launch","title":"Launch","text":"<p>To pull the sc-machine image from DockerHub and run it, follow these steps:</p> <pre><code># build knowledge base (see below for details)\ndocker compose run --rm machine build\n# launch machine\ndocker compose up\n</code></pre> <p>Generally you would want to use a knowledge base source folder alongside sc-machine. To do that, create a \"kb\" folder in the root of the project and place the KB sources in it. After that build it using the command described above (or enable autorebuild as shown below).</p> <p>By default we expect you to place a repo.path file inside the <code>./kb</code> folder, but in case you don't have one you can configure to build the folder itself by modifying the <code>.env</code> file:</p> <pre><code>+KB_PATH=\"/kb\"\n</code></pre> <p>If you want to auto-rebuild the knowledge base on sc-machine restart, you can also configure this behavior in the <code>.env</code> file:</p> <pre><code>+REBUILD_KB=1\n</code></pre>"},{"location":"docker/#docker_entrypointsh","title":"docker_entrypoint.sh","text":"<p>Our Docker entrypoint script has two commands: <code>build</code> and <code>run</code>. The former is used to build or update knowledge base, and the latter is used to launch <code>sc-machine</code>. You can use it in your own projects that use sc-machine as the entrypoint. Don't forget to configure custom binary and knowledge base paths. Consult with the <code>docker-entrypoint.sh --help</code> for the full list of available flags.</p>"},{"location":"docker/#rebuild-image","title":"Rebuild image","text":"<p>In case you want to run your own, changed version of <code>sc-machine</code> or you made some contributions that require changes to the image, use our <code>Dockerfile</code> to build a new version of the image. To rebuild the image, launch <code>docker build . -t ostis/sc-machine</code> in the root folder of this project. You'll be able to launch it using <code>docker compose up</code> afterwards.</p>"},{"location":"quick_start/","title":"Quick Start","text":"<p>Note</p> <p>The sc-machine can't be used on Windows.</p>"},{"location":"quick_start/#use-sc-machine-as-a-c-library-in-your-project","title":"Use sc-machine as a C++ library in your project","text":""},{"location":"quick_start/#conan","title":"Conan","text":"<p>You can use Conan to install sc-machine. To integrate sc-machine into your project using Conan, follow these steps:</p> <ol> <li> <p>Create a <code>conanfile.txt</code> in your project root with the following content:</p> <pre><code>[requires]\nsc-machine/&lt;version&gt;\n</code></pre> <p>The latest version of the sc-machine is 0.10.5.</p> </li> <li> <p>Install pipx first using guide: https://pipx.pypa.io/stable/installation/.</p> </li> <li> <p>Update CMake to 3.24:</p> <pre><code>pipx install cmake\npipx ensurepath\n</code></pre> </li> <li> <p>Install Conan if not already installed:</p> <pre><code>pipx install conan\npipx ensurepath\n</code></pre> </li> <li> <p>Relaunch your shell after installation.</p> <pre><code>exec $SHELL\n</code></pre> </li> <li> <p>Add the OSTIS-AI remote Conan repository:</p> <pre><code>conan remote add ostis-ai https://conan.ostis.net/artifactory/api/conan/ostis-ai-library\n</code></pre> </li> <li> <p>Install sc-machine and its dependencies:</p> <pre><code>conan install . --build=missing\n</code></pre> </li> <li> <p>Import sc-machine targets into your CMake project by using:</p> <pre><code>find_package(sc-machine REQUIRED)\n</code></pre> </li> <li> <p>Start building! Refer to our C++ Guide on how to quickly develop an sc-machine agent in C++ from scratch.</p> </li> </ol>"},{"location":"quick_start/#github-releases","title":"GitHub Releases","text":"<p>You can download pre-built artifacts from GitHub Releases. Extract it to any location, then make it available to CMake by appending folder path to <code>CMAKE_PREFIX_PATH</code>:</p> <pre><code>set(FABULOUS_PROJECT_SC_MACHINE_PATH \"/path/to/extracted/sc-machine\" \n    CACHE PATH \"sc-machine installation path\"\n)\n\nlist(APPEND CMAKE_PREFIX_PATH ${FABULOUS_PROJECT_SC_MACHINE_PATH})\n</code></pre> <p>Find more info on installation methods on the build system page (including some more advanced snippets for CMake).</p>"},{"location":"quick_start/#install-sc-machine-as-a-service","title":"Install sc-machine as a service","text":"<p>It's possible to use sc-machine through a WebSocket API. Docs for our WebSocket API clients in Python and TypeScript are available in the respective repositories. You might want to check sc-web for a more user-friendly interface as well.</p>"},{"location":"quick_start/#docker","title":"Docker","text":"<p>We provide a Docker image for this project. Here's a quick snippet on how to launch it.</p> <pre><code># clone the repo\ngit clone https://github.com/ostis-ai/sc-machine\ncd sc-machine\n# create empty knowledge base sources folder\nmkdir kb\n# note: at this stage you can move your KB sources to the ./kb folder\n\n# build knowledge base\ndocker compose run --rm machine build\n# run sc-machine\ndocker compose up\n</code></pre> <p>Head to Installing with Docker to learn more. Using Docker is the recommended way to deploy sc-machine in production.</p>"},{"location":"quick_start/#native","title":"Native","text":"<p>Note</p> <p>Currently, running sc-machine natively on Windows isn't supported.</p> <p>Download the sc-machine release for your platform and run it on your system:</p> <pre><code># create empty knowledge base sources folder\nmkdir kb\n# note: at this stage you can move your KB sources to the ./kb folder\n\ncd sc-machine-&lt;version&gt;-&lt;platform&gt;\n# build knowledge base\n./bin/sc-builder -i ../kb -o ../kb.bin --clear\n# run sc-machine\n./bin/sc-machine -e lib/extensions -s ../kb.bin \n# kb.bin will become your KB persistence folder\n</code></pre> <p>In case you want to make changes to the project sources, please refer to the build system docs.</p>"},{"location":"quick_start/#config","title":"Config","text":"<p>This repository provides a default configuration for the sc-machine. To customize the sc-machine to suit your needs you can create your own config file.</p>"},{"location":"build/build_system/","title":"Build System","text":""},{"location":"build/build_system/#implementation-details","title":"Implementation details","text":"<p>The project uses CMake as the build system generator. CMake allows for cross-platform builds and provides the necessary flexibility for both project development and its use in external projects.</p> <p>Conan is integrated as an optional dependency manager via dependency resolver mechanism introduced in CMake 3.24 (see <code>cmake/conan_provider.cmake</code>). Conan helps us manage external libraries and allows us to create reproducible developer environment with ease. However, the build system is designed to work without Conan if needed.</p>"},{"location":"build/build_system/#compilation-steps","title":"Compilation steps","text":"<p>Warning</p> <p>Our build system settings require using CMake 3.24 or newer. Make sure your version is compatible by running <code>cmake --version</code> and use the CMake installation guide to upgrade to latest version if yours is older than 3.24. The universal method is to use <code>pipx install cmake</code> (don't forget to run <code>pipx ensurepath</code> and relaunching your shell after installation <code>exec $SHELL</code>), but you may choose reconfiguring your OS's package manager instead.</p> <p>Warning</p> <p>By default, our build system use the Ninja generator for building (see CMakePresets.json). Ensure that Ninja is installed and properly configured in your environment. To upgrade it, use <code>pipx install ninja</code>. Don't forget to run <code>pipx ensurepath</code> and relaunching your shell after installation <code>exec $SHELL</code>.</p> <p>Typical configurations of the project are provided in the <code>CMakePresets.json</code> file \u2013 this means that if you use a modern IDE, no additional configuration is needed. Just pick one of the configurations provided by this file and use controls in your IDE to recompile and run tests (should work with VSCode + CMake Tools extension, JetBrains CLion and probably many others).</p> <p>If you wish to use CLI instead, you can list all the available configurations in the <code>CMakePresets.json</code> file and pick one of the presets:</p> <pre><code>cmake --list-presets\n</code></pre>"},{"location":"build/build_system/#configure-presets","title":"Configure presets","text":"<p>These presets define how the project is configured before building.</p> Name Description Purpose <code>debug</code> Debug config with tests and benchmarks Use for debugging and testing during development. <code>debug-conan</code> Debug config with tests and benchmarks (Conan dependencies used) Use if you are utilizing Conan for dependency management. <code>release</code> Release config Use for production-ready builds. <code>release-conan</code> Release config (Conan dependencies used) Use if you are utilizing Conan for dependency management. <code>release-with-tests</code> Release config with tests Use for production builds that require testing. <code>release-with-tests-conan</code> Release config with tests (Conan dependencies used) Use if you want to run tests in a production build using Conan."},{"location":"build/build_system/#build-presets","title":"Build presets","text":"<p>These presets are linked to the configure presets and are used by CMake to determine the build folder (<code>build/Debug</code> or <code>build/Release</code> by default).</p> Name Configure Preset <code>debug</code> debug, debug-conan <code>release</code> release, release-conan, release-with-tests, release-with-tests-conan <p>The build artifacts will be located in the <code>build/&lt;Release|Debug&gt;/bin</code> folder.</p>"},{"location":"build/build_system/#package-presets","title":"Package presets","text":"<p>These presets are used for packaging the built project.</p> Name Configure Preset <code>release-conan</code> release-conan <code>release</code> release"},{"location":"build/build_system/#recommendations","title":"Recommendations","text":"<ul> <li>For development and debugging, use the Debug config (<code>debug</code>) preset. This configuration includes options for testing and benchmarking, making it ideal for development environments where you need to troubleshoot and test your code.</li> <li>For production builds, choose the Release config (<code>release</code>) preset to create optimized builds without debugging information. This is suitable for deploying applications.</li> <li>If your project relies on Conan, select either the Debug config (Conan) (<code>debug-conan</code>) or the Release config (Conan) (<code>release-conan</code>) presets, depending on whether you are debugging or preparing a release.</li> <li>Choose the Release config with tests (<code>release-with-tests</code>) or its Conan variant (<code>release-with-tests-conan</code>) if you want to ensure that your production build has been tested thoroughly before deployment.</li> </ul>"},{"location":"build/build_system/#example-usage","title":"Example usage","text":"<p>For example, this is how to build sc-machine in debug mode using dependencies from Conan:</p> <pre><code># Use pipx to install Conan if not already installed\n# Install pipx first using guide: https://pipx.pypa.io/stable/installation/ \npipx install conan\n</code></pre> <pre><code>conan remote add ostis-ai https://conan.ostis.net/artifactory/api/conan/ostis-ai-library/\n</code></pre> <pre><code># Use preset with Conan-provided dependencies and debug build type\ncmake --preset debug-conan\n# Use debug build preset since we've used a debug configure preset\ncmake --build --preset debug\n</code></pre> <p>This is how you would build sc-machine in release mode using system-provided dependencies:</p> <pre><code># release build type with tests (no conan postfix = system-provided deps)\ncmake --preset release-with-tests\ncmake --build --preset release\n</code></pre> <p>We also define <code>INSTALL</code> instructions in our CMake. This routine can be launched by appending <code>--target install</code> to the <code>cmake --build --preset &lt;preset&gt;</code> command. The result of this command will reside in <code>build/&lt;Release|Debug&gt;/install</code> (our default install folder). Install folder is basically a pack of portable executable files and shared libraries required to get sc-machine up and running, this command is intended to create clutter-free archives/folders with our code which you can then use in your own projects.</p>"},{"location":"build/build_system/#consuming-the-package","title":"Consuming the package","text":"find_package() using CPack artifacts on GitHub Actions <p>The package artifacts are available here. To use these in your CMake project, download and extract the release for your platform to any convenient location. Then make it available to CMake by appending folder path to <code>CMAKE_PREFIX_PATH</code>:</p> <pre><code># Import sc-machine from the Releases archive.\n# You can override this variable via -D&lt;proj_name&gt;_PATH_SC_MACHINE_PATH \n# or CMakeUserPreset.json / CMakePreset.json files.\nset(&lt;proj_name&gt;_SC_MACHINE_PATH \"/path/to/sc-machine-&lt;version&gt;-&lt;platform&gt;\" \n  CACHE PATH \"sc-machine installation path\"\n)\n\n# It can be overriden using env variables as well.\nif(DEFINED ENV{&lt;proj_name&gt;_SC_MACHINE_PATH})\n  set(&lt;proj_name&gt;_SC_MACHINE_PATH \"$ENV{&lt;proj_name&gt;_SC_MACHINE_PATH}\")\nendif()\n\nlist(APPEND CMAKE_PREFIX_PATH ${&lt;proj_name&gt;_SC_MACHINE_PATH})\n</code></pre> find_package() using Conan <ul> <li>You want to use a released version of sc-machine</li> </ul> <p>Simply add sc-machine as a dependency to your project and use Conan to install it for you.</p> <p>conanfile.txt:</p> <pre><code>[requires]\nsc-machine/0.10.0\n\n[generators]\nCMakeDeps\nCMakeToolchain\n\n[layout]\ncmake_layout\n</code></pre> <pre><code># Add remote repository to your Conan client configuration\nconan remote add ostis-ai https://conan.ostis.net/artifactory/api/conan/ostis-ai-library\n\nconan install . --build=missing\ncmake --preset conan-release\ncmake --build --preset conan-release\n</code></pre> <ul> <li>You want to use a package version that is not published in a Conan repo:</li> </ul> <p>Export the version you'd like to use to local conan cache:   <pre><code>git clone https://github.com/ostis-ai/sc-machine\ngit checkout &lt;your-commit&gt;\ncmake --preset release-conan\ncmake --build --preset release --target install\nconan export-pkg .\n# you should see the package version and revision exported to local conan cache\n</code></pre></p> <p>Then in your project edit conanfile.txt and add the following:</p> <pre><code>[requires]\n# git commit is also the revision\nsc-machine/&lt;version&gt;#&lt;commit&gt;\n\n[generators]\nCMakeDeps\nCMakeToolchain\n\n[layout]\ncmake_layout\n</code></pre> <p>Finally, build your project</p> <pre><code>conan install .\ncmake --preset conan-release\ncmake --build --preset conan-release\n</code></pre> <p>After making sc-machine available to find_package() in any of the above ways, use this to import our targets:</p> <pre><code>find_package(sc-machine REQUIRED)\n</code></pre> <p>After adding this code to your build system, using sc-machine libraries and executables will be available to you. Linking to a library will automatically make headers available to you as well.</p> <p>Let's try to use it!</p> <pre><code>add_executable(wave-find-path main.cpp)\ntarget_link_libraries(wave-find-path sc-machine::sc-memory)\n</code></pre> <pre><code>#include &lt;sc-memory/sc_addr.hpp&gt;\n\nScAddr graph, rrel_arcs, rrel_nodes;\n</code></pre> <p>If your IDE doesn't integrate well with this solution, try exporting compile commands in CMake:</p> <pre><code>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n</code></pre> <p>By default, the sc-machine repository contains configuration for launching tests in vscode. If you're developing on vscode, you can use this configuration and extension C++ TestMate for debugging code.</p>"},{"location":"build/build_system/#advanced-usage","title":"Advanced Usage","text":""},{"location":"build/build_system/#cross-compilation","title":"Cross-Compilation","text":"<p>For cross-compilation, use the appropriate CMake toolchain file.</p>"},{"location":"build/build_system/#editing-sc-machine-while-consuming-it-as-a-library","title":"Editing sc-machine while consuming it as a library","text":"<p>It's almost always problematic to edit a project while also consuming it as a library from another project. Luckily, if you've installed sc-machine in your project using Conan, there is a relatively easy solution to that problem.</p> <pre><code>conan editable add &lt;path to sc-machine repo&gt;\nconan editable list\n# sc-machine of the corresponding version should be in the output\n# make changes in the project and run a rebuild\ncmake --preset debug-conan\n# using a debug build since that would allow us to step \n# into the library's code while debugging\ncmake --build --preset debug\n</code></pre> <p>The same is true for installations that have used GitHub Releases artifacts. Download the sc-machine repo, configure it, run <code>cmake --build --preset &lt;preset&gt; --target install</code>. It will copy the built artifacts from their build location to the designated install location. After that, add <code>sc-machine/build/&lt;Debug|Release&gt;/install</code> to <code>CMAKE_PREFIX_PATH</code> of your project. Re-running <code>cmake --build --preset &lt;preset&gt; --target install</code> is enough to propagate changes to the consumer. By these steps, you can seamlessly integrate sc-machine into your project, ensuring that you have access to all necessary components without unnecessary rebuilds.</p> <p>Relaunch the compilation steps in your project and you should be good to go!</p> <p>You can find more info in Conan docs.</p>"},{"location":"build/build_system/#falling-back-to-system-dependencies","title":"Falling Back to System Dependencies","text":"<p>If Conan is not used, the CMake will attempt to find system-installed dependencies. Ensure that the necessary development packages are installed on your system.</p> <p>Currently, we require the following packages to be available to CMake at build-time:</p> <ul> <li><code>java</code></li> <li><code>glib2</code></li> <li><code>websocketpp</code></li> <li><code>asio</code> as the transitive dependency</li> <li><code>nlohmann_json</code></li> <li><code>xml2</code></li> </ul> <p>You can use convenience scripts provided in our repo (<code>scripts/install_deps_ubuntu.sh</code> and <code>scripts/install_deps_macOS.sh</code>) to install these dependencies.</p>"},{"location":"build/build_system/#testing-conan-package-definition","title":"Testing Conan package definition","text":"<p>It is possible to write tests for the Conan packaging using local package development flow.</p>"},{"location":"build/build_system/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If you encounter issues with Conan, try clearing the Conan cache: <code>conan cache clean</code>.</li> <li>For CMake configuration issues, check the CMakeCache.txt file in your build directory.</li> <li>Ensure that your CMake version is compatible with the project requirements.</li> </ul> <p>For further assistance, please consult the project's issue tracker or contact the maintainers.</p>"},{"location":"build/cmake_flags/","title":"CMake Flags","text":""},{"location":"build/cmake_flags/#build-cache","title":"Build cache","text":"<p>This project uses ccache automatically if it's available in the system. To disable this, use flag <code>-DAUTO_CCACHE=OFF</code>.</p>"},{"location":"build/cmake_flags/#building-tests","title":"Building tests","text":"<pre><code>cmake --preset &lt;configure-preset&gt; -DSC_BUILD_TESTS=ON\ncmake --build --preset &lt;build-preset&gt;\n</code></pre> <p>Additionally you can use <code>-DSC_BUILD_BENCH=ON</code> flag to build performance tests</p>"},{"location":"build/cmake_flags/#building-sc-machine-with-sanitizers","title":"Building sc-machine with sanitizers","text":"<p>Use <code>cmake</code> with <code>-DSC_USE_SANITIZER=memory</code> or <code>-DSC_USE_SANITIZER=address</code> option to run build with memory or address sanitizer. </p> <p>Note</p> <p>Sanitizers are only supported by <code>clang</code> compiler.</p>"},{"location":"build/cmake_flags/#example","title":"Example","text":"<pre><code>cmake --preset &lt;configure-preset&gt; -DSC_USE_SANITIZER=memory -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang\ncmake --build --preset &lt;build-preset&gt;\n</code></pre>"},{"location":"build/cmake_flags/#code-formatting-with-clangformat","title":"Code formatting with CLangFormat","text":"<p>To check code with CLangFormat run: <pre><code>cmake --preset release-with-tests -DSC_CLANG_FORMAT_CODE=ON\ncmake --build --preset release --target clangformat_check\n</code></pre></p> <p>or <pre><code>./scripts/clang/check_formatting.sh\n</code></pre></p> <p>To format code with CLangFormat run: <pre><code>cmake --preset release-with-tests -DSC_CLANG_FORMAT_CODE=ON\ncmake --build --preset release --target clangformat\n</code></pre></p> <p>or <pre><code>./scripts/clang/format_code.sh\n</code></pre></p>"},{"location":"build/config/","title":"Configuration File","text":""},{"location":"build/config/#config-file-example","title":"Config file example","text":"<pre><code>[sc-memory]\n# Maximum number of segments. By default, it is 1000.\n# Remember, that one sc-segment size is 3932144 bytes. 1000 segments size is 4 GB.\nmax_loaded_segments = 1000\n\n# If it is equal to `true` then sc-memory use minimum between physical cores number and `max_events_and_agents_threads`.\nlimit_max_threads_by_max_physical_cores = true\n# Maximum number of threads that can be used in events and agents handler. By default, it is 32 if \n`limit_max_threads_by_max_physical_cores` is `true` or otherwise it is core number of device processor.\nmax_events_and_agents_threads = 32\n\n# Period (in seconds) to save sc-memory statistics. By default, it is 3600.\ndump_memory_period = 3600\n# Boolean indicating to enable sc-memory dump.\ndump_memory = true\n# Period (in seconds) to update sc-memory statistics. By default, it is 1800.\ndump_memory_statistics_period = 1800\n# Boolean indicating to enable sc-memory statistics dump.\ndump_memory_statistics = true\n\n# Path to folder with compiled knowledge base binaries. By default, it is empty.\nstorage = /path/to/kb.bin\n# List of paths to directories with sc-memory shared library extensions separated by semicolon.\nextensions = /path/to/sc-machine/bin/extensions_1;/path/to/sc-machine/bin/extensions_2;...\n\n# Sc-memory log type. It can be `File` or `Console`.\nlog_type = File\n# Sc-memory log file.\nlog_file = /path/to/sc-machine/log/sc-server.log\n# Sc-memory log level. # It can be `Debug`, `Info`, `Warning` or `Error` also.\nlog_level = Info\n\n# Boolean indicating to upload all sc-element into one common sc-structure with system identifier `result_structure`.\ninit_memory_generated_upload = false\ninit_memory_generated_structure = result_structure\n\n# Maximum number of channels to split file memory into sections. By default, it is 1000.\nmax_strings_channels = 1000\n# Maximum file memory section size. By default, it is 100000.\nmax_strings_channel_size = 100000\n# Maximum size of strings that can be found by substring. By default, it is 1000.\nmax_searchable_string_size = 1000\n# Separators used to divide strings into tokens to find this strings by its tokens substrings. By default, it is \" _\".\n# If search by substring isn't needed, set this value to \"\" to increase maximum performance for strings linking and searching.\nterm_separators = \" _\" \n# If search by substring isn't needed, set this value to \"false\" to increase maximum performance for strings linking.\nsearch_by_substring = true\n\n[sc-server]\n# Sc-server socket data.\nhost = 127.0.0.1\nport = 8090\n\n# Sc-server mode to call parallel all input actions. By default, it is true.\nparallel_actions = true\n\n# Sc-server log type. It can be `File` or `Console`.\nlog_type = File\n# Sc-server log file.\nlog_file = /path/to/sc-machine/log/sc-server.log\n# Sc-server log level. # It can be `Debug`, `Info`, `Warning` or `Error` also.\nlog_level = Info\n\n[sc-builder]\n# Path to directory with knowledge base sources (.scs, .gwf) or to &lt;repo-name&gt;.path file\ninput = kb\n# Path to folder with compiled knowledge base binaries. By default, it is empty.\noutput = kb.bin\n</code></pre> <p>Note</p> <p>If you use relative paths they will be resolved based on config file location.</p>"},{"location":"build/quick_start/","title":"Quick Start for Developers","text":"<p>Note</p> <p>The sc-machine can't be built on Windows.</p> <p>This guide provides short information for developers to start to work with sc-machine quickly. You can always learn more about the sc-machine's build system.</p>"},{"location":"build/quick_start/#install-project","title":"Install project","text":"<p>Install sc-machine via git:</p> <pre><code>git clone https://github.com/ostis-ai/sc-machine\ncd sc-machine\ngit submodule update --init --recursive\n</code></pre>"},{"location":"build/quick_start/#install-basic-tools-for-development-environment","title":"Install basic tools for development environment","text":"<ul> <li> <p>Ubuntu/Debian (GCC): </p> <pre><code>sudo apt update\n\nsudo apt install --yes --no-install-recommends \\\n    curl \\\n    ccache \\\n    build-essential\n</code></pre> </li> <li> <p>macOS (Clang):</p> <pre><code>brew update &amp;&amp; brew upgrade\nbrew install \\\n    curl \\\n    ccache\n</code></pre> </li> <li> <p>Other Linux distributions:</p> <p>If you're using a different Linux distribution that doesn't support apt, ensure you have equivalent packages installed:</p> <ul> <li>curl: A tool for transferring data with URLs;</li> <li>ccache: A compiler cache to speed up compilation processes;</li> <li>build-essential: Includes a C++ compiler, necessary for building C++ components.</li> </ul> </li> </ul> <p>Compiler is required for building C++ components.</p>"},{"location":"build/quick_start/#check-cmake","title":"Check CMake","text":"<p>Install pipx first using pipx installation guide if not already installed.</p> <p>Ensure you are using CMake version 3.24 or newer. Verify your version with:</p> <pre><code>cmake --version\n</code></pre> <p>To upgrade CMake, run:</p> <pre><code># Use pipx to install cmake if not already installed\npipx install cmake\npipx ensurepath\n# relaunch your shell after installation\nexec $SHELL\n</code></pre>"},{"location":"build/quick_start/#install-ninja-generator","title":"Install Ninja generator","text":"<p>Install Ninja generator for CMake, to use sc-machine CMake presets:</p> <pre><code># Use pipx to install ninja if not already installed\npipx install ninja\npipx ensurepath\n# relaunch your shell after installation\nexec $SHELL\n</code></pre>"},{"location":"build/quick_start/#start-develop-sc-machine-with-conan","title":"Start develop sc-machine with Conan","text":""},{"location":"build/quick_start/#install-conan","title":"Install Conan","text":"<p>Install Conan, to build sc-machine with Conan-provided dependencies:</p> <pre><code># Use pipx to install conan if not already installed\npipx install conan\npipx ensurepath\n# relaunch your shell after installation\nexec $SHELL\n</code></pre> <p>Add the 'ostis-ai' remote, enabling Conan to find packages (libffi/3.4.8):</p> <pre><code>conan remote add ostis-ai https://conan.ostis.net/artifactory/api/conan/ostis-ai-library/\n</code></pre>"},{"location":"build/quick_start/#use-sc-machine-in-debug","title":"Use sc-machine in Debug","text":""},{"location":"build/quick_start/#build-sc-machine-in-debug","title":"Build sc-machine in Debug","text":"<p>To build sc-machine in debug mode using Conan-provided dependencies, run:</p> <pre><code># debug build type\ncmake --preset debug-conan\ncmake --build --preset debug\n</code></pre> <p>Note</p> <p>By default, configure preset <code>debug</code> enables building sc-machine tests.</p>"},{"location":"build/quick_start/#run-sc-machine-tests-in-debug","title":"Run sc-machine tests in Debug","text":"<p>After that, you can go to <code>build/Debug</code> and run tests via <code>ctest</code>:</p> <pre><code>cd build/Debug\nctest -V\n</code></pre>"},{"location":"build/quick_start/#run-sc-machine-in-debug","title":"Run sc-machine in Debug","text":"<pre><code># create empty knowledge base sources folder\nmkdir kb\n# note: at this stage you can move your KB sources to the ./kb folder\n\n# build knowledge base\n./build/Debug/bin/sc-builder -i kb -o kb.bin --clear\n# run sc-machine\n./build/Debug/bin/sc-machine -e build/Debug/lib/extensions -s kb.bin\n</code></pre>"},{"location":"build/quick_start/#use-sc-machine-in-release","title":"Use sc-machine in Release","text":""},{"location":"build/quick_start/#build-sc-machine-in-release","title":"Build sc-machine in Release","text":"<p>To build sc-machine in release mode using Conan-provided dependencies, run:</p> <pre><code># release build type without tests\ncmake --preset release-conan\ncmake --build --preset release\n</code></pre> <p>To build sc-machine with tests in release mode using Conan-provided dependencies, run:</p> <pre><code># release build type with tests\ncmake --preset release-with-tests-conan\ncmake --build --preset release\n</code></pre>"},{"location":"build/quick_start/#run-sc-machine-tests-in-release","title":"Run sc-machine tests in Release","text":"<p>After that, you can run tests:</p> <pre><code>cd build/Release\nctest -V\n</code></pre>"},{"location":"build/quick_start/#run-sc-machine-in-release","title":"Run sc-machine in Release","text":"<pre><code># create empty knowledge base sources folder\nmkdir kb\n# note: at this stage you can move your KB sources to the ./kb folder\n\n# build knowledge base\n./build/Release/bin/sc-builder -i kb -o kb.bin --clear\n# run sc-machine\n./build/Release/bin/sc-machine -e build/Release/lib/extensions -s kb.bin\n</code></pre> <p>You can also check code formatting, build sc-machine with sanitizers and other. To learn more, go to the CMake flags page.</p>"},{"location":"build/quick_start/#start-develop-sc-machine-with-system-provided-dependencies","title":"Start develop sc-machine with system-provided dependencies","text":""},{"location":"build/quick_start/#install-sc-machine-dependencies","title":"Install sc-machine dependencies","text":"<p>Note</p> <p>sc-machine build system supports installation of dependencies for Ubuntu and macOS only.</p>"},{"location":"build/quick_start/#install-sc-machine-dependencies-for-ubuntu","title":"Install sc-machine dependencies for Ubuntu","text":"<pre><code>cd scripts\n./install_deps_ubuntu.sh --dev\n</code></pre>"},{"location":"build/quick_start/#install-sc-machine-dependencies-for-macos","title":"Install sc-machine dependencies for macOS","text":"<pre><code>cd scripts\n./install_deps_macOS.sh\n</code></pre>"},{"location":"build/quick_start/#install-sc-machine-dependencies-for-other-os","title":"Install sc-machine dependencies for other OS","text":"<p>Currently, we require the following packages to be available to CMake at build-time:</p> <ul> <li><code>java</code></li> <li><code>glib2</code></li> <li><code>websocketpp</code></li> <li><code>asio</code> as the transitive dependency</li> <li><code>nlohmann_json</code></li> <li><code>xml2</code></li> </ul> <p>You can try install these dependencies on your OS.</p>"},{"location":"build/quick_start/#use-sc-machine-in-debug_1","title":"Use sc-machine in Debug","text":""},{"location":"build/quick_start/#build-sc-machine-in-debug_1","title":"Build sc-machine in Debug","text":"<p>To build sc-machine in debug mode using system-provided dependencies, run:</p> <pre><code># debug build type\ncmake --preset debug\ncmake --build --preset debug\n</code></pre> <p>Note</p> <p>By default, configure preset <code>debug</code> enables building sc-machine tests.</p>"},{"location":"build/quick_start/#run-sc-machine-tests-in-debug_1","title":"Run sc-machine tests in Debug","text":"<p>After that, you can go to <code>build/Debug</code> and run tests via <code>ctest</code>:</p> <pre><code>cd build/Debug\nctest -V\n</code></pre>"},{"location":"build/quick_start/#run-sc-machine-in-debug_1","title":"Run sc-machine in Debug","text":"<pre><code># create empty knowledge base sources folder\nmkdir kb\n# note: at this stage you can move your KB sources to the ./kb folder\n\n# build knowledge base\n./build/Debug/bin/sc-builder -i kb -o kb.bin --clear\n# run sc-machine\n./build/Debug/bin/sc-machine -e build/Debug/lib/extensions -s kb.bin\n</code></pre>"},{"location":"build/quick_start/#use-sc-machine-in-release_1","title":"Use sc-machine in Release","text":""},{"location":"build/quick_start/#build-sc-machine-in-release_1","title":"Build sc-machine in Release","text":"<p>To build sc-machine in release mode using system-provided dependencies, run:</p> <pre><code># release build type without tests\ncmake --preset release\ncmake --build --preset release\n</code></pre> <p>To build sc-machine with tests in release mode using system-provided dependencies, run:</p> <pre><code># release build type with tests\ncmake --preset release-with-tests\ncmake --build --preset release\n</code></pre>"},{"location":"build/quick_start/#run-sc-machine-tests-in-release_1","title":"Run sc-machine tests in Release","text":"<p>After that, you can run tests:</p> <pre><code>cd build/Release\nctest -V\n</code></pre>"},{"location":"build/quick_start/#run-sc-machine-in-release_1","title":"Run sc-machine in Release","text":"<pre><code># create empty knowledge base sources folder\nmkdir kb\n# note: at this stage you can move your KB sources to the ./kb folder\n\n# build knowledge base\n./build/Release/bin/sc-builder -i kb -o kb.bin --clear\n# run sc-machine\n./build/Release/bin/sc-machine -e build/Release/lib/extensions -s kb.bin\n</code></pre> <p>You can also check code formatting, build sc-machine with sanitizers and other. To learn more, go to the CMake flags page.</p>"},{"location":"dev/codestyle/","title":"Code Style Guide","text":"<p>In general, Google's coding standard is used, and we strongly  encourage to read it.</p> <p>All code should conform to C++17 standard. Here's a summary of the key rules specified in the configuration:</p>"},{"location":"dev/codestyle/#includes","title":"Includes","text":"<ul> <li>We use <code>.cpp</code> and <code>.hpp</code> files, not <code>.cc</code> and <code>.h</code> (<code>.c</code> and <code>.h</code> are used for C code), in UTF-8 encoding.</li> <li>File names are lowercase with underscores, like <code>sc_memory.cpp</code>.</li> <li>Directory names are lowercase with hyphen, like <code>sc-memory/</code>.</li> <li>We use <code>#pragma once</code> instead of the <code>#define</code> Guard in header files.</li> <li>Include categories are specified with priorities. There are two main categories: external libraries and internal  libraries. External libraries have the highest priority.</li> <li>Includes are sorted and grouped by directory, there should be newlines between different directories.</li> <li>Order of directories in includes: <code>current_dir/current_file.hpp</code>, other includes from the same dir, includes from other dirs sorted by name.</li> </ul> <pre><code>#include \"test.hpp\"\n\n#include &lt;curl/curl.h&gt;\n\n#include &lt;rapidjson/document.h&gt;\n#include &lt;rapidjson/stringbuffer.h&gt;\n#include &lt;rapidjson/writer.h&gt;\n\n#include \"hash/hmac.h\"\n#include \"hash/sha256.h\"\n\n#include \"sc-memory/sc_event_wait.hpp\"\n#include \"sc-memory/sc_agent.hpp\"\n</code></pre> <ul> <li>Don't use <code>using namespace std</code> or other namespaces globally. You can use them locally in test cpp files or functions.</li> </ul> <p>Note</p> <p>Unfortunately, sources of <code>sc-kpm</code> does not comply these rules. But you must comply these rules!</p>"},{"location":"dev/codestyle/#indentation-and-spacing","title":"Indentation and Spacing","text":"<ul> <li>The code should use spaces for indentation. The indentation width is set to 2 spaces. The code should not use tabs.</li> </ul> <pre><code>// It is correct style.\nsc_uint32 ExampleFunc() \n{\n  if (condition) \n  {\n    // Code block\n  } \n  else \n  {\n    // Code block\n  }\n\n  return 0;\n}\n\n// It is incorrect style.\nsc_uint32 ExampleFunc() \n{\n    if (condition) \n    {\n        // Code block\n    } \n    else \n    {\n        // Code block\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li>Spaces before the opening parenthesis in control statements.</li> </ul> <pre><code>// It is correct style.\nvoid ExampleFunction(sc_uint32 x) \n{\n  if (x &gt; 0) \n  {\n    // Code block\n  }\n\n  for (sc_uint32 i = 0; i &lt; x; ++i) \n  {\n    // Code block\n  }\n\n  while (x &gt; 10) \n  {\n    // Code block\n  }\n}\n\n// It is incorrect style.\nvoid ExampleFunction(sc_uint32 x) \n{\n  if(x &gt; 0) \n  {\n    // Code block\n  }\n\n  for(sc_uint32 i = 0; i &lt; x; ++i) \n  {\n    // Code block\n  }\n\n  while(x &gt; 10) \n  {\n    // Code block\n  }\n}\n</code></pre> <ul> <li>Spaces before the colon in constructor initializer lists.</li> </ul> <pre><code>// It is correct style.\nclass MyClass \n{\npublic:\n  // Constructor with initializer list\n  MyClass(sc_uint32 x, sc_uint32 y)\n    : m_x(x)\n    , m_y(y) \n  {\n    // Constructor body\n  }\n\nprivate:\n  sc_uint32 m_x; // `m` - is abbreviation of `member`\n  sc_uint32 m_y;\n  static sc_uint32 ms_maxX; // `ms` - is abbreviation of `member static`\n  static sc_uint32 ms_maxY;\n};\n</code></pre> <ul> <li>Spaces should be inserted before assignment operators and around pointer and reference qualifiers.</li> </ul> <pre><code>// It is correct style.\nsc_uint32 x = 10;\nsc_uint32 * ptr = &amp;x;\nsc_uint32 const * constPtr = &amp;x;\nsc_uint32 &amp; ref = x;\n\n// It is incorrect style.\nsc_uint32 x = 10;\nsc_uint32* ptr = &amp;x;\nconst sc_uint32 *constPtr = &amp;x;\nsc_uint32&amp; ref = x;\n</code></pre> <ul> <li>Use right-to-left order for variables/params.</li> </ul> <pre><code>// It is correct style.\nScAddr const &amp; addr; // reference to the const `ScAddr`.\n</code></pre>"},{"location":"dev/codestyle/#whitespace","title":"Whitespace","text":"<ul> <li>Remove extra whitespaces at the end of lines.</li> <li>Spaces in empty blocks and parentheses should be omitted.</li> <li>Trailing commas should be added in wrapped situations.</li> </ul> <pre><code>// It is correct style.\nstd::vector&lt;sc_uint32&gt; numbers = {\n    1,\n    2,\n    3,  // Trailing comma added\n};\n</code></pre>"},{"location":"dev/codestyle/#brace-style","title":"Brace Style","text":"<ul> <li>Braces for functions, classes, namespaces, etc., should be on a new line.</li> </ul> <pre><code>// It is correct styles.\nvoid ExampleFunction() \n{\n  // Code block\n}\n\nclass ExampleClass \n{\npublic:\n  // Class members\n};\n\nnamespace exampleNamespace \n{\n  // Namespace contents\n}\n\n// It is incorrect styles.\nvoid ExampleFunction() {\n  // Code block\n}\n\nclass ExampleClass {\npublic:\n  // Class members\n};\n\nnamespace exampleNamespace {\n  // Namespace contents\n}\n</code></pre> <ul> <li>Empty functions, classes, and namespaces should be split into separate lines.</li> </ul> <pre><code>// It is correct style.\nvoid ExampleFunction() \n{\n}\n\nclass ExampleClass \n{\n};\n\nnamespace exampleNamespace \n{\n}\n</code></pre> <ul> <li>Braces for control statements always on a new line.</li> </ul> <pre><code>// It is correct style.\nif (condition) \n{\n  // Code block\n} \nelse \n{\n  // Code block\n}\n\nfor (sc_uint32 i = 0; i &lt; 10; ++i) \n{\n  // Code block\n}\n\n// It is incorrect style.\n</code></pre> <ul> <li>Always break after a multiline string.</li> </ul> <pre><code>// It is correct style.\nstd::string multilineString = \"This is a long string that \"\n                              \"spans multiple lines.\";\n</code></pre> <ul> <li>Always break functions declarations and calls.</li> </ul> <pre><code>// It is correct style.\nsc_uint32 ExampleFunction(\n    sc_uint32 argument1, \n    sc_uint32 argument2, \n    sc_uint32 argument3, \n    sc_uint32 * result, \n    sc_uint32 * delta)\n\n// It is incorrect style.\nsc_uint32 ExampleFunction(\n    sc_uint32 argument1, sc_uint32 argument2, sc_uint32 argument3, \n    sc_uint32 * result, sc_uint32 * delta)\n</code></pre>"},{"location":"dev/codestyle/#line-length-and-wrapping","title":"Line Length and Wrapping","text":"<ul> <li> <p>The maximum column limit is set to 120 characters.</p> </li> <li> <p>Break binary operators before the operator.</p> </li> </ul> <pre><code>// It is correct style.\nsc_uint32 const result = longVariableName\n    + anotherLongVariableName\n    + yetAnotherLongVariableName;\n\n// It is incorrect style.\nsc_uint32 const result = longVariableName +\n    anotherLongVariableName +\n    yetAnotherLongVariableName;\n</code></pre> <ul> <li>Break before ternary operators.</li> </ul> <pre><code>// It is correct style.\nsc_uint32 const value = condition\n    ? trueValue\n    : falseValue;\n\n// It is incorrect style.\nsc_uint32 const value = condition ?\n    trueValue :\n    falseValue;\n</code></pre> <ul> <li>Break before braces in custom scenarios.</li> </ul> <pre><code>// It is correct style.\nif (condition) \n{\n  // Code block\n} \nelse \n{\n  // Code block\n}\n\n// It is incorrect style.\nif (condition) {\n  // Code block\n} \nelse {\n  // Code block\n}\n</code></pre> <ul> <li>In one line <code>if</code>, <code>for</code>, <code>while</code> we do not use brackets. If one line <code>for</code> or <code>while</code> is combined with one line <code>if</code>, do use brackets for cycle.</li> </ul> <pre><code>for (ScAddr const &amp; addr : addrList)\n  context.EraseElement(addr);\n\n...\n\nfor (ScAddr const &amp; addr : addrList)\n{\n  if (addr.IsValid())\n    return true;\n}\n</code></pre>"},{"location":"dev/codestyle/#naming","title":"Naming","text":""},{"location":"dev/codestyle/#c-naming","title":"C Naming","text":"<ul> <li>Macros and C-style enums must be named in UPPER_CASE, and enum values must be prefixed with a capitalized enum name.</li> <li>All other objects must be named in snake_case.</li> </ul>"},{"location":"dev/codestyle/#c-naming_1","title":"C++ Naming","text":"<ul> <li>Underscores are allowed only in prefixes for member variables and namespace names, like <code>int m_keynodeAddr; namespace sc_utils</code>.</li> <li>We use <code>using</code> keyword instead of <code>typedef</code>.</li> <li>Compile-time constants must be named in camelCase, starting with a lower-case <code>k</code>, e.g. <code>kCompileTimeConstant</code>  and marked as <code>constexpr</code> when possible.</li> <li>Values of enum classes must be named in CamelCase, e.g. <code>enum class Color { Red, Green, LightBlue };</code>.</li> </ul>"},{"location":"dev/codestyle/#comments","title":"Comments","text":"<ul> <li>Doxygen-style comments can be used.</li> </ul>"},{"location":"dev/codestyle/#check-code-style","title":"Check code style","text":"<p>Most of our coding style is specified in a configuration file for ClangFormat. To automatically format a file, install <code>clang-format</code> and run:</p> <pre><code>cd sc-machine\nclang-format -i file.cpp file.hpp other_file.cpp\n</code></pre> <p>To check all format code use script <code>check_formatting.sh</code>.</p> <pre><code>cd sc-machine\n./scripts/clang/check_formatting.sh\n</code></pre> <p>Or use script <code>format_code.sh</code> to reformat all code.</p> <pre><code>cd sc-machine\n./scripts/clang/format_code.sh\n</code></pre>"},{"location":"dev/codestyle/#tips-and-hints","title":"Tips and Hints","text":"<ul> <li>Code should compile without warnings! Just deprecated warning could be present for a short time. But if you see them,   then try to fix it in a separate commit.</li> <li>If you see outdated code which can be improved - DO IT NOW (but in the separate pull request).</li> <li>Your code should work at least on: Ubuntu 20.04 and 22.04; Debian 11; macOS platforms.</li> <li>Your code should compile well with the last gcc and clang.</li> <li>Try to avoid using any new 3rd party library if it is not fully tested and supported on supported platforms.</li> <li>Cover your code with unit tests.</li> <li>If you don't have enough time to make it right, leave a <code>// TODO(DeveloperName): need to fix it</code> comment and make  issue on GitHub.</li> </ul>"},{"location":"dev/devcontainer/","title":"Dev Container","text":""},{"location":"dev/devcontainer/#docker-development-container","title":"Docker development container","text":"<p>We recognize that recreating development environment for this project may be complicated, especially on unsupported platforms. To ease things for our developers and contributors, we created a stable, reproducible environment dubbed \"Dev container\". It can be used in any IDE or in a standalone manner, but is fully integrated with Visual Studio Code.</p>"},{"location":"dev/devcontainer/#usage","title":"Usage","text":""},{"location":"dev/devcontainer/#vscode","title":"VSCode","text":"<p>If you use VSCode as your code editor of choice, things are simple: install Docker, install <code>Remote - Containers</code> extension for VSCode, and reload the window. You should see a prompt to reopen the project in container (if it didn't appear, you can fire up <code>Reopen in Container</code> action in Command Palette). First load/build may take a while, so don't rush to cancel the process. After the window is reopened, you can open terminals, edit code and recompile the project as usual.</p>"},{"location":"dev/devcontainer/#jetbrains-ide","title":"JetBrains IDE","text":"<p>You can add our development environment container as a Docker toolchain to your JetBrains IDE. Check this guide for more info.</p>"},{"location":"dev/devcontainer/#standalone","title":"Standalone","text":"<p>Using this image directly in the terminal is also possible:</p> <ol> <li> <p>To build it, use <code>devcontainer</code> target in our Dockerfile <pre><code>docker build . -t ostis/sc-machine-builder  --target=devcontainer\n</code></pre></p> </li> <li> <p>Run the container mounting your workspace folder to <code>/sc-machine</code> inside the container. Optionally you can create a volume for <code>ccache</code> to preserve build cache across restarts: <pre><code>docker run --rm -i -t -v sc-machine_ccache:/ccache -v &lt; path to the project folder&gt;:/sc-machine ostis/sc-machine-builder\n</code></pre></p> </li> </ol>"},{"location":"sc-memory/api/cpp/core/api/","title":"C++ Core API","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>The API provides core functionality for creating, retrieving and erasing sc-elements in sc-memory. This sc-memory is designed to represent knowledge in a structured and graph-based manner.</p> <p>A sc-memory consists of sc-elements. Sc-elements can be grouped into sc-constructions (semantic graphs or knowledge graphs). Among sc-elements there are sc-nodes, sc-links and sc-connectors between them. All sc-elements have syntactic and semantic sc-types. Sc-connectors are divided into non-oriented sc-connectors (sc-edges) and oriented sc-connectors (sc-arcs). Each sc-connector have source and target sc-elements. These sc-elements can be sc-nodes, sc-links or sc-connectors. All these attributes of sc-elements and sc-element structures are hidden from user, but you can get these features using this API.</p> <p>Note</p> <p>All API methods are thread-safe.</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_memory.hpp&gt;</code> in your hpp source.</p> <p>Warning</p> <p>Objects of <code>ScMemoryContext</code> class are movable, but not copyable.</p>"},{"location":"sc-memory/api/cpp/core/api/#scaddr","title":"ScAddr","text":"<p>Each sc-element has a sc-address with which you can obtain information about this sc-element.</p> <pre><code>...\nScAddr elementAddr1 = // some call of the API method 1\nScAddr elementAddr2 = // some call of the API method 2\n// Compare sc-addresses.\nbool const isAddrsEqual = elementAddr1 == elementAddr2;\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#scmemorycontext","title":"ScMemoryContext","text":"<p>It is a class provided all API methods for creating, manipulating, retrieving and erasing sc-elements in sc-memory. It refers to set of attributes and rights of some subject of action in sc-memory (user or agent) that are used in  during API methods completion.</p> <pre><code>...\n// To create such context use constructor of ScMemoryContext.\nScMemoryContext context;\n// After you can use this object to call any API methods.\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#generatenode","title":"GenerateNode","text":"<p>To create sc-nodes you can use the method <code>GenerateNode</code>, to create sc-links - the method <code>GenerateLink</code>, to create sc-connectors between them - the method <code>GenerateConnector</code>. All these methods check passed sc-types. If specified sc-type is not valid, then a method throws the exception <code>utils::ExceptionInvalidParams</code> with description of this error.</p> <pre><code>...\n// Generate sc-node and get sc-address in sc-memory of it.\nScAddr const &amp; nodeAddr = context.GenerateNode(ScType::ConstNode);\n// Specified sc-type must be one of ScType::...Node... type.\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#generatelink","title":"GenerateLink","text":"<pre><code>...\n// Generate sc-link and get sc-address in sc-memory of it.\nScAddr const &amp; linkAddr = context.GenerateLink(ScType::ConstNodeLink);\n// Specified sc-type must be one of ScType::...NodeLink... type.\n</code></pre> <p>Note</p> <p>Now all sc-links are not sc-nodes. It can be fixed in the further versions of sc-machine. But you can use  the method <code>GenerateNode</code> to create sc-links.</p>"},{"location":"sc-memory/api/cpp/core/api/#generateconnector","title":"GenerateConnector","text":"<pre><code>...\n// Generate sc-arc between sc-node and sc-link and get sc-address in \n// sc-memory of it.\nScAddr const &amp; arcAddr = context.GenerateConnector(\n    ScType::ConstPermPosArc, nodeAddr, linkAddr);\n// Specified sc-type must be one of ScType::Edge... type.\n</code></pre> <p>If specified sc-addresses of source and target sc-elements are not valid, then the method throws exception <code>utils::ExceptionInvalidParams</code> with description that some of specified sc-addresses is not valid.</p> <p>Note</p> <p>Although this method is called incorrectly and may be misleading, but you can create any sc-connectors using it.</p>"},{"location":"sc-memory/api/cpp/core/api/#iselement","title":"IsElement","text":"<p>To check if specified sc-address is valid in sc-memory you can use the method <code>IsElement</code>. Valid sc-address refers to sc-address that exists in sc-memory and that corresponds some sc-element in it.</p> <pre><code>...\n// Check if all created sc-elements are valid.\nbool const isNodeValid = context.IsElement(nodeAddr);\nbool const isLinkValid = context.IsElement(linkAddr);\nbool const isArcValid = context.IsElement(arcAddr);\n</code></pre> <p>Note</p> <p>You can check if specified sc-address is not empty calling from this sc-address object method <code>IsValid</code>. But it is preferable to use <code>IsElement</code>, it checks if provided sc-address exists and valid in sc-memory. </p>"},{"location":"sc-memory/api/cpp/core/api/#getelementtype","title":"GetElementType","text":"<p>If it needs you can get sc-element types by its sc-addresses. If specified sc-address is not valid, then the method  throws exception <code>utils::ExceptionInvalidParams</code> with description that specified sc-address is not valid.</p> <pre><code>...\n// Get created sc-elements sc-types.\nScType const &amp; nodeType = context.GetElementType(nodeAddr);\nScType const &amp; linkType = context.GetElementType(linkAddr);\nScType const &amp; arcType = context.GetElementType(arcAddr);\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#setelementsubtype","title":"SetElementSubtype","text":"<p>You can change semantic sc-type of sc-element. Use the method <code>SetElementSubtype</code> and provide semantic sc-type for syntactic sc-type for sc-element.</p> <pre><code>...\n// Generate sc-node and get sc-address in sc-memory of it.\nScAddr const &amp; nodeAddr = context.GenerateNode(ScType::Node);\nbool const isSubtypeElementChanged \n    = context.SetElementSubtype(nodeAddr, ScType::ConstNode);\n// The value of `isSubtypeElementChanged` must be equal to `true`.\n</code></pre> <p>Note</p> <p>Don't use this method to change syntactic sc-type for sc-element. It is misleading.</p>"},{"location":"sc-memory/api/cpp/core/api/#getconnectorincidentelements","title":"GetConnectorIncidentElements","text":"<p>To get incident (source and target) sc-elements you can use methods <code>GetConnectorIncidentElements</code>, <code>GetArcSourceElement</code> and <code>GetArcTargetElement</code>. If specified sc-address is not valid, then this methods throw exception <code>utils::ExceptionInvalidParams</code> with description  that specified sc-address of sc-connector is not valid.</p> <pre><code>...\n// Get sc-arc incident sc-elements.\nauto const [sourceAddr, targetAddr] \n  = context.GetConnectorIncidentElements(arcAddr);\n// The sc-address `sourceAddr` must be equal to the sc-address `nodeAddr` \n// and the sc-address `targetAddr` must be equal to the sc-address `linkAddr`.\n...\n// Or get sc-arc incident source and target sc-elements separately.\nScAddr const &amp; sourceAddr = context.GetArcSourceElement(arcAddr);\n// The sc-address `sourceAddr` must be equal to the sc-address `nodeAddr`.\nScAddr const &amp; targetAddr = context.GetArcTargetElement(arcAddr);\n// The sc-address `targetAddr` must be equal to the sc-address `linkAddr`.\n</code></pre> <p>To find previously created sc-constructions you can use 3-element sc-iterators and 5-element sc-iterators from C++ API. The image below shows numeration of sc-elements in 3-element (left) and 5-element (right) sc-iterators.</p> <p>Iterators element numeration</p> <p>For both of them you have two approaches. First approach is to use simple while loop. It is suitable, when you need to break this loop depending on logic:</p>"},{"location":"sc-memory/api/cpp/core/api/#sciterator3","title":"ScIterator3","text":"<pre><code>...\n// Create sc-iterator for searching all sc-element sc-addresses \n// with unknown sc-type belonging to sc-set with sc-address `setAddr`.\nScIterator3Ptr it3 = context.CreateIterator3(\n    setAddr,\n    ScType::ConstPermPosArc,\n    ScType::Unknown);\n// Use it3-Next() to go to the next appropriate by condition sc-construction.\nwhile (it3-&gt;Next())\n{\n  // To get values use `it3-&gt;Get(index)`, where index in range [0; 2]. \n  // It returns `true`, if the next appropriate construction is found, \n  // otherwise `false`.\n  ... // Write your code to handle found sc-construction.\n}\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#sciterator5","title":"ScIterator5","text":"<pre><code>...\n// Create sc-iterator for searching all sc-node sc-addresses, \n// which pairs with sc-element with address `setAddr` belong to the relation \n// with sc-address `nrelDecompositionAddr`.\nScIterator5Ptr it5 = context.CreateIterator5(\n    setAddr,\n    ScType::ConstCommonArc,\n    ScType::ConstNode,\n    ScType::ConstPermPosArc,\n    nrelDecompositionAddr);\n// Use `it5-Next()` to go to the next appropriate by condition sc-construction. \n// It returns `true`, if the next appropriate construction is found, \n// otherwise `false`.\nwhile (it5-&gt;Next())\n{\n  // To get values use `it5-&gt;Get(index)`, where index in range [0; 4].\n  ... // Write your code to handle found sc-construction.\n}\n</code></pre> <p>Second approach allows you to iterate 3-element and 5-element constructions with less code, and it is suitable when you need to iterate all results.</p> <p>Note</p> <p>Use next methods if you need to iterate all results. Because it more clearly.</p>"},{"location":"sc-memory/api/cpp/core/api/#foreach","title":"ForEach","text":"<pre><code>...\n// Create callback-based sc-iterator for searching all sc-element sc-addresses \n// with unknown sc-type belonging to sc-set with sc-address `setAddr`.\ncontext.ForEach(\n    setAddr,\n    ScType::ConstPermPosArc,\n    ScType::Unknown,\n    [] (ScAddr const &amp; srcAddr, ScAddr const &amp; edgeAddr, ScAddr const &amp; trgAddr)\n{\n  // srcAddr equal to the 0th value of iterator\n  // edgeAddr equal to the 1st value of iterator\n  // trgAddr equal to the 2d value of iterator\n  ... // Write your code to handle found sc-construction.\n});\n</code></pre> <pre><code>...\n// Create callback-based sc-iterator for searching all sc-node sc-addresses, \n// which pairs with sc-element with address `setAddr` belong to the relation \n// with sc-address `nrelDecompositionAddr`.\ncontext.ForEach(\n  setAddr,\n  ScType::ConstCommonArc,\n  ScType::ConstNode,\n  ScType::ConstPermPosArc,\n  nrelDecompositionAddr\n  [] (ScAddr const &amp; srcAddr, \n      ScAddr const &amp; connectorAddr, \n      ScAddr const &amp; trgAddr, \n      ScAddr const &amp; connectorAttrAddr, \n      ScAddr const &amp; attrAddr)\n{\n  // srcAddr equal to the 0th value of sc-iterator\n  // connectorAddr equal to the 1st value of sc-iterator\n  // trgAddr equal to the 2d value of sc-iterator\n  // connectorAttrAddr equal to the 3rd value of sc-iterator\n  // attrAddr equal to the 4th value of sc-iterator\n  ... // Write your code to handle found sc-construction.\n});\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#eraseelement","title":"EraseElement","text":"<p>All sc-elements can be erasing from sc-memory. For this you can use the method <code>EraseElement</code>.</p> <pre><code>...\n// Erase all created sc-elements.\nbool const isNodeErased = context.EraseElement(nodeAddr);\n// The sc-elements with sc-addresses `nodeAddr` and `arcAddr` must be deleted.\nbool const isArcErased = context.EraseElement(arcAddr);\n// The sc-element with sc-address `targetAddr` must be deleted.\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#setlinkcontent","title":"SetLinkContent","text":"<p>Besides creating and checking elements, the API also supports updating and removing content of sc-links. If specified sc-element is a sc-link, you can set content into it. Re-installing new content into a sc-link removes the previous content from this sc-link. If specified sc-address is not valid, then the method throws exception  <code>utils::ExceptionInvalidParams</code> with description that specified sc-address is not valid.</p> <pre><code>...\nScAddr const &amp; linkAddr1 = context.GenerateLink(ScType::ConstNodeLink);\n// Set string content into created sc-link.\ncontext.SetLinkContent(linkAddr1, \"my content\");\n\nScAddr const &amp; linkAddr2 = context.GenerateLink(ScType::ConstNodeLink);\n// Set numeric content into created sc-link.\ncontext.SetLinkContent(linkAddr2, 10f);\n...\n</code></pre> <p>Note</p> <p>Don't use result value, it doesn't mean anything.</p>"},{"location":"sc-memory/api/cpp/core/api/#getlinkcontent","title":"GetLinkContent","text":"<p>To get existed content from sc-link you can use the method <code>GetLinkContent</code>. A content can be represented as numeric or  string. If content doesn't exist in sc-link, then the method <code>GetLinkContent</code> will return <code>false</code> and result content will be empty.</p> <pre><code>...\n// Get string content from sc-link.\nstd::string stringContent;\nbool const stringContentExist \n  = context.GetLinkContent(linkAddr1, stringContent);\n\n// Get numeric content from sc-link.\nfloat numericContent;\nbool const numericContentExist \n  = context.GetLinkContent(linkAddr1, numericContent);\n...\n</code></pre> <p>Note</p> <p>You can set empty content into sc-link, but it means that this sc-link has content and this method for this  sc-link returns <code>true</code>.</p>"},{"location":"sc-memory/api/cpp/core/api/#searchlinksbycontent","title":"SearchLinksByContent","text":"<p>You can find sc-links by its content. For this use the method <code>SearchLinksByContent</code>.</p> <pre><code>...\n// Find sc-links with specified string content.\nScAddrSet const &amp; linkAddrs1 = context.SearchLinksByContent(\"my content\");\n// The set `linkAddrs1` must contain sc-address `linkAddr1`.\n\n// Find sc-links with specified numeric content.\nScAddrSet const &amp; linkAddrs2 = context.SearchLinksByContent(10f);\n// The set `linkAddrs2` must contain sc-address `linkAddr2`.\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#searchlinksbycontentsubstring","title":"SearchLinksByContentSubstring","text":"<p>And you can find sc-links by its content substring. For this use the method <code>SearchLinksByContentSubstring</code>.</p> <pre><code>...\n// Find sc-links with specified string content substring.\nScAddrSet const &amp; linkAddrs1 \n  = context.SearchLinksByContentSubstring(\"my cont\");\n// The set `linkAddrs1` must contain sc-address `linkAddr1`.\n</code></pre> <p>Also, you can provide a filter to search sc-links to define criteria for which links should be included in the search results. This allows for customization of which links are considered based on user-defined conditions. The filter must be an instance of a class derived from <code>ScLinkFilter</code>, which implements the <code>CheckLink</code> and <code>RequestLink</code> methods.</p> <pre><code>class TestScLinkFilter final : public ScLinkFilter\n{\npublic:\n  // You can specify custom fields and methods.\n  ScMemoryContext * m_context;\n  ScAddr m_linkClassAddr;\n  size_t m_foundLinksCount = 0u;\n\n  bool CheckLink(ScAddr const &amp; linkAddr) override\n  {\n    // Don't include sc-link in result if it doesn't belong \n    // to `m_linkClassAddr`.\n    return m_context-&gt;CheckConnector(\n      m_linkClassAddr, linkAddr, ScType::ConstPermPosArc);\n  }\n\n  ScLinkFilterRequest RequestLink(ScAddr const &amp; linkAddr) override\n  {\n    // Iterate over only the first 5 sc-links.\n    ++m_foundLinksCount;\n\n    if (m_foundLinksCount == 5u)\n      return ScLinkFilterRequest::STOP;\n\n    return ScLinkFilterRequest::CONTINUE;\n  }\n};\n\n\n// Some method A\n...\n// For example, generate sc-links, set contents for them and add only \n// one of them to some set or class.\nScAddr const &amp; linkClassAddr = m_ctx-&gt;GenerateNode(ScType::ConstNodeClass);\nScAddr const &amp; linkAddr1 = m_ctx-&gt;GenerateLink(ScType::ConstNodeLink);\nScAddr const &amp; linkAddr2 = m_ctx-&gt;CreateLink(ScType::ConstNodeLink);\n\nm_ctx-&gt;SetLinkContent(linkAddr1, \"content 1\");\nm_ctx-&gt;SetLinkContent(linkAddr2, \"content 2\");\n\nm_ctx-&gt;GenerateConnector(ScType::ConstPermPosArc, linkClassAddr, linkAddr1);\n...\n\n// Some method B\n...\n// Create object of custom sc-link filter class and search sc-links \n// with this filter.\nScMemoryContext context;\nCustomScLinkFilter filter;\nfilter.m_context = &amp;context;\nfilter.m_linkClassAddr = linkClassAddr;\n\nScAddrSet const &amp; links \n  = m_ctx-&gt;SearchLinksByContentSubstring(\"content\", filter);\n// The `links` must have only one sc-link sc-address `linkAddr1`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#searchlinkscontentsbycontentsubstring","title":"SearchLinksContentsByContentSubstring","text":"<p>Also, you can find contents of sc-links by its content substring. For this use the method <code>SearchLinksContentsByContentSubstring</code>.</p> <pre><code>...\n// Find contents of sc-links with specified string content substring.\nstd::set&lt;std::string&gt; const &amp; linkContents \n  = context.SearchLinksContentsByContentSubstring(\"my cont\");\n// The set `linkContents` must contain string `my content`.\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#scexception","title":"ScException","text":"<p>To declare your own exceptions inherit from class <code>ScException</code>.</p> <pre><code>class MyException final : public ScException\n{\npublic:\n  explicit MyException(\n    std::string const &amp; description, std::string const &amp; message) \n    : ScException(\"MyException: \" + description, message)\n  {}\n};\n</code></pre> <p>To throw exceptions use <code>SC_THROW_EXCEPTION(exceptionName, message);</code>.</p> <pre><code>SC_THROW_EXCEPTION(MyException, \"It is my exception.\");\n</code></pre> <p>Throw exception for a non-implemented part of code.</p> <pre><code>SC_NOT_IMPLEMENTED(\"This code is not implemented.\");\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#sclogger","title":"ScLogger","text":"<p>The <code>ScLogger</code> class provides a robust logging mechanism for your code.</p> <p>To create an instance of ScLogger, you can use the constructor that specifies the logging type (console or file), the log file name (if applicable), and the initial log level. Here\u2019s how to do it:</p> <pre><code>// Create a logger that logs to the console with Info level\nutils::ScLogger logger(\n  utils::ScLogger::ScLogType::Console, \"\", utils::ScLogLevel::Info);\n\n// Create a logger that logs to a file with Debug level\nutils::ScLogger fileLogger(\n  utils::ScLogger::ScLogType::File, \"log_file.txt\", utils::ScLogLevel::Debug);\n</code></pre> <p>Once you have created an instance of ScLogger, you can call its various methods to manage logging.</p>"},{"location":"sc-memory/api/cpp/core/api/#message-error-warning-info-debug","title":"Message (Error, Warning, Info, Debug)","text":"<p>Use the <code>Message</code> method to log messages at different severity levels:</p> <pre><code>logger.Info(\"This is an informational message.\");\n// or \n// logger.Message(\n//   utils::ScLogLevel::Info, \n//   \"This is an informational message.\",\n//   ScConsole::Color::Grey);\n\nfileLogger.Error(\"An error occurred while processing.\");\n// or\n// fileLogger.Message(\n//    utils::ScLogLevel::Error,\n//    \"An error occurred while processing.\",\n//    ScConsole::Color::Red);\n</code></pre> <p>It prints colored info message. Look color constants in <code>ScConsole::Color</code>.</p>"},{"location":"sc-memory/api/cpp/core/api/#setloglevel","title":"SetLogLevel","text":"<p>You can change the log level dynamically:</p> <pre><code>logger.SetLogLevel(utils::ScLogLevel::Warning);\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#mute-and-unmute","title":"Mute and Unmute","text":"<p>Control whether logs are outputted:</p> <pre><code>logger.Mute();   // Mute logging\nlogger.Unmute(); // Unmute logging\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#setprefix","title":"SetPrefix","text":"<p>Customize prefix for logs:</p> <pre><code>logger.SetPrefix(\"MyAgent: \");\n\nlogger.Info(\"It is info message\");\n// Output: MyAgent: Is info message \n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#clear","title":"Clear","text":"<p>Clear any open file streams or flush logs if necessary:</p> <pre><code>logger.Clear();\n</code></pre>"},{"location":"sc-memory/api/cpp/core/api/#log-levels","title":"Log levels","text":"<p>The following macros are available for logging messages at different severity levels:</p> Method Message prefix Message color Log levels <code>Debug</code> <code>[Debug]</code> <code>ScConsole::Color::Grey</code> Debug <code>Info</code> <code>[Info]</code> <code>ScConsole::Color::LightBlue</code> Debug, Info <code>Warning</code> <code>[Warning]</code> <code>ScConsole::Color::Yellow</code> Debug, Info, Warning <code>Error</code> <code>[Error]</code> <code>ScConsole::Color::Red</code> Debug, Info, Warning, Error <p>These macros simplify the process of logging messages by automatically formatting them with appropriate prefixes and colors based on their severity levels.</p>"},{"location":"sc-memory/api/cpp/core/api/#extended-api","title":"Extended API","text":"<p>Described methods are part of Core C++ API of sc-memory. You can see and use Extended C++ API of sc-memory:</p> <ul> <li>ScHelper C++ API to manipulate with system identifiers of sc-elements; </li> <li>ScTemplate C++ API, providing functionality for creating, manipulating and retrieving  large graph structures.</li> </ul>"},{"location":"sc-memory/api/cpp/core/api/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>What is the difference between ScType::ConstCommonArc and ScType::ConstPermPosArc?</li> <li>How can I specify empty ScAddr?</li> </ul>"},{"location":"sc-memory/api/cpp/core/api/#what-is-the-difference-between-sctypeconstcommonarc-and-sctypeconstpermposarc","title":"What is the difference between ScType::ConstCommonArc and ScType::ConstPermPosArc?","text":"<p><code>ScType::ConstCommonArc</code> is a sc-type of sc-arc that connects two sc-elements in some relation. <code>ScType::ConstPermPosArc</code> is a sc-type of sc-arc that denotes membership of target sc-element to source sc-element. The sc-arc with sc-type <code>ScType::ConstCommonArc</code> between some two sc-elements can be transformed to sc-node to which  this two sc-elements belong.</p>"},{"location":"sc-memory/api/cpp/core/api/#how-can-i-specify-empty-scaddr","title":"How can I specify empty ScAddr?","text":"<p>Empty <code>ScAddr</code> is the sc-address that has hash that equals to <code>0</code>.</p> <pre><code>...\nScAddr addr;\n// Here `addr` is empty.\n\nmyFunc(addr);\n// or\nmyFunc(ScAddr::Empty);\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/helper_api/","title":"C++ System Identifier API","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>This API allows to work with system identifiers of sc-elements. All methods of this API are the part of class  <code>ScMemoryContext</code>. So, you can use they from object of class <code>ScMemoryContext</code>.</p> <p>A system identifier is an identifier that is unique within the entire knowledge base. This identifier is usually used in  the source texts of the lower-level knowledge base. To ensure internationalization, it is recommended that system  identifiers be written in English. The characters used in the system identifier can be letters of the Latin alphabet,  numbers, underscores and dashes. Thus, it is most appropriate to form the system identifier of the sc-element from  the main English one by replacing all characters not included in the alphabet described above with the character \u201c_\u201d.</p> <p>Note</p> <p>All system identifiers must satisfy the regular pattern <code>([a-z]|[A-Z]|'_'|'.'|[0-9])+</code>.</p> <p>Note</p> <p>Now only sc-nodes and sc-links can have system identifiers.</p> <p>There is a quintuple of sc-node with its system identifier.</p> <p></p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_memory.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/helper_api/#setelementsystemidentifier","title":"SetElementSystemIdentifier","text":"<p>To set system identifier for some sc-node or sc-link, use the method <code>SetElementSystemIdentifier</code>. If passed system identifier is not valid then the method <code>SetElementSystemIdentifier</code> will throw the exception <code>utils::ExceptionInvalidParams</code> with  description of the error. If passed system identifier is already used for other sc-element then the method will return <code>false</code>.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.GenerateNode(ScType::ConstNode);\n\nbool const &amp; isSystemIdentifierSet \n    = context.SetElementSystemIdentifier(\"my_node\", nodeAddr);\n// The value of `isSystemIdentifierSet` must be equal to `true`.\n...\n</code></pre> <p>If you want to get creating quintuple you can provide variable of type <code>ScSystemIdentifierQuintuple</code> as out parameter.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.GenerateNode(ScType::ConstNode);\n\nScSystemIdentifierQuintuple quintuple;\nbool const &amp; isSystemIdentifierSet \n    = context.SetElementSystemIdentifier(\"my_node\", nodeAddr, quintuple);\nScAddr const &amp; myNodeAddr = quintuple.addr1;\n// The value of `myNodeAddr` must be equal to the value of `nodeAddr`.\nScAddr const &amp; arcToSystemIdtfLinkAddr = quintuple.addr2;\n// The sc-address of common sc-arc between your sc-node and \n// sc-link with system identifier of your sc-node.\nScAddr const &amp; systemIdtfLinkAddr = quintuple.addr3;\n// The sc-address of sc-link with system identifier of your sc-node.\nScAddr const &amp; arcToArcToSystemIdtfLinkAddr = quintuple.addr4;\n// The sc-address of membership sc-arc between binary sc-relation \n// with system identifier `nrel_system_identifier` and the common sc-arc\n// between your sc-node and sc-link with system identifier of your sc-node.\nScAddr const &amp; nrelSystemIdtfAddr = quintuple.addr5;\n// The sc-address of binary sc-relation with system identifier \n// `nrel_system_identifier`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/helper_api/#getelementsystemidentifier","title":"GetElementSystemIdentifier","text":"<p>To get system identifier of sc-element you can use the method <code>GetElementSystemIdentifier</code>. If sc-element hasn't system  identifier then the method will return empty string.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.GenerateNode(ScType::ConstNode);\n\nbool const &amp; isSystemIdentifierSet \n    = context.SetElementSystemIdentifier(\"my_node\", nodeAddr);\n// The value of `isSystemIdentifierSet` must be equal to `true`.\n\nstd::string const &amp; systemIdtf = context.GetElementSystemIdentifier(nodeAddr);\n// The value of `systemIdtf` must be equal to `\"my_node\"`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/helper_api/#searchelementbysystemidentifier","title":"SearchElementBySystemIdentifier","text":"<p>You can find sc-element by its system identifier. For this use the method <code>SearchElementBySystemIdentifier</code>. It will return  <code>true</code> if there is sc-element with provided system identifier, otherwise <code>false</code>.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.GenerateNode(ScType::ConstNode);\n\nbool const &amp; isSystemIdentifierSet \n    = context.SetElementSystemIdentifier(\"my_node\", nodeAddr);\n// The value of `isSystemIdentifierSet` must be equal to `true`.\n\nScAddr resultAddr;\nbool const &amp; isElementWithSystemIdtfFound \n    = context.SearchElementBySystemIdentifier(\"my_node\", resultAddr);\n// The value of `isElementWithSystemIdtfFound` must be equal to `true` \n// and the value of `resultAddr` must be equal to the value of `nodeAddr`.\n\n// Or use the another definition of this method.\nresultAddr = context.SearchElementBySystemIdentifier(\"my_node\");\n// The value of `resultAddr` must be equal to the value of `nodeAddr`.\n\n// Or use the another definition of this method.\nresultAddr = context.SearchElementBySystemIdentifier(\"not_my_node\");\n// The value of `resultAddr` must be invalid.\n...\n</code></pre> <p>If you want to find quintuple sc-element with its system identifier you can provide variable of type  <code>ScSystemIdentifierQuintuple</code> as out parameter.</p> <pre><code>...\nScAddr const &amp; nodeAddr = context.GenerateNode(ScType::ConstNode);\n\nbool const &amp; isSystemIdentifierSet \n    = context.SetElementSystemIdentifier(\"my_node\", nodeAddr);\n// The value of `isSystemIdentifierSet` must be equal to `true`.\n\nScSystemIdentifierQuintuple quintuple;\nbool const &amp; isElementWithSystemIdtfFound \n    = context.SearchElementBySystemIdentifier(\"my_node\", quintuple);\nScAddr const &amp; myNodeAddr = quintuple.addr1;\n// The value of `myNodeAddr` must be equal to the value of `nodeAddr`.\nScAddr const &amp; arcToSystemIdtfLinkAddr = quintuple.addr2;\n// The sc-address of common sc-arc between your sc-node \n// and sc-link with system identifier of your sc-node.\nScAddr const &amp; systemIdtfLinkAddr = quintuple.addr3;\n// The sc-address of sc-link with system identifier of your sc-node.\nScAddr const &amp; arcToArcToSystemIdtfLinkAddr = quintuple.addr4;\n// The sc-address of membership sc-arc between binary sc-relation \n// with system identifier `nrel_system_identifier` and the common sc-arc \n// between your sc-node and sc-link with system identifier of your sc-node.\nScAddr const &amp; nrelSystemIdtfAddr = quintuple.addr5;\n// The sc-address of binary sc-relation with system identifier \n// `nrel_system_identifier`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/helper_api/#resolveelementsystemidentifier","title":"ResolveElementSystemIdentifier","text":"<p>Very often you can need to resolve sc-element by system identifier. Resolve sc-element by system identifier refers to finding for sc-element with providing system identifier and (if such sc-element is not found) creating sc-element with provided system identifier and sc-type.</p> <pre><code>...\nScAddr const &amp; nodeAddr \n    = ResolveElementSystemIdentifier(\"my_node\", ScType::ConstNode);\n// If there is no sc-element with system identifier `\"my_node\"` \n// then the method will create sc-element with this system identifier \n// and provided sc-type `ScType::ConstNode`.\n...\n</code></pre> <p>Note</p> <p>Provided sc-type must be a subtype of sc-type of sc-node or sc-type of sc-link.</p> <p>If you want to resolve quintuple sc-element with its system identifier you can provide variable of type <code>ScSystemIdentifierQuintuple</code> as out parameter.</p> <pre><code>...\nScSystemIdentifierQuintuple quintuple;\nbool const &amp; isSystemIdentifierResolved \n    = context.ResolveElementSystemIdentifier(\n        \"my_node\", ScType::ConstNode, quintuple);\nScAddr const &amp; myNodeAddr = quintuple.addr1;\n// The sc-address of resolved sc-node by provided system identifier.\nScAddr const &amp; arcToSystemIdtfLinkAddr = quintuple.addr2;\n// The sc-address of common sc-arc between your sc-node and sc-link \n// with system identifier of your sc-node.\nScAddr const &amp; systemIdtfLinkAddr = quintuple.addr3;\n// The sc-address of sc-link with system identifier of your sc-node.\nScAddr const &amp; arcToArcToSystemIdtfLinkAddr = quintuple.addr4;\n// The sc-address of membership sc-arc between binary sc-relation\n// with system identifier `nrel_system_identifier` and the common sc-arc \n// between your sc-node and sc-link with system identifier of your sc-node.\nScAddr const &amp; nrelSystemIdtfAddr = quintuple.addr5;\n// The sc-address of binary sc-relation with system identifier \n// `nrel_system_identifier`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/helper_api/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>Can I specify empty system identifier for sc-element?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/helper_api/#can-i-specify-empty-system-identifier-for-sc-element","title":"Can I specify empty system identifier for sc-element?","text":"<p>You can not specify empty system identifier for sc-element. All system identifiers must satisfy the regular  pattern <code>([a-z]|[A-Z]|'_'|'.'|[0-9])+</code>.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/","title":"User permissions API","text":"<p>Note</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>This API allows to handle users and their permissions in knowledge base.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#who-are-users-of-ostis-systems","title":"Who are users of ostis-systems?","text":"<p>Users interact with ostis-systems. Users can be other systems, agents or people. All users of an ostis-system can perform actions on its knowledge base. There are six classes of user actions in knowledge base:</p> <ul> <li>action_read_from_sc_memory;</li> <li>action_generate_in_sc_memory;</li> <li>action_erase_from_sc_memory;</li> <li>action_read_permissions_from_sc_memory;</li> <li>action_generate_permissions_in_sc_memory;</li> <li>action_erase_permissions_from_sc_memory.</li> </ul> <p>Before a user action is performed, it is checked whether the user has permissions to perform actions of the specified class.</p> <p>By default, user permissions are not handled by sc-machine. This is configured via the sc-machine config (<code>&lt;config-name&gt;.ini</code>). To enable user permissions handling in the sc-machine, go to the group <code>[sc-memory]</code> and set <code>user_mode</code> as <code>true</code>.</p> <pre><code>[sc-memory]\n...\nuser_mode = true\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#how-are-users-managed","title":"How are users managed?","text":"<p>You can only work with sc-memory through methods provided in <code>ScMemoryContext</code> class. Each object of this class can be considered as an object that handles information about a user (including his permissions) when that user invokes methods through that object.</p> <p>To work with sc-memory, you should create object of <code>ScMemoryContext</code> class or use existing one. If you create context via constructor, then this context will have guest user (user with <code>concept_guest_user</code> class). </p> <pre><code>ScMemoryContext context;\nScAddr const &amp; guestUserAddr = context.GetUser();\n// This user should belongs `concept_guest_user` class.\n\n// After you can use `context` to generate, search or erase sc-elements \n// in sc-memory.\n</code></pre> <p>You can get user from object of context, if you need to handle this user.</p> <pre><code>ScAddr const &amp; userAddr = context.GetUser();\n</code></pre> <p><code>concept_guest_user</code> class is default class for all users in sc-memory. By default, all guest users haven't permissions. You can specify permissions for their class. See documentation below to learn how to do it.</p> <p>When some user initiates a sc-event, an object of <code>ScMemoryContext</code> with this user is created for the agent that reacted to this sc-event. After this agent uses this context to manipulate with sc-constructions within sc-memory. Each agent class has <code>m_context</code> field. You should use it to call methods in sc-memory.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#how-does-the-sc-machine-identifies-users","title":"How does the sc-machine identifies users?","text":"<p>You can identify user. User identification refers to the process of identifying a user on ostis-system, i.e., that the specified guest user is some user that is on the knowledge base.</p> <p>It is useful when your ostis-system implements functionality to work with guest users. The sc-machine provides users identification. You can identify some guest user as user that had been already registered in the system. Users identification allows you to implement your own agent to register/authorize users by password, token or something else.</p> <p>To identify user in the sc-memory, you should create connection between guest user and identified user.</p> <pre><code>..some_guest_user =&gt; nrel_identified_user: ..some_user;;\n</code></pre> <p>After that, all contexts that had specified guest user will have specified identified user. </p> <p>To unidentify identified user, you can create reverse connection between specified guest user and specified identified user.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#how-does-the-sc-machine-authenticate-users","title":"How does the sc-machine authenticate users?","text":"<p>Users can be known in advance and then guest users and their identification is unnecessary, but all users should be authenticated in sc-memory. User authentication involves the process of verifying the authenticity of identified user and storing information about that user in sc-memory.</p> <p>To authenticate user in sc-memory, you should create connection between <code>concept_authentication_request_user</code> and user:</p> <pre><code>concept_authentication_request_user -&gt; ..some_user;;\n</code></pre> <p>You should do it once, no more. After the sc-machine authenticates this user, it means that connection between <code>concept_authenticated_user</code> and user has been created and all contexts with this user have been authenticated.</p> <pre><code>concept_authenticated_user ~&gt; ..some_user;;\n</code></pre> <p>If you remove this sc-arc between <code>concept_authenticated_user</code> and the user, then the user and all contexts with user will be also unauthenticated.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#examples-of-using-user-identification-and-authentication","title":"Examples of using user identification and authentication","text":""},{"location":"sc-memory/api/cpp/extended/permissions_api/#example-of-user-identification","title":"Example of user identification","text":"<p>You should identify guest user as user that should be authenticated. </p> <pre><code>// Create context with guest user.\nScMemoryContext context;\n// Get guest user from created context.\nScAddr const &amp; guestUserAddr = context.GetUser();\n\n// Find a user, which should be identified. You can provide your own logic \n// of user identification before.\nScAddr const &amp; userAddr1 = context.SearchElementBySystemIdentifier(\"user_1\");\n\n// Before user identification, specify that user isn't identified. \n// This way, you can subscribe to sc-event of erasing negative sc-arc, \n// because when you identify user, all existing negative sc-arcs \n// between `nrel_identified_user` and sc-arc between guest user and user \n// to be identified are erased. This logic will help you to wait for user \n// to be identified.\nScAddr const &amp; arcAddr = ScMemory::ms_globalContext-&gt;GenerateConnector(\n  ScType::ConstCommonArc, guestUserAddr, userAddr1);\nScMemory::ms_globalContext-&gt;GenerateConnector(\n  ScType::ConstTempNegArc, ScKeynodes::nrel_identified_user, arcAddr);\n\n// Create sc-event waiter to wait user to be identified.\n// You should subscribe to sc-event of erasing negative sc-arc incoming to\n// sc-arc between guest user and user to be identified.\nauto eventWaiter \n  = ScMemory::ms_globalContext-&gt;CreateConditionWaiter&lt;\n    ScEventBeforeEraseIncomingArc&lt;ScType::ConstTempNegArc&gt;&gt;(\n  arcAddr,\n  [&amp;]() -&gt; void\n  {\n    // Identify guest user.\n    ScMemory::ms_globalContext-&gt;GenerateConnector(\n      ScType::ConstTempPosArc, ScKeynodes::nrel_identified_user, arcAddr);\n    // Only `ScMemory::ms_globalContext` can identify users.\n  },\n  [&amp;](ScEventBeforeEraseIncomingArc&lt;ScType::ConstTempNegArc&gt; const &amp; event) \n    -&gt; bool\n  {\n    // Check that sc-arc from `nrel_identified_user` is erased.\n    return event.GetArcSourceElement() \n      == ScKeynodes::nrel_identified_user;\n  });\n\n// After creation, call method `Wait` and specify time while you \n// will wait sc-event for specified subscription sc-element.\neventWaiter-&gt;Wait(200); // milliseconds\n// By default, this wait time equals to 5000 milliseconds.\n// You will wait until sc-event occurs or until specified time expires.\n</code></pre> <p>After, you can authenticate identified user.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#example-of-user-authentication","title":"Example of user authentication","text":"<p>To do this programly you can create waiter to wait sc-event of adding outgoing sc-arc from <code>concept_authenticated_user</code> and request user to be authenticated, i.e. create sc-arc between <code>concept_authentication_request_user</code> and user. After waiting this sc-event, your user will be authenticated.</p> <pre><code>...\n// Find a user, which you want to authenticate.\nScAddr const &amp; userAddr1 = context.SearchElementBySystemIdentifier(\"user_1\");\n\n// Before user authentication, specify that user isn't authenticated. \n// This way, you can subscribe to sc-event of erasing negative sc-arc, \n// because when you authenticate user, all existing negative sc-arcs \n// between `concept_authenticated_user` and user are erased. This logic will \n// help you to wait for user to be authenticated.\nScMemory::ms_globalContext-&gt;GenerateConnector(\n  ScType::ConstTempNegArc, \n  ScKeynodes::concept_authenticated_user,\n  userAddr1);\n\n// Create sc-event waiter to wait user to be authenticated.\n// You should subscribe to sc-event of erasing negative sc-arc incoming to\n// user.\nauto eventWaiter \n  = ScMemory::ms_globalContext-&gt;CreateConditionWaiter&lt;\n    ScEventBeforeEraseIncomingArc&lt;ScType::ConstTempNegArc&gt;&gt;(\n  userAddr1,\n  [&amp;]() -&gt; void\n  {\n    ScMemory::ms_globalContext-&gt;GenerateConnector(\n      ScType::ConstPermPosArc, \n      ScKeynodes::concept_authentication_request_user, \n      userAddr1);\n\n    // Only `ScMemory::ms_globalContext` can authenticate users.\n  },\n  [&amp;](ScEventBeforeEraseIncomingArc&lt;ScType::ConstTempNegArc&gt; const &amp; event) \n    -&gt; bool\n  {\n    // Check that sc-arc from `concept_authenticated_user` is erased.\n    return event.GetArcSourceElement() \n      == ScKeynodes::concept_authenticated_user;\n  });\n\n// After creation, call method `Wait` and specify time while you \n// will wait sc-event for specified subscription sc-element.\neventWaiter-&gt;Wait(200); // milliseconds\n// By default, this wait time equals to 5000 milliseconds.\n// You will wait until sc-event occurs or until specified time expires.\n</code></pre> <p>Yes, this way of waiting for user authentication is complicated, but it ensures that the NOT factors in the user information are accounted for. In the future, transaction mechanisms will be implemented in the sc-machine to simplify its API.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#example-of-user-unauthentication","title":"Example of user unauthentication","text":"<p>To unauthenticate user, you must erase sc-arc between <code>concept_authenticated_user</code> and user.</p> <pre><code>...\n// Find a user, which you want to unauthenticate.\nScAddr const &amp; userAddr1 = context.SearchElementBySystemIdentifier(\"user_1\");\n\n// Create sc-event waiter to wait user to be unauthenticated.\n// You should subscribe to sc-event of adding negative sc-arc incoming to\n// user, because it will be added when you erase sc-arcs between \n// `concept_authenticated_user` and user.\nauto eventWaiter \n  = ScMemory::ms_globalContext-&gt;CreateConditionWaiter&lt;\n    ScEventAfterGenerateIncomingArc&lt;ScType::ConstTempNegArc&gt;&gt;(\n  userAddr1,\n  [&amp;]() -&gt; void\n  {\n    // Find and erase connection between `concept_authenticated_user`\n    // and user.\n    ScIterator3Ptr it3 = ScMemory::ms_globalContext-&gt;Iterator3(\n      ScKeynodes::concept_authenticated_user,\n      ScType::EdgeAccessConstPosTemp,\n      userAddr1\n    );\n    if (it3-&gt;Next())\n    {\n      ScMemory::ms_globalContext-&gt;EraseElement(it3-&gt;Get(1));\n    }\n\n    // Only `ScMemory::ms_globalContext` can unauthenticate users.\n  },\n  [&amp;](ScEventAfterGenerateIncomingArc&lt;ScType::ConstTempNegArc&gt; const &amp; event) \n    -&gt; bool\n  {\n    // Check that sc-arc from `concept_authenticated_user` is added.\n    return event.GetArcSourceElement() \n      == ScKeynodes::concept_authenticated_user;\n  });\n\n// After creation, call method `Wait` and specify time while you \n// will wait sc-event for specified subscription sc-element.\neventWaiter-&gt;Wait(200); // milliseconds\n</code></pre> <p>You can use these examples to identify guest users.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#how-are-user-permissions-managed","title":"How are user permissions managed?","text":""},{"location":"sc-memory/api/cpp/extended/permissions_api/#action-classes-used-to-handle-user-permissions","title":"Action classes used to handle user permissions","text":"<p>In order for a user to successfully execute a method from <code>ScMemoryContext</code>, it is necessary that the knowledge base for that user specifies that it can perform the class of actions that corresponds to that method.</p> <p>Description of action classes that users of ostis-system can perform in its knowledge base is represented below:</p> Action class System identifier of action class sc-node Abbreviation Logic if user has permissions to execute actions of the specified class reading from sc-memory action <code>action_read_from_sc_memory</code> R The user can execute all methods that read sc-constructions from knowledge base. generating in sc-memory action <code>action_generate_in_sc_memory</code> G The user can execute all methods that generate sc-constructions in knowledge base. erasing from sc-memory action <code>action_erase_from_sc_memory</code> E The user can execute all methods that erase sc-constructions from knowledge base. reading permissions from sc-memory action <code>action_read_permissions_from_sc_memory</code> RP The user can read permissions of other users from knowledge base. generating permissions in sc-memory action <code>action_generate_permissions_in_sc_memory</code> GP The user can generate permissions for other users in knowledge base. erasing permissions from sc-memory action <code>action_erase_permissions_from_sc_memory</code> EP The user can erase permissions of other users from knowledge base. <p>Each core method of C++ Core API checks user permissions. All methods of C++ Extended API use methods of C++ Core API. Description of ScMemoryContext API methods and user permissions required to execute these methods is represented below:</p> ScMemoryContext API method R G E Logic if user hasn't required permissions to perform method GenerateNode, GenerateLink - - - These methods don't require any permissions for users. GenerateConnector - + - If user hasn't permissions to add sc-connector from specified source sc-element or to specified target sc-element, then method will throw <code>utils::ExceptionInvalidState</code>. IsElement + - - If user hasn't permissions to read specified sc-element, then method will throw <code>utils::ExceptionInvalidState</code>. GetElementType + - - If user hasn't permissions to read specified sc-element, then method will throw <code>utils::ExceptionInvalidState</code>. SetElementSubtype - + - If user hasn't permissions to update specified sc-element sc-type, then method will throw <code>utils::ExceptionInvalidState</code>. GetConnectorIncidentElements, GetArcSourceElement, GetArcTargetElement + - - If user hasn't permissions to read specified sc-connector or its incident sc-elements, then method will throw <code>utils::ExceptionInvalidState</code>. CreateIterator3, CreateIterator5, ForEach, ForEach + - - If user hasn't permissions to read some sc-connectors from or to specified sc-element, then method won't return these sc-connectors to user: method <code>ScIterator::Next</code> will skip these sc-connectors. If user has permissions to read sc-connector from or to specified sc-element, but he hasn't permissions to read other incident sc-elements, then method <code>ScIterator::Get</code> will throw <code>utils::ExceptionInvalidState</code> if user tries to get such permitted sc-element by index in found sc-construction. Methods <code>ForEach</code> will return empty sc-address in such case. EraseElement - - + If user hasn't permissions to erase specified sc-element, then method will return <code>false</code>. SetLinkContent - + + If user hasn't permissions to change (erase and write) content for specified sc-link, then method will throw <code>utils::ExceptionInvalidState</code>. GetLinkContent + - - If user hasn't permissions to read specified sc-link by specified content, then method will throw <code>utils::ExceptionInvalidState</code>. SearchLinksByContent, SearchLinksByContentSubstring + - - If user hasn't permissions to read some sc-links that have specified content, then method won't return these sc-links."},{"location":"sc-memory/api/cpp/extended/permissions_api/#global-and-local-user-permissions","title":"Global and local user permissions","text":"<p>Depending on where the user can perform actions in the knowledge base, their permissions are divided into global and local permissions:</p> <ul> <li>global permissions is permissions over entire knowledge base;</li> <li>local permissions is permissions in some part (sc-structure) of knowledge base.</li> </ul> <p>Permissions can be set on a specific user or group (set or class) of users.</p> <p>All permissions can be represented as connections between users, action classes and sc-structures:</p> Permissions class System identifier of relation sc-node for concrete user Description Global permissions <code>nrel_user_action_class</code> Binary relation between concrete user and action class Local permissions <code>nrel_user_action_class_within_sc_structure</code> Ternary relation between concrete user and action class with sc-structure where actions of specified class can be performed by this user Permissions class System identifier of relation sc-node for users set Description Global permissions <code>nrel_users_set_action_class</code> Binary relation between users set and action class Local permissions <code>nrel_users_set_action_class_within_sc_structure</code> Ternary relation between users set and action class with sc-structure where actions of specified class can be performed by this one of users <p>Examples of global and local read permissions for user and users set:</p> Permissions SCg-code example SCs-code example User has global read permissions <pre>\n        <code>\n..user &lt;~ concept_user;;\n\nnrel_user_action_class\n~&gt; (..user =&gt; action_read_from_sc_memory);; \n        </code>\n      </pre> User has local read permissions <pre>\n        <code>\n..user &lt;~ concept_user;;\n\n..structure = [*\n    concept_set ~&gt; ..set;;\n*];;\n\nnrel_user_action_class_within_sc_structure\n~&gt; (..user =&gt; (action_read_from_sc_memory =&gt; ..structure));;\n        </code>\n      </pre> Each user in users set has global read permissions <pre>\n        <code>\nnrel_users_set_action_class\n~&gt; (concept_user =&gt; action_read_from_sc_memory);;\n        </code>\n      </pre> Each user in users set has local read permissions <pre>\n        <code>\n..structure = [*\n    concept_set ~&gt; ..set;;\n*];;\n\nnrel_users_set_action_class_within_sc_structure\n~&gt; (..user =&gt; (action_read_from_sc_memory =&gt; ..structure));;\n        </code>\n      </pre> User hasn't global read permissions <pre>\n        <code>\n..user &lt;~ concept_user;;\n\nnrel_user_action_class\n~|&gt; (..user =&gt; action_read_from_sc_memory);;\n        </code>\n      </pre> User hasn't local read permissions <pre>\n        <code>\n..user &lt;~ concept_user;;\n\n..structure = [*\nconcept_set ~&gt; ..set;;\n*];;\n\nnrel_user_action_class_within_sc_structure\n~|&gt; (..user =&gt; (action_read_from_sc_memory =&gt; ..structure));;\n        </code>\n      </pre> Each user in users set hasn't global read permissions <pre>\n        <code>\nnrel_users_set_action_class\n~|&gt; (concept_user =&gt; action_read_from_sc_memory);;\n        </code>\n      </pre> Each user in users set hasn't local read permissions <pre>\n        <code>\n..structure = [*\n    concept_set ~&gt; ..set;;\n*];;\n\nnrel_users_set_action_class_within_sc_structure\n~|&gt; (..user =&gt; (action_read_from_sc_memory =&gt; ..structure));;\n        </code>\n      </pre> <p>In these examples, you can use any other action class (<code>action_generate_in_sc_memory</code>, <code>action_erase_from_sc_memory</code>, <code>action_read_permissions_from_sc_memory</code>, <code>action_generate_permissions_in_sc_memory</code> or <code>action_erase_permissions_from_sc_memory</code>) instead of <code>action_read_from_sc_memory</code>.</p> <p>All sc-arcs from permissions classes (relations) must be permanent or temporary. All sc-arcs from user groups (classes or sets) must be permanent or temporary.</p> <p>Note</p> <p>If the knowledge base does not explicitly specify permissions for a user, it is equivalent to saying that this user does not have them.</p> <p>Note</p> <p>In order to erase permissions for a user it is enough to erase an membership sc-arc from the relation that indicated permissions.</p> <p>Note</p> <p>In the sc-machine there is a global system context -- <code>ScMemory::ms_globalContext</code>, that has all permissions. You can use it to update permissions that can be used to read, update or erase permissions for other users.</p> <p>Warning</p> <p>Erasing a positive membership sc-arc between relation and sc-arc between the user and an action class, that the user can perform (pair with sc-structure and action class), automatically creates a negative membership sc-arc between the given relation and the sc-arc between the user and the action class (the pair with sc-structure and action class).</p> <p></p> <p>Warning</p> <p>Creating a positive membership sc-arc between relation and sc-arc between the user and an action class, that the user can perform (pair with sc-structure and action class), automatically erases all negative membership sc-arcs between the given relation and the sc-arc between the user and the action class (the pair with sc-structure and action class).</p> <p></p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#compatibility-of-global-and-local-user-permissions","title":"Compatibility of global and local user permissions","text":"<p>Both global and local permissions can be described for the same user. It is important to know the logic of how they work together. For example, concrete user wants to handle some sc-construction. There may be several cases:</p> Case Criterion 1. Does specified sc-construction belong to any permitted sc-structure? Criterion 2. Does user have global permissions? Criterion 3. Does user have local permissions? Result. Can user handle the specified sc-construction? 1 No, it doesn't. No, he doesn't. No, he doesn't. No, he doesn't. 2 No, it doesn't. Yes. He has global write permissions. No, he doesn't. Yes. He can only add sc-elements into the specified sc-construction, because he has global write permissions. 3 Yes. The sc-construction is in a sc-structure that indicates that certain permissions are required. Some users have permissions to this sc-structure. No, he doesn't. No, he doesn't. No, he doesn't. 4 Yes. The sc-construction is in a sc-structure that indicates that certain permissions are required. Some users have permissions to this sc-structure. Yes. He has global read permissions. No, he doesn't. No, he doesn't. The user hasn't local permissions for the specified sc-structure. But he can read any sc-constructions in knowledge base, which doesn't have permitted sc-structures. 5 Yes. The sc-construction is in a sc-structure that indicates that certain permissions are required. Some users have permissions to this sc-structure. No, he doesn't. Yes. He has local write permissions for the specified sc-structure. Yes. The user can only add sc-elements into the specified sc-structure. But he can't handle any sc-constructions in knowledge base other than the given one. 6 Yes. The sc-construction is in a sc-structure that indicates that certain permissions are required. Some users have permissions to this sc-structure. Yes. He has global write permissions. Yes. He has local write permissions for the specified sc-structure. Yes. The user can add sc-elements into the specified sc-structure. And he can add sc-element into any sc-constructions in knowledge base other than the given one."},{"location":"sc-memory/api/cpp/extended/permissions_api/#examples-of-using-user-permissions","title":"Examples of using user permissions","text":"<p>If you want to update permissions for a user, then you can describe them in the knowledge base in any format convenient for you (SCs-code or SCg-code) or do it programly.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#example-for-adding-updating-user-permissions","title":"Example for adding (updating) user permissions","text":"<p>If you want to add permissions for user constantly, specify permissions for this user in the knowledge base. See examples of local and global user permissions above.</p> <p>To do this programly you can create waiter to wait sc-event of adding outgoing sc-arc from permissions class and add permissions for this user. After waiting this sc-event, your user will have new user permissions.</p> <pre><code>...\n// Find a user, for whom you need to add new permissions.\nScAddr const &amp; userAddr1 = context.SearchElementBySystemIdentifier(\"user_1\");\n// Find a structure, within which the user should have permissions.\nScAddr const &amp; structureAddr \n  = context.SearchElementBySystemIdentifier(\"my_structure\");\n\n// Before adding new user permissions, specify that user doesn't have these\n// permissions. This way, you can subscribe to sc-event of erasing negative \n// sc-arc, because when you add new permissions for user, all existing \n// negative sc-arcs to permissions are erased. This logic will help you to \n// wait for user's permissions to be changed.\nScAddr const &amp; _actionClassArcAddr = context.GenerateConnector(\n  ScType::ConstCommonArc, \n  ScKeynodes::action_generate_in_sc_memory, \n  structureAddr);\nScAddr const &amp; _userArcAddr = context.GenerateConnector(\n  ScType::ConstCommonArc, \n  userAddr1, \n  _actionClassArcAddr);\ncontext.GenerateConnector(\n  ScType::ConstTempNegArc, \n  ScKeynodes::nrel_user_action_class_within_sc_structure, \n  _userArcAddr);\n\n// Create sc-event waiter to wait adding new permissions for specified user.\n// You should subscribe to sc-event of erasing negative sc-arc. \n// Negative sc-arc is erased when you added new permissions for user. \nauto eventWaiter \n  = context.CreateConditionWaiter&lt;\n    ScEventEraseOutgoingArc&lt;ScType::ConstTempNegArc&gt;&gt;(\n  ScKeynodes::nrel_user_action_class_within_sc_structure,\n  [&amp;]() -&gt; void\n  {\n    // Update user permissions here.\n    ScAddr const &amp; actionClassArcAddr = context.GenerateConnector(\n      ScType::ConstCommonArc, \n      ScKeynodes::action_generate_in_sc_memory, \n      structureAddr);\n    ScAddr const &amp; userArcAddr = context.GenerateConnector(\n      ScType::ConstCommonArc, \n      userAddr1, \n      actionClassArcAddr);\n    context.GenerateConnector(\n      ScType::EdgeAccessConstPosTemp, \n      ScKeynodes::nrel_user_action_class_within_sc_structure, \n      userArcAddr);\n    // You should create sc-arc from permissions class at \n    // the end of this callback.\n\n    // And note, that if `context` user doesn't have permissions to create\n    // permissions in sc-memory for other users, you should to update \n    // permissions for user of `context` or use `ScMemory::ms_globalContext` \n    // that has all permissions, by default.\n  },\n  [&amp;](ScEventEraseOutgoingArc&lt;ScType::ConstTempNegArc&gt; const &amp; event)\n    -&gt; bool\n  {\n    // Check that permissions for specified are updated.\n    ScAddr targetElementAddr = event.GetArcTargetElement();\n    if (context.GetElementType(targetElementAddr) \n        != ScType::ConstCommonArc)\n      return false;\n\n    auto [userAddr, permissionsAddr]\n      = context.GetConnectorIncidentElements(targetElementAddr);\n\n    return userAddr == userAddr1;\n  });\n\n// After creation, call method `Wait` and specify time while you \n// will wait sc-event for specified subscription sc-element.\neventWaiter-&gt;Wait(200); // milliseconds\n// By default, this wait time equals to 5000 milliseconds.\n// You will wait until sc-event occurs or until specified time expires.\n</code></pre> <p>Yes, this way of waiting for permissions to change is complicated, but it ensures that the NOT factors in the user information are accounted for. In the future, transaction mechanisms will be implemented in the sc-machine to simplify its API.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#example-for-erasing-user-permissions","title":"Example for erasing user permissions","text":"<p>To erase permissions for a user, you must erase sc-arc from permissions class.</p> <pre><code>...\n// Find a user, for whom you need to erase permissions.\nScAddr const &amp; userAddr1 = context.SearchElementBySystemIdentifier(\"user_1\");\n// Find a structure, within which the user should no longer have rights\nScAddr const &amp; structureAddr \n  = context.SearchElementBySystemIdentifier(\"my_structure\");\n// Create sc-event waiter to wait erasing permissions for specified user. \n// You should subscribe to sc-event of adding negative sc-arc. \n// Negative sc-arc is added when you erases user permissions. \nauto eventWaiter \n  = context.CreateConditionWaiter&lt;\n    ScEventAfterGenerateOutgoingArc&lt;ScType::ConstTempNegArc&gt;&gt;(\n  ScKeynodes::nrel_user_action_class_within_sc_structure,\n  [&amp;]() -&gt; void\n  {\n    // Update user permissions here.\n    ScTemplate permissionsTemplate;\n    permissionsTemplate.Triple(\n      ScKeynodes::action_generate_in_sc_memory,\n      ScType::VarCommonArc &gt;&gt; \"_action_class_arc\",  \n      structureAddr\n    );\n    permissionsTemplate.Quintuple(\n      userAddr1, \n      ScType::VarCommonArc,\n      \"_action_class_arc\",\n      ScType::VarTempPosArc &gt;&gt; \"_permissions_arc\",\n      ScKeynodes::nrel_user_action_class_within_sc_structure \n    );\n    ScTemplateSearchResult result;\n    if (context.SearchByTemplate(permissionsTemplate, result))\n    {\n      context.EraseElement(result[0][\"_permissions_arc\"]);\n      // You should erase sc-arc from permissions class at \n      // the end of this callback.\n    }\n\n    // And note, that if `context` user doesn't have permissions to read\n    // permissions in sc-memory for other users, you should to update \n    // permissions for user of `context` or use `ScMemory::ms_globalContext` \n    // that has all permissions, by default.\n  },\n  [&amp;](ScEventAfterGenerateOutgoingArc&lt;ScType::ConstTempNegArc&gt; const &amp; event)\n    -&gt; bool\n  {\n    // Check that permissions for specified are erased.\n    ScAddr targetElementAddr = event.GetArcTargetElement();\n    if (context.GetElementType(targetElementAddr) \n        != ScType::ConstCommonArc)\n      return false;\n\n    auto [userAddr, permissionsAddr]\n      = context.GetConnectorIncidentElements(targetElementAddr);\n\n    return userAddr == userAddr1;\n  });\n\n// After creation, call method `Wait` and specify time while you \n// will wait sc-event for specified subscription sc-element.\neventWaiter-&gt;Wait(200); // milliseconds\n</code></pre> <p>These examples can be reused for any of permissions classes described above.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>How to specify role for users in knowledge base and set permissions for this role?</li> <li>How to specify permissions to structures that are not described in knowledge base sources?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#how-to-specify-role-for-users-in-knowledge-base-and-set-permissions-for-this-role","title":"How to specify role for users in knowledge base and set permissions for this role?","text":"<p>A role for users should be understood as a class of users. You can specify permission for user classes.</p> <p>The following example shows how global and local permissions are specified for a class of users:</p> <pre><code>concept_users_class_1\n~&gt; ..user_1;;\n\nnrel_users_set_action_class\n~&gt; (concept_users_class_1 =&gt; action_read_from_sc_memory);;\n\nnrel_users_set_action_class_within_sc_structure\n~&gt; (concept_users_class_1 =&gt; (action_read_from_sc_memory =&gt; ..structure));;\n\n..structure = [*\n    concept_users_class_2 ~&gt; ..user_2;;\n    ..user_2 -&gt; rrel_password: [password];;\n*];;\n</code></pre> <p>This example shows that all users from <code>concept_users_class_1</code> can view the entire knowledge base besides the structure describing users from <code>concept_users_class_2</code>.</p>"},{"location":"sc-memory/api/cpp/extended/permissions_api/#how-to-specify-permissions-to-structures-that-are-not-described-in-knowledge-base-sources","title":"How to specify permissions to structures that are not described in knowledge base sources?","text":"<p>You can generate and update structures in knowledge base while system is running. You can also generate and modify permissions to structures in knowledge base while system is running. To do this, you should use all available API methods.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/","title":"C++ ScTemplate API","text":"<p>Warning</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>Sc-templates is a very powerful mechanism to work with semantic network (graph). You can generate and search any constructions using sc-templates. In the following picture the sc-template and the isomorphic sc-construction are shown.</p> <p></p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_memory.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplate","title":"ScTemplate","text":"<p>The class to work with sc-templates in C++ API. Before reading this paragraph you need to read common information about sc-element types.</p> <p>Let use <code>f</code> symbols for constant parameter of sc-template. Let use <code>a</code> symbol for a variable parameter of sc-template.  Then sc-template to search all outgoing sc-connectors from specified sc-element will be a triple:</p> <ul> <li>where the first sc-element is known <code>f</code>;</li> <li>second and the third sc-elements need to be found <code>a</code>.</li> </ul> <p>There are possible 3 types of triple sc-templates:</p> <ul> <li><code>f_a_a</code> - sc-template to find all outgoing sc-connectors from a specified sc-element;</li> <li><code>f_a_f</code> - sc-template to find all sc-connectors between two specified sc-elements;</li> <li><code>a_a_f</code> - sc-template to find all incoming sc-connectors to a specified sc-element.</li> </ul> <p>And there are possible 7 types of quintuple sc-templates:</p> <ul> <li><code>f_a_a_a_a</code> - sc-template to find all outgoing sc-connectors from a specified sc-element with all attributes of this sc-connectors;</li> <li><code>f_a_f_a_a</code> - sc-template to find all sc-connectors between two specified sc-elements with all attributes of this sc-connectors;</li> <li><code>f_a_a_a_f</code> - sc-template to find all outgoing sc-connectors from a specified sc-element with specified attribute;</li> <li><code>f_a_f_a_f</code> - sc-template to find all sc-connectors between two specified sc-elements with specified attribute;</li> <li><code>a_a_f_a_a</code> - sc-template to find all incoming sc-connectors to a specified sc-element with all attributes of this sc-connectors;</li> <li><code>a_a_f_a_f</code> - sc-template to find all incoming sc-connectors to a specified sc-element with specified attribute;</li> <li><code>a_a_a_a_f</code> - sc-template to find all sc-connectors with specified attribute.</li> </ul> <p>Here attribute is sc-element from which the sc-connector is outgoing to the searchable sc-connectors.</p> <p>There are some methods available for <code>ScTemplate</code> class:</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#triple","title":"Triple","text":"<p>It is the method that adds triple sc-construction into sc-template. There are some examples of using this function to produce simple sc-templates:</p> Template Description f_a_a Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Triple(\n  param1,\n  ScType::VarPermPosArc,\n  ScType::VarNode\n);\n</code></pre> This triple sc-template is used to traverse outgoing sc-connectors from specified sc-element.       There <code>param1</code> is a known sc-address of sc-element. It must be a valid (use <code>IsElement</code> method to check). Where <code>_param2</code> and <code>_param3</code> are sc-types for compare by search engine. When search engine will traverse outgoing sc-connectors from <code>param1</code>. Construction will be added into traverse result, where outgoing sc-arc from <code>param1</code>, will suitable to specified type <code>_param2</code>, and type of target sc-element of this sc-arc will be suitable for a type <code>_param3</code>.       You can use any sc-type of <code>_param3</code> (including sc-connectors) depending on sc-construction you want to find. But <code>_param2</code> should be any sc-type of variable sc-connector.      f_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Triple(\n  param1,\n  ScType::VarPermPosArc,\n  param3\n);\n</code></pre> This triple sc-template using to find sc-arc between <code>param1</code> and <code>param3</code>.       There are <code>param1</code> and <code>param3</code> a known <code>ScAddr</code> of sc-elements. Arc type <code>_param2</code> should be variable.      a_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Triple(\n  ScType::VarNode,\n  ScType::VarPermPosArc,\n  param3\n);\n</code></pre> This triple sc-template using to traverse incoming sc-connectors to specified sc-element.       There <code>param3</code> is a known sc-address of sc-element. You can use any type of <code>_param1</code> (including sc-connectors) depending on construction you want to find. But <code>_param2</code> should be any type of variable connector."},{"location":"sc-memory/api/cpp/extended/template_api/#quintuple","title":"Quintuple","text":"<p>It is the method that adds quintuple sc-construction into sc-template. There are some examples of using this  function to produce simple sc-templates:</p> Template Description f_a_a_a_a Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  param1,\n  ScType::VarPermPosArc,\n  ScType::VarNode,\n  ScType::VarPermPosArc,\n  ScType::VarNode\n);\n</code></pre> f_a_f_a_a Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  param1,\n  ScType::VarPermPosArc,\n  param3,\n  ScType::VarPermPosArc,\n  ScType::VarNode\n);\n</code></pre> f_a_a_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  param1,\n  ScType::VarPermPosArc,\n  ScType::VarNode,\n  ScType::VarPermPosArc,\n  param5\n);\n</code></pre> f_a_f_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  param1,\n  ScType::VarPermPosArc,\n  param3,\n  ScType::VarPermPosArc,\n  param5\n);\n</code></pre> a_a_f_a_a Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  ScType::VarNode,\n  ScType::VarPermPosArc,\n  param3,\n  ScType::VarPermPosArc,\n  ScType::VarNode\n);\n</code></pre> a_a_f_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  ScType::VarNode,\n  ScType::VarPermPosArc,\n  param3,\n  ScType::VarPermPosArc,\n  param5\n);\n</code></pre> a_a_a_a_f Graphical representation Equal C++ code <pre><code>\nScTemplate templ;\ntempl.Quintuple(\n  ScType::VarNode,\n  ScType::VarPermPosArc,\n  ScType::VarNode,\n  ScType::VarPermPosArc,\n  param5\n);\n</code></pre> <p>When sc-template search engine works, it tries to traverse graph by simple (triple or quintuple) sc-template in order they specified. For example, we need to check if specified sc-element (<code>_set</code>) is included into <code>concept_set</code> class and <code>concept_binary_relation</code> class:</p> <p></p> <p>There is example code that generates equal sc-template.</p> <pre><code>...\n// Find key concepts that should be used in sc-template.\nScAddr const &amp; conceptSetAddr = context.SearchElementBySystemIdentifier(\"concept_set\");\nScAddr const &amp; conceptBinaryRelationAddr \n    = context.SearchElementBySystemIdentifier(\"concept_binary_relation\");\n\n// Generate sc-template and add triples into this sc-template.\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,    // sc-address of concept set node\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_set\"\n);\ntempl.Triple(\n  conceptBinaryRelationAddr,    // sc-address of concept binary relation node\n  ScType::VarPermPosArc,\n  \"_set\"\n);\n..\n</code></pre> <p>In code, you can see a construction <code>ScType::VarNode &gt;&gt; \"_set\"</code> - this is a naming for a sc-template sc-element. It allows to set alias for a specified sc-element in sc-template, and use it many times in different triples. You can see, that in the second triple we use this alias <code>\"_set\"</code>. That means, that we need to place search result from a first triple into the second. So the second triple is a <code>f_a_f</code> style triple.</p> <p>So if you want to use the same sc-element <code>_x</code> in different triples, and you doesn't know it <code>ScAddr</code>, then just use two main rules:</p> <ul> <li>Set alias of this sc-element in a first occurrence of this sc-element in sc-template triples. You need to use <code>&gt;&gt;</code> operator to   do this (see code below, last sc-element of first triple).</li> <li>When you need to use aliased sc-element in next triples, then just use it alias instead of <code>ScType</code> or <code>ScAddr</code> (see code   below, first sc-element of second triple).</li> </ul> <p>There is the example code with naming.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  anyAddr, // sc-address of known sc-element\n  ScType::VarPermPosArc,  // type of unknown sc-arc\n  ScType::VarNode &gt;&gt; \"_x\"  // type and alias for an unknown sc-element\n);\ntempl.Triple(\n  \"_x\",  // say that is the same sc-element as the last on in a previous triple\n  ScType::VarPermPosArc,  // type of unknown sc-arc\n  ScType::VarNode  // type of unknown sc-node\n);\n...\n</code></pre> <p>Inside a program object of a sc-template all its constructions are represented as triples.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#hasreplacement","title":"HasReplacement","text":"<p>To check that sc-template has an aliased sc-element you can use the method <code>HasReplacement</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  anyAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\nbool const hasAliasX = templ.HasReplacement(\"_x\");\n// The value of `hasAliasX` be equal to `true`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#size","title":"Size","text":"<p>To get count of triples in sc-template, use the method <code>Size</code>. It may be useful if your program can choose optimal for  manipulating sc-template.</p> <pre><code>ScTemplate templ;\ntempl.Triple(\n  anyAddr, // sc-address of known sc-element\n  ScType::VarPermPosArc,  // type of unknown sc-arc\n  ScType::VarNode &gt;&gt; \"_x\"  // type and alias for an unknown sc-element\n);\ntempl.Triple(\n  \"_x\",  // say that is the same sc-element as the last on in a previous triple\n  ScType::VarPermPosArc,  // type of unknown sc-arc\n  ScType::VarNode  // type of unknown sc-node\n);\n\nsize_t const tripleCount = templ.Size();\n// The triple count must be equal to `2`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#isempty","title":"IsEmpty","text":"<p>If you need sc-template to be empty you don't have to add any constructions into it. But you should know that result of generation by this sc-template is always <code>true</code> and result of searching by this sc-template is always <code>false</code>. To check that sc-template is empty use the method <code>IsEmpty</code>.</p> <pre><code>...\nScTemplate templ;\nbool const isEmpty = templ.IsEmpty();\n// The value of `isEmpty` be equal to `true`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplatebuild","title":"ScTemplateBuild","text":"<p>Also, you can build sc-templates using SCs-code.</p> <pre><code>...\n// Describe your sc-template in SCs-code.\nsc_char const * data = \n  \"_set\"\n  \"  _&lt;- concept_set;\"\n  \"  _&lt;- concept_binary_set;;\";\n\n// Build program object by this sc-template.\nScTemplate templ;\ncontext.BuildTemplate(templ, data);\n...\n</code></pre> <p>Note</p> <p>Don't use result value, it doesn't mean anything.</p> <p>During sc-template building all constants will be resolved by their system identifier (in example: <code>concept_set</code>, <code>concept_binary_set</code>), so in result <code>templ</code> will contain sc-template:</p> <p></p> <p>Or you can it by specifying valid sc-address of some sc-template in sc-memory.</p> <pre><code>...\n// Find by system identifier your sc-template in sc-memory.\nScAddr const &amp; templAddr = context.SearchElementBySystemIdentifier(\"my_template\");\n\n// Build program object by this sc-template.\nScTemplate templ;\ncontext.BuildTemplate(templ, templAddr);\n...\n</code></pre> <p>Note</p> <p>Don't use result value, it doesn't mean anything.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplateparams","title":"ScTemplateParams","text":"<p>You can replace existing sc-variables in sc-templates by your ones. To provide different replacements for sc-variables  in different cases there is class <code>ScTemplateParams</code>. It stores a map between sc-variables and specified values (replacements).</p> <pre><code>...\nScTemplateParams params;\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#add","title":"Add","text":"<p>You can add replacement for sc-variable by specifying system identifier of this sc-variable if sc-template is built from SCs-code.</p> <pre><code>...\n// Describe your sc-template on SCs-code.\nsc_char const * data = \n  \"_set\"\n  \"  _&lt;- concept_set;\"\n  \"  _&lt;- concept_binary_set;;\";\n\n// Generate replacement in sc-memory.\nScAddr const &amp; setAddr = context.GenerateNode(ScType::ConstNode);\n// Also you can find some replacement from sc-memory.\n\n// Define replacements for sc-variables in sc-template.\nScTemplateParams params;\nparams.Add(\"_set\", setAddr);\n\n// Build program object by this sc-template, specifying replacements.\nScTemplate templ;\ncontext.BuildTemplate(templ, data, params);\n...\n</code></pre> <p>Or you can add replacement for sc-variable by specifying sc-address of this sc-variable if sc-template is built from  sc-address of sc-structure in sc-memory.</p> <pre><code>...\n// Find by system identifier your sc-template in sc-memory.\nScAddr const &amp; templAddr = context.SearchElementBySystemIdentifier(\"my_template\");\n\n// Find by system identifier sc-address of sc-variable in your sc-template.\nScAddr const &amp; setVarAddr = context.SearchElementBySystemIdentifier(\"_set\");\n\n// Generate replacement in sc-memory.\nScAddr const &amp; setAddr = context.GenerateNode(ScType::ConstNode);\n// Also you can find some replacement from sc-memory.\n\n// Define replacements for sc-variables in sc-template.\nScTemplateParams params;\nparams.Add(setVarAddr, setAddr);\n\n// Build program object by this sc-template, specifying replacements.\nScTemplate templ;\ncontext.BuildTemplate(templ, templAddr, params);\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#get","title":"Get","text":"<p>Sometimes you need to check if there is replacement in params yet. You can do it using the method <code>Get</code>. It works with system identifiers and sc-addresses of sc-variables also.</p> <pre><code>...\n// Generate replacement in sc-memory.\nScAddr const &amp; setAddr = context.GenerateNode(ScType::ConstNode);\n// Also you can find some replacement from sc-memory.\n\n// Define replacements for sc-variables in sc-template.\nScTemplateParams params;\nparams.Add(\"_set\", setAddr);\n\nScAddr const &amp; replAddr = params.Get(\"_set\");\n// The value of `replAddr` be equal to value of `setAddr`.\n...\n</code></pre> <pre><code>...\n// Find by system identifier sc-address of sc-variable in your sc-template.\nScAddr const &amp; setVarAddr = context.SearchElementBySystemIdentifier(\"_set\");\n\n// Generate replacement in sc-memory.\nScAddr const &amp; setAddr = context.GenerateNode(ScType::ConstNode);\n// Also you can find some replacement from sc-memory.\n\n// Define replacements for sc-variables in sc-template.\nScTemplateParams params;\nparams.Add(setVarAddr, setAddr);\n\nScAddr const &amp; replAddr = params.Get(setVarAddr);\n// The value of `replAddr` be equal to value of `setAddr`.\n...\n</code></pre> <p>Note</p> <p>If there are no replacements by specified system identifier or sc-address of sc-variable of sc-template then the  method <code>Get</code> will return empty sc-address.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#isempty_1","title":"IsEmpty","text":"<p>To check that replacements map is empty use the method <code>IsEmpty</code>.</p> <pre><code>...\nScTemplateParams params;\nbool const isEmpty = params.IsEmpty();\n// The value of `isEmpty` be equal to `true`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#generatebytemplate","title":"GenerateByTemplate","text":"<p>Use sc-template to generate graphs in sc-memory and get replacements from result.</p> <pre><code>...\n// Specify sc-template for searching sc-constructions in sc-memory.\n// You can use `ScTemplate` methods or method ScTemplateBuild to translate \n// sc-template from SCs-code or sc-memory into program representation.\nScTemplateResultItem result;\ncontext.GenerateByTemplate(templ, result);\n// Sc-elements sc-addresses of generated sc-construction may be gotten from \n// `result`.\n...\n</code></pre> <p>Note</p> <p>Remember, that sc-template must contain only valid sc-address of sc-elements and all sc-connectors in it must be sc-variables. Otherwise, this method can throw <code>utils::ExceptionInvalidParams</code> with description of this error.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplateresultitem","title":"ScTemplateResultItem","text":"<p>It is a class that stores information about sc-construction.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#safe-get","title":"Safe Get","text":"<p>You can get sc-addresses of sc-elements of generated sc-construction by system identifier or sc-address of sc-variable  in sc-template. To do it safely (without throwing exceptions if there are no replacements by specified system identifier  or sc-address of sc-variable of sc-template) use the methods <code>Get</code> and provide result of replacement as out parameter in this method.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\ncontext.GenerateByTemplate(templ, result);\n\nScAddr setAddr;\nbool replExist = result.Get(\"_x\", setAddr);\n// The value of `replExist` be equal to `true`.\n\nbool replExist = result.Get(\"_y\", setAddr);\n// The value of `replExist` be equal to `false`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#get_1","title":"Get","text":"<p>If you want to catch exceptions, if there are no replacements by specified system identifier or sc-address of sc-variable  of sc-template, use the method <code>Get</code> and get replacement as result of this method. Then this method will throw  <code>utils::ExceptionInvalidParams</code> with description of error.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\ncontext.GenerateByTemplate(templ, result);\n\nScAddr setAddr = result.Get(\"_x\");\n\nsetAddr = result.Get(\"_y\", setAddr);\n// It will throw the exception `utils::ExceptionInvalidParams`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#has","title":"Has","text":"<p>To check that there is replacement by specified system identifier or sc-address of sc-variable of sc-template use the method <code>Has</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\ncontext.GenerateByTemplate(templ, result);\n\nbool const replExist = result.Has(\"_x\");\n// The value of `replExist` be equal to `true`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#operator","title":"operator[]","text":"<p>To get all replacements in result you can use the <code>operator[]</code>. It returns replacement by index of sc-variable in  sc-template. If there is no sc-variable with specified index this method will throw the exception  <code>utils::ExceptionInvalidParams</code> with description of the error.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\ncontext.GenerateByTemplate(templ, result);\n\nScAddr const &amp; setAddr = result[2];\n// It is equal to `result.Get(\"_x\")`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#size_1","title":"Size","text":"<p>If you want to iterate all replacement in the result you need to know size of this result.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n\nScTemplateResultItem result;\ncontext.GenerateByTemplate(templ, result);\n\n// Iterate by all replacements in result.\nfor (size_t i = 0; i &lt; result.Size(); ++i)\n{\n  ScAddr const &amp; addr = result[i];\n  // Implement your code to handle replacements.\n}\n...\n</code></pre> <p>Note</p> <p>The method <code>Size</code> returns summary count of indexes of replacements in each triple in sc-template. If there are  <code>2</code> triples in sc-template, then there are <code>2 * 3 = 6</code> different indexes of replacements in sc-template.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#searchbytemplate","title":"SearchByTemplate","text":"<p>You can search sc-construction in sc-memory by sc-templates. This search refers to isomorphic search by graph-template. Search algorithm trying to find all possible variants of specified construction. It uses any constants (available sc-addresses from parameters to find equal sc-constructions in sc-memory).</p> <pre><code>...\n// Specify sc-template for searching sc-constructions in sc-memory.\n// You can use `ScTemplate` methods or method ScTemplateBuild to translate \n// sc-template from SCs-code or sc-memory into program representation.\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.SearchByTemplate(templ, result);\n// Program representation of sc-constructions in `ScTemplateResultItem` \n// may be gotten from `result`.\n...\n</code></pre> <p>Note</p> <p>Remember, that sc-template must contain only valid sc-address of sc-elements and all sc-connectors in it must be sc-variables. Otherwise, this method can throw <code>utils::ExceptionInvalidParams</code> with description of this error.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#sctemplatesearchresult","title":"ScTemplateSearchResult","text":"<p>It is a class that stores in information about sc-constructions represented in <code>ScTemplateResultItem</code>. An object of class <code>ScTemplateSearchResult</code> can be referred to a vector of objects of class <code>ScTemplateResultItem</code>.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#safe-get_1","title":"Safe Get","text":"<p>To get object of class <code>ScTemplateResultItem</code> you can use the method <code>Get</code>. If you want to get objects safely, use the method <code>Get</code> and provide <code>ScTemplateResultItem</code> as out parameter in this method.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.SearchByTemplate(templ, result);\n\nScTemplateResultItem item;\nbool constrExist = result.Get(0, item);\n// The value of `constrExist` be equal to `true`.\n\nconstrExist = result.Get(1, item);\n// The value of `constrExist` be equal to `false` and item is not valid.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#get_2","title":"Get","text":"<p>If you want to catch exceptions use the method <code>Get</code> and get result as return value. If there is no sc-construction with  specified index this method will throw the exception utils::ExceptionInvalidParams with description of the error.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.SearchByTemplate(templ, result);\n\nScTemplateResultItem item = result.Get(0);\n// It is a valid item.\n\nitem = result.Get(1);\n// It throws `utils::ExceptionInvalidParams`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#operator_1","title":"operator[]","text":"<p>Also, you can use the method <code>operator[]</code> to do this. If there is no sc-construction with specified index this method  will throw the exception utils::ExceptionInvalidParams with description of the error.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.SearchByTemplate(templ, result);\n\nScTemplateResultItem item = result[0];\n// It is a valid item.\n\nitem = result[1];\n// It throws `utils::ExceptionInvalidParams`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#size_2","title":"Size","text":"<p>To get count of found sc-constructions by sc-template you can use the method <code>Size</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.SearchByTemplate(templ, result);\n\nsize_t const count = result.Size();\n// The value of `count` be equal to `1`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#isempty_2","title":"IsEmpty","text":"<p>To check if found result is empty use the method <code>IsEmpty</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.SearchByTemplate(templ, result);\n\nbool const count = result.IsEmpty();\n// The value of `count` be equal to `false`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#clear","title":"Clear","text":"<p>To clear all information about found sc-constructions use the method <code>Clear</code>.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.SearchByTemplate(templ, result);\n\nresult.Clear();\n// After that `result` does not contain any information about sc-constructions.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#foreach","title":"ForEach","text":"<p>To iterate all program objects of found sc-constructions by sc-template you can use for-each cycle.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.SearchByTemplate(templ, result);\n\nfor (size_t i = 0; i &lt; result.Size(); ++i)\n{\n  ScTemplateResultItem const &amp; item = result.Get(i);\n  // Implement logic to handle found sc-constructions.\n}\n...\n</code></pre> <p>Or you can use the method <code>ForEach</code> to do this.</p> <pre><code>...\nScTemplate templ;\ntempl.Triple(\n  conceptSetAddr,\n  ScType::VarPermPosArc,\n  ScType::VarNode &gt;&gt; \"_x\"\n);\n// There is one sc-construction that is isomorphic this sc-template.\n\nScTemplateSearchResult result;\nbool const isFoundByTemplate = context.SearchByTemplate(templ, result);\n\nresult.ForEach([](ScTemplateResultItem const &amp; item) {\n  // Implement logic to handle found sc-constructions.\n});\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#searchbytemplateinterruptibly","title":"SearchByTemplateInterruptibly","text":"<p>This method searches constructions by isomorphic sc-template and pass found sc-constructions to <code>callback</code>  lambda-function. Lambda-function <code>callback</code> must return a request command value to manage sc-template search:</p> <ul> <li>ScTemplateSearchRequest::CONTINUE,</li> <li>ScTemplateSearchRequest::STOP,</li> <li>ScTemplateSearchRequest::ERROR.</li> </ul> <p>When ScTemplateSearchRequest::CONTINUE returns, sc-template search will be continued. If ScTemplateSearchRequest::STOP  or ScTemplateSearchRequest::ERROR returns, then sc-template search stops. If sc-template search stopped by  ScTemplateSearchRequest::ERROR, then SearchByTemplateInterruptibly thrown utils::ExceptionInvalidState. If <code>filterCallback</code>  passed, then all found sc-constructions triples are filtered by <code>filterCallback</code> condition.</p> <pre><code>...\nScAddr const &amp; structureAddr = context.SearchElementBySystemIdentifier(\"my_structure\");\nScAddr const &amp; setAddr = context.SearchElementBySystemIdentifier(\"my_set\");\nScAddr const &amp; classAddr = context.SearchElementBySystemIdentifier(\"my_class\");\n\nScTemplate templ;\ntempl.Triple(\n  classAddr,\n  ScType::VarPermPosArc &gt;&gt; \"_arc\",\n  ScType::Unknown &gt;&gt; \"_addr2\"\n);\nm_context-&gt;SearchByTemplateInterruptibly(templ, [&amp;context](\n    ScTemplateSearchResultItem const &amp; item) -&gt; ScTemplateSearchRequest \n{\n  ScAddr const &amp; arcAddr = item[\"_arc\"];\n  if (context-&gt;CheckConnector(\n      structureAddr, arcAddr, ScType::ConstPermPosArc))   \n    return ScTemplateSearchRequest::CONTINUE;\n\n  if (context.GenerateConnector(\n      ScType::ConstTempPosArc, setAddr, item[\"_addr2\"]))\n    return ScTemplateSearchRequest::STOP;\n\n  return ScTemplateSearchRequest::ERROR;\n});\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/template_api/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>What's the best way to describe sc-templates for search? By sc-template C++ API or on the SC-code?</li> <li>Which is better: searching by sc-template or by iterator?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/template_api/#what-is-the-best-way-to-describe-sc-templates-for-search-by-sc-template-c-api-or-on-the-sc-code","title":"What is the best way to describe sc-templates for search? By sc-template C++ API or on the SC-code?","text":"<p>The description of sc-templates in the knowledge base encourages the use of reflection for them. The sc-templates  described in the knowledge base can be easily expanded and improved. However, sc-templates presented through the API  do not require preprocessing (translation from the knowledge base), so the speed of the program used by such  sc-templates may be higher if the sc-templates have significant size.</p>"},{"location":"sc-memory/api/cpp/extended/template_api/#which-is-better-searching-by-sc-template-or-by-iterator","title":"Which is better: searching by sc-template or by iterator?","text":"<p>In all cases sc-iterator is faster the searching by sc-template. If you want to search large sc-constructions, then don't search they by one large sc-template, divide it into certain sc-templates or use sc-iterators instead of sc-template.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/","title":"C++ Actions API","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>The C++ Actions API is dedicated to defining and initiating actions that agents can perform within the sc-machine environment. This section provides guidelines on how to implement various actions, including their arguments and results.</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_action.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#what-is-action","title":"What is action?","text":"<p>All actions are processes. Any process is performed by some subject. Each action can be defined as a process of solving some problem, i.e. as a process of achieving the given goal with the given conditions. Each action denotes some transformation carried out in the external environment or in the memory of some system.</p> <p>Like an agent, an action has a specification. This specification includes: class, arguments, state, result. The specification of an action is called a problem.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#scaction","title":"ScAction","text":"<p>The sc-machine provides <code>ScAction</code> class to handle actions in sc-memory. You can't use constructors of this class, because they are private. Use <code>ScAgentContext</code> to generate action with provided class or use the existing one. All methods of this class work directly with the knowledge base, there is no local cache.</p> <pre><code>// Find action class and generate action.\n...\nScAction action = context.GenerateAction(actionClassAddr);\n...\n</code></pre> <p></p> <p>Note</p> <p>You should provide action class that is include to the one of types: <code>receptor_action</code>, <code>effector_action</code>, <code>behavioral_action</code> or <code>information_action</code>.</p> <pre><code>// Or find action and convert it to object of `ScAction` class.\n...\nScAction action = context.ConvertToAction(actionAddr);\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#getclass","title":"GetClass","text":"<p>To get class of action use this method.</p> <pre><code>...\nScAddr const &amp; actionClassAddr = action.GetClass();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#getargument","title":"GetArgument","text":"<p>Actions can have arguments. Action arguments are some objects using which this action should be performed. If action has arguments in knowledge base, then you will get them. There are a couple of getters for this.</p> <pre><code>...\n// Provide relation here if your argument has specific role in action. \nScAddr const &amp; argAddr = action.GetArgument(ScKeynodes::rrel_1);\n// If there is no argument with such role, then `argAddr` will be empty.\n...\n</code></pre> <pre><code>...\n// Or provide index of argument. 1 is equal to `ScKeynodes::rrel_1`,\n// 2 is equal to `ScKeynodes::rrel_2` and etc.\nScAddr const &amp; argAddr = action.GetArgument(1);\n// If there is no argument with such role, then `argAddr` will be empty.\n...\n</code></pre> <p></p> <p>Note</p> <p>There is a limit to the number of order role relations. You can get from <code>rrel_1</code> up to and including <code>rrel_20</code>.</p> <p>Warning</p> <p>This method will throw <code>utils::ExceptionInvalidParams</code> if you provide invalid index for argument (for example, 0 or 21).</p> <pre><code>...\nScAddr const &amp; argAddr = action.GetArgument(1, defaultArgumentAddr);\n// If there is no argument with such role, then `argAddr` will equal \n// to `defaultArgumentAddr`.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#getarguments","title":"GetArguments","text":"<p>You can get all arguments using one getter.</p> <pre><code>...\n// Here, 2 is number of arguments in specified action.\nauto const &amp; [argAddr1, argAddr2] = action.GetArguments&lt;2&gt;();\n// If action doesn't have some argument, it will be empty.\n...\n</code></pre> <pre><code>...\n// You can ignore some arguments.\nauto const &amp; [argAddr1, argAddr2, _] = action.GetArguments&lt;3&gt;();\n...\n</code></pre> <p></p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#setargument","title":"SetArgument","text":"<p>You can set arguments for specified action.</p> <pre><code>...\n// Provide relation here if your argument should have specific role in action. \naction.SetArgument(ScKeynodes::rrel_1, argAddr);\n...\n</code></pre> <pre><code>...\n// Or provide index of argument. 1 is equal to `ScKeynodes::rrel_1`,\n// 2 is equal to `ScKeynodes::rrel_2`, etc.\naction.SetArgument(1, argAddr);\n...\n</code></pre> <p></p> <p>Note</p> <p>If action already has an argument with specified role, then connection between action and existing argument will be removed and connection between action and new argument will be generated.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#setarguments","title":"SetArguments","text":"<pre><code>...\n// Set several arguments simultaneously.\naction.SetArguments(argAddr1, argAddr2);\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#action-result","title":"Action result","text":"<p>All actions should have result (result situation). Result situation is structure that contains all sc-constructions that indicate result of performed (finished) action.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#getresult","title":"GetResult","text":"<p>You get can result of any action. Result may be empty.</p> <pre><code>...\n// Use this method after some agent finishes \n// performing action.\nScStructure const &amp; actionResult = action.GetResult();\n...\n</code></pre> <p></p> <p>Warning</p> <p>If you call this method for not finished action, then this method will throw <code>utils::ExceptionInvalidState</code>. It prevents a situation where an agent that performs an action is still forming a result for that action, and you haven't waited for it and already want to get result for that action.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#setresult","title":"SetResult","text":"<pre><code>...\n// Use this method in agent performing action \n// to set new result.\naction.SetResult(resultStructure);\n...\n</code></pre> <p>Note</p> <p>If action has result, then existing result will be removed and the new one will be set.</p> <p>Warning</p> <p>If you call this method for not finished, but initiated action only, the this method will throw <code>utils::ExceptionInvalidState</code>.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#formresult","title":"FormResult","text":"<p>You may not generate result structure. You can provide only elements of result for action.</p> <pre><code>...\n// Use this method in agent performing action \n// to form new result with provided sc-elements.\naction.FormResult(elementAddr1, elementAddr2);\n...\n</code></pre> <p>Note</p> <p>If action has result, then existing result will be removed and the new one will be set.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#updateresult","title":"UpdateResult","text":"<pre><code>...\n// Use this method in agent performing action\n// for update existing result by new sc-elements.\naction.UpdateResult(elementAddr1, elementAddr2);\n...\n</code></pre> <p>Note</p> <p>This method updates existing result for action.</p> <p>Note</p> <p><code>FormResult</code> and <code>UpdateResult</code> don't append sc-element twice.</p> <p>Note</p> <p>If you don't form result then empty result for your action will be generated if you finish action.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#action-states","title":"Action states","text":"<p>All actions have state. There are three states of actions provided by this API:</p> <ul> <li>action isn't initiated;</li> <li>action is initiated, but isn't finished (that is, action is being performed);</li> <li>action is finished.</li> </ul> <p>You can initiate, wait or finish actions.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#isinitiated","title":"IsInitiated","text":"<p>Use this method to check that specified action is initiated.</p> <pre><code>...\nbool const isActionInitiated = action.IsInitiated();\n...\n</code></pre> <p></p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#initiateandwait","title":"InitiateAndWait","text":"<p>You can initiate action and wait for it to finish. This method stores maximum customer waiting time of the action to finish in knowledge base.</p> <pre><code>...\n// Provide maximum time of waiting while action will be finished.\naction.InitiateAndWait(100); // milliseconds\n// This argument has default value, that equals to 5000 milliseconds.\n...\n</code></pre> <p></p> <p>Warning</p> <p>If you set maximum customer waiting time for an action that already has maximum customer waiting time, then this method will throw <code>utils::ExceptionInvalidState</code>.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#getmaxcustomerwaitingtimelink","title":"GetMaxCustomerWaitingTimeLink","text":"<p>You can get sc-link with time that customer will wait for action to finish. If action does not have waiting time then empty sc-address will be returned.</p> <pre><code>...\nScAddr const &amp; waitingTimeAddr = action.GetMaxCustomerWaitingTimeLink();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#getmaxcustomerwaitingtime","title":"GetMaxCustomerWaitingTime","text":"<p>You can get time that customer will wait for action to finish. If action does not have waiting time then 0 will be returned.</p> <pre><code>...\nsc_uint32 const waitingTime = action.GetMaxCustomerWaitingTime();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#initiate","title":"Initiate","text":"<p>Or you can initiate and not wait for it to finish.</p> <pre><code>...\naction.Initiate();\n...\n</code></pre> <p></p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#isfinished","title":"IsFinished","text":"<p>Use this method to check that specified action is finished.</p> <pre><code>...\nbool const isActionFinished = action.IsFinished();\n...\n</code></pre> <p></p> <p>All finished actions should be finished with one of the following statuses:</p> <ul> <li>finished successfully;</li> <li>finished unsuccessfully;</li> <li>finished with error.</li> </ul>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#isfinishedsuccessfully","title":"IsFinishedSuccessfully","text":"<p>The set of actions finished successfully includes actions that have been successfully completed from the point of view of subject who performed them, i.e., the goal has been achieved, for example, the solution and result to a problem have been obtained, a construction has been successfully transformed, etc.</p> <pre><code>...\nbool const isActionFinishedSuccessfully = action.IsFinishedSuccessfully();\n...\n</code></pre> <p></p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#finishsuccessfully","title":"FinishSuccessfully","text":"<p>You can successfully finish action that does not have yet been finished.</p> <pre><code>...\nScResult const &amp; result = action.FinishSuccessfully();\n// Use result to return result from agent program.\n...\n</code></pre> <p></p> <p>Warning</p> <p>If you finish action successfully that already has result, then this method will throw <code>utils::ExceptionInvalidState</code>.</p> <p>Warning</p> <p>If you finish action successfully that is finished or not initiated, then this method will throw <code>utils::ExceptionInvalidState</code>.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#isfinishedunsuccessfully","title":"IsFinishedUnsuccessfully","text":"<p>The set of actions finished unsuccessfully includes actions that were not successfully finished from the point of view of subject who performed them for some reason. There are two main reasons why this situation may occur:</p> <ul> <li>corresponding problem is formulated incorrectly;</li> <li>formulation of corresponding problem is correct and understandable to the system, but solution of this problem at the current moment cannot be obtained in terms satisfactory from the point of view of executor.</li> </ul> <pre><code>...\nbool const isActionFinishedUnsuccessfully = action.IsFinishedUnsuccessfully();\n...\n</code></pre> <p></p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#finishunsuccessfully","title":"FinishUnsuccessfully","text":"<p>You can finish unsuccessfully action that not finished yet.</p> <pre><code>...\nScResult const &amp; result = action.FinishUnsuccessfully();\n// Use result to return result from agent program.\n...\n</code></pre> <p></p> <p>Warning</p> <p>If you finish action unsuccessfully that already has result, then this method will throw <code>utils::ExceptionInvalidState</code>.</p> <p>Warning</p> <p>If you finish action unsuccessfully that is finished or not initiated, then this method will throw <code>utils::ExceptionInvalidState</code>.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#isfinishedwitherror","title":"IsFinishedWithError","text":"<p>The set of actions finished with error includes actions whose execution was not successfully finished from the point of view of subject who executed them, because to some error, such as incorrect specification of this action or violation of sc-memory integrity by some subject.</p> <pre><code>...\nbool const isActionFinishedWithError = action.IsFinishedWithError();\n...\n</code></pre> <p></p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#finishwitherror","title":"FinishWithError","text":"<p>You can finish action with error that not finished yet.</p> <pre><code>...\nScResult const &amp; result = action.FinishWithError();\n// Use result to return result from agent program.\n...\n</code></pre> <p></p> <p>Warning</p> <p>If you finish action with error that already has result, then this method will throw <code>utils::ExceptionInvalidState</code>.</p> <p>Warning</p> <p>If you finish action with error that is finished or not initiated, then this method will throw <code>utils::ExceptionInvalidState</code>.</p> <p>All these methods return object of <code>ScResult</code>. You should return it in agent program. You can't call constructor of <code>ScResult</code> to generate new object.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>What is difference between <code>ScAction</code> and <code>ScEvent</code>?</li> <li>What if I want to set some edge as action result and not structure with this edge?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#what-is-difference-between-scaction-and-scevent","title":"What is difference between <code>ScAction</code> and <code>ScEvent</code>?","text":"<p><code>ScAction</code> is a class that represents sc-action. A sc-action is a process performed by some entity to solve specified problem. <code>ScEvent</code> represents a sc-event. A sc-event is a connection between process and its initial and result situation. Actions are generated after the occurrence of some sc-event and actions are performed by agents. Emergence of events in sc-memory leads to generation of new processes.</p>"},{"location":"sc-memory/api/cpp/extended/agents/actions/#what-if-i-want-to-set-some-edge-as-action-result-and-not-structure-with-this-edge","title":"What if I want to set some edge as action result and not structure with this edge?","text":"<p>You're not allowed to do this. Action result should be a atomic formula (statement, situation or structure). Action result describes how action was performed. In the future, result can be non-atomic logical formula.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/","title":"C++ Agent Context API","text":"<p>Note</p> <p>This documentation is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>The C++ Agent context API provides tools for managing the context in which agents operate. This API provides additional sc-memory methods that simplify working with it and provide additional methods to work with sc-events and agents.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#scagentcontext","title":"ScAgentContext","text":"<p>The <code>ScAgentContext</code> class is inherited from <code>ScMemoryContext</code> class and provides functionality for managing agent-specific operations, including event subscriptions, actions, and structures within the sc-machine.</p> <p>Note</p> <p>All API methods are thread-safe.</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_agent_context.hpp&gt;</code> in your hpp source.</p> <p>Warning</p> <p>Objects of <code>ScAgentContext</code> class are movable, but not copyable.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#createelementaryeventsubscription","title":"CreateElementaryEventSubscription","text":"<p>This method can be useful when you want create sc-event subscription, but don't want to use agents for this. <code>CreateElementaryEventSubscription</code> generates sc-event subscription with specified subscription (listen) sc-element and on-event callback. To learn more about sc-event see C++ Events API, to learn more about sc-event subscriptions see C++ Event subscriptions API.</p> <pre><code>...\n// Create or use existing sc-agent context.\nScAgentContext context;\n\n// Create sc-event subscription (listen) sc-element.\nScAddr const &amp; nodeAddr = context.GenerateNode(ScType::ConstNode);\n// Choose sc-event type to subscribe for.\nusing MyEventType = ScEventAfterGenerateOutgoingArc&lt;\n  ScType::ConstPermPosArc&gt;;\n// Create sc-event subscription for generated sc-node (listen sc-element) \n// and provide on-event callback.\nauto eventSubscription \n  = context.CreateElementaryEventSubscription&lt;MyEventType&gt;(\n  nodeAddr,\n  [](MyEventType const &amp; event) -&gt; void\n  {\n    // Handle sc-event.\n  });\n\n// Initiate sc-event. Generate sc-arc from `nodeAddr`.\nScAddr const &amp; otherNodeAddr = context.GenerateNode(ScType:::ConstNode);\ncontext.GenerateConnector(ScType::ConstPermPosArc, nodeAddr, otherNodeAddr);\n// After that sc-arc will be generated, sc-event will occur \n// and specified on-event callback will be called.\n...\n</code></pre> <p>Note</p> <p>You can provide empty on-event callback <code>{}</code> in <code>CreateElementaryEventSubscription</code> and call <code>SetDelegate</code> from object of subscription to set new on-event callback.</p> <p>Note</p> <p>You can call <code>RemoveDelegate</code> from object of subscription to remove existing on-event callback.</p> <p>Warning</p> <p>You should provide valid subscription sc-element. Otherwise, exception will be thrown.</p> <p>If you don't know in advance what sc-event you need to subscribe for, you can use override version of this method.</p> <pre><code>...\n// Create sc-event subscription (listen) sc-element.\nScAddr const &amp; nodeAddr = context.GenerateNode(ScType::ConstNode);\n// Choose sc-event type to subscribe or find it.\nScAddr const &amp; eventClassAddr = GetSomeEventType(); // User-specified method.\n// Create sc-event subscription for generated sc-node (listen sc-element) \n// and provide on-event callback.\nauto eventSubscription = context.CreateElementaryEventSubscription(\n  eventClassAddr,\n  nodeAddr,\n  [](ScElementaryEvent const &amp; event) -&gt; void\n  {\n    // Handle sc-event.\n  });\n\n// Initiate sc-event. Generate sc-arc from `nodeAddr`.\nScAddr const &amp; otherNodeAddr = context.GenerateNode(ScType:::ConstNode);\ncontext.GenerateConnector(ScType::ConstPermPosArc, nodeAddr, otherNodeAddr);\n// After that sc-arc will be generated, sc-event will occur \n// and specified on-event callback will be called.\n...\n</code></pre> <p>Warning</p> <p>A sc-event class must be valid and must belong to <code>sc_event</code> class.</p> <p>Note</p> <p>All sc-event classes provided by sc-machine always belongs to <code>sc_event</code> class.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#createeventwaiter","title":"CreateEventWaiter","text":"<p>You can generate waiter for some sc-event. It is useful when your agent should wait other agent.</p> <pre><code>...\n// Find sc-event subscription (listen) sc-element.\nScAddr const &amp; nodeAddr = context.SearchElementBySystemIdentifier(\"my_node\");\n// Choose sc-event type to subscribe for.\nusing MyEventType = ScEventAfterGenerateOutgoingArc&lt;\n  ScType::ConstPermPosArc&gt;;\n// Create sc-event waiter for generated sc-node (listen sc-element).\nauto eventWaiter = context.CreateEventWaiter&lt;MyEventType&gt;(\n  nodeAddr,\n  []() -&gt; void\n  {\n    // Here you can provide some code, that will be called\n    // when you will call `Wait` method.\n    // For example, it will be code, that initiate some sc-event.\n    // By default, this callback is empty.\n  });\n\n// After creation, call method `Wait` and specify time while you \n// will wait sc-event for specified subscription sc-element\neventWaiter-&gt;Wait(200); // milliseconds\n// By default, this wait time equals to 5000 milliseconds.\n// You will wait until sc-event occurs or until specified time expires.\n\n...\n// Some other code should initiate sc-event (generate sc-arc from `nodeAddr`).\nScAddr const &amp; otherNodeAddr = context.GenerateNode(ScType:::ConstNode);\ncontext.GenerateConnector(ScType::ConstPermPosArc, nodeAddr, otherNodeAddr);\n// After that sc-arc will be generated and waiter will be resolved.\n...\n</code></pre> <p>Warning</p> <p>You should provide valid subscription sc-element. Otherwise, exception will be thrown.</p> <p>Just like for the method of creating sc-event subscription, if you don't know sc-event class in advance, you can generate waiters dynamically.</p> <pre><code>...\n// Find sc-event subscription (listen) sc-element.\nScAddr const &amp; nodeAddr = context.SearchElementBySystemIdentifier(\"my_node\");\n// Choose sc-event type to subscribe or find it.\nScAddr const &amp; eventClassAddr = GetSomeEventType(); // User-specified method.\n// Create sc-event waiter for generated sc-node (listen sc-element)   \n// and provide on-event callback.\nauto eventWaiter = context.CreateEventWaiter(\n  eventClassAddr,\n  nodeAddr);\n...\n</code></pre> <p>Warning</p> <p>A sc-event class must be valid and must belong to <code>sc_event</code> class.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#createconditionwaiter","title":"CreateConditionWaiter","text":"<p>In addition to the waiting time, you can also specify check that will be called when sc-event to which we have subscribed occurs.</p> <pre><code>...\n// Find sc-event subscription (listen) sc-element.\nScAddr const &amp; nodeAddr = context.SearchElementBySystemIdentifier(\"my_node\");\n// Choose sc-event type to subscribe for.\nusing MyEventType = ScEventAfterGenerateOutgoingArc&lt;\n  ScType::ConstPermPosArc&gt;;\n// Create sc-event waiter for generated sc-node (listen sc-element).\nauto eventWaiter = context.CreateConditionWaiter&lt;MyEventType&gt;(\n  nodeAddr,\n  []() -&gt; void\n  {\n    // Here you can also provide some code, that will be called\n    // when you will call `Wait` method.\n    // For example, it will be code, that initiate some sc-event.\n    // By default, this callback is empty.\n  },\n  [](MyEventType const &amp; event) -&gt; bool\n  {\n    // Here you can specify check for sc-event that will occur.\n    // This check should return bool value.\n  });\n\neventWaiter-&gt;Wait(200); // milliseconds\n// You will wait until sc-event occurs or until specified time expires.\n\n...\n// Some other code should initiate sc-event (generate sc-arc from `nodeAddr`).\nScAddr const &amp; otherNodeAddr = context.GenerateNode(ScType:::ConstNode);\ncontext.GenerateConnector(ScType::ConstPermPosArc, nodeAddr, otherNodeAddr);\n// After that sc-arc will be generated and waiter will be resolved.\n...\n</code></pre> <p>Waiters with condition are very useful, when you want to call some agent and wait until this agent will finish work.</p> <pre><code>...\n// Generate action and specify class for it.\nScAddr const &amp; actionAddr = context.GenerateNode(ScType::ConstNode);\ncontext.GenerateConnector(\n    ScType::ConstPermPosArc, MyKeynodes::my_action_class, actionAddr);\n// Create sc-event waiter for generated action (listen sc-element).\n// You should wait while sc-arc in action from `action_finished_successfully`\n// will generated.\nauto eventWaiter = context.CreateConditionWaiter&lt;\n  ScEventAfterGenerateIncomingArc&lt;ScType::ConstPermPosArc&gt;&gt;(\n  actionAddr,\n  [&amp;]() -&gt; void\n  {\n    // Initiate sc-event here.\n    context.GenerateConnector(\n        ScType::ConstPermPosArc, \n        ScKeynodes::action_initiated, \n        actionAddr);\n  },\n  [](ScEventAfterGenerateIncomingArc&lt;\n        ScType::ConstPermPosArc&gt; const &amp; event) -&gt; bool\n  {\n    // Check sc-event here.\n    return event.GetOtherElement()\n      == ScKeynodes::action_finished_successfully;\n  });\n\neventWaiter-&gt;Wait(200); // milliseconds\n// You will wait until sc-event occurs or until specified time expires.\n...\n</code></pre> <p>You can also generate waiters with conditions dynamically, providing sc-event class from knowledge base.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#subscribeagent","title":"SubscribeAgent","text":"<p><code>ScModule</code> provides API to subscribe agents to sc-events statically (see C++ Modules API). <code>ScAgentContext</code> also provides methods to subscribe agents to sc-events. It can be useful if you want to subscribe agents to sc-events dynamically.</p> <p>To subscribe agent class to sc-event use <code>SubscribeAgent</code>.</p> <pre><code>...\n// For agent classes inherited from `ScAgent` class write so.\ncontext.SubscribeAgent&lt;MyAgent&gt;(mySubscriptionElementAddr);\n\n// For agent classes inherited from `ScActionInitiatedAgent` class write so.\ncontext.SubscribeAgent&lt;MyActionAgent&gt;();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#unsubscribeagent","title":"UnsubscribeAgent","text":"<p>To unsubscribe agent class to sc-event use <code>UnsubscribeAgent</code>.</p> <pre><code>...\n// For agent classes inherited from `ScAgent` class write so.\ncontext.UnsubscribeAgent&lt;MyAgent&gt;(mySubscriptionElementAddr);\n\n// For agent classes inherited from `ScActionInitiatedAgent` class write so.\ncontext.UnsubscribeAgent&lt;MyActionAgent&gt;();\n...\n</code></pre> <p>Note</p> <p>If you subscribed some agent to sc-event, you should unsubscribe it from this sc-event after. Otherwise, when you will stop the sc-machine, warnings about it will be gotten.</p> <p>Warning</p> <p>You must provide valid subscription sc-elements.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#subscribespecifiedagent","title":"SubscribeSpecifiedAgent","text":"<p>Also, you can subscribe agent according to specification provided in knowledge base. Instead of subscription sc-elements, you should provide agent implementations. <code>SubscribeSpecifiedAgent</code> method finds specification of abstract agent for specified agent implementation and uses this specification to subscribe specified agent to sc-event.</p> <pre><code>...\ncontext.SubscribeSpecifiedAgent&lt;MyAgent&gt;(agentImplementationAddr);\n...\n</code></pre> <p>Note</p> <p>If some specification elements will be not found, then exceptions will be thrown. Sure, that specification is full, and that it is loaded to knowledge base. This method doesn't load specification to knowledge base for specified agent class.</p> <p>You can subscribe the same agents to sc-events according to several agent implementations. These agent implementations can be included to the same abstract agent or to different abstract agents.</p> <pre><code>...\ncontext.SubscribeSpecifiedAgent&lt;MyAgent&gt;(agentImplementationAddr1);\ncontext.SubscribeSpecifiedAgent&lt;MyAgent&gt;(agentImplementationAddr2);\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#unsubscribespecifiedagent","title":"UnsubscribeSpecifiedAgent","text":"<p>This method finds specification of abstract agent for specified agent implementation and uses this specification to unsubscribe specified agent from sc-event.</p> <pre><code>...\n// If your agent was subscribed to sc-event according to agent \n// implementation, you should unsubscribe from sc-event according \n// to this agent implementation. \ncontext.UnsubscribeSpecifiedAgent&lt;MyAgent&gt;(agentImplementationAddr);\n...\n</code></pre> <pre><code>...\n// If your agent was subscribed to sc-events according to several \n// agent implementations, you should unsubscribe from sc-events \n// according to these agent implementations.\ncontext.UnsubscribeSpecifiedAgent&lt;MyAgent&gt;(agentImplementationAddr1);\ncontext.UnsubscribeSpecifiedAgent&lt;MyAgent&gt;(agentImplementationAddr2);\n...\n</code></pre> <p>Note</p> <p>If some specification elements will be not found, then exceptions will be thrown. Sure, that specification is full, and that it is loaded to knowledge base. This method doesn't load specification to knowledge base for specified agent class.</p> <p>Warning</p> <p>You must provide valid agent implementations.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#generateaction","title":"GenerateAction","text":"<p>All agents perform actions. We provide API to work with them. Use <code>GenerateAction</code> to generate object of <code>ScAction</code> class. To learn more about actions see C++ Action API.</p> <pre><code>// Find action class and generate action.\n...\nScAction action = context.GenerateAction(actionClassAddr);\n...\n</code></pre> <p>Note</p> <p>You should provide action class that is include to the one of types: <code>receptor_action</code>, <code>effector_action</code>, <code>behavioral_action</code> or <code>information_action</code>.</p> <p>Note</p> <p>Action class sc-address must be valid.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#converttoaction","title":"ConvertToAction","text":"<pre><code>// Or find action and convert it to object of `ScAction` class.\n...\nScAction action = context.ConvertToAction(actionAddr);\n...\n</code></pre> <p>Note</p> <p>Action sc-address must be valid.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#generateset","title":"GenerateSet","text":"<p>We provide API to easy work with sets and structures in knowledge base.</p> <pre><code>// Generate new set.\n...\nScSet set = context.GenerateSet();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#converttoset","title":"ConvertToSet","text":"<pre><code>// Or find set and convert it to object of `ScSet` class.\n...\nScSet set = context.ConvertToSet(setAddr);\n...\n</code></pre> <p>Note</p> <p>Set sc-address must be valid.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#generatestructure","title":"GenerateStructure","text":"<pre><code>// Generate new structure.\n...\nScStructure structure = context.GenerateStructure();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#converttostructure","title":"ConvertToStructure","text":"<pre><code>// Or find structure and convert it to object of `ScStructure` class.\n...\nScStructure structure = context.ConvertToStructure(structureAddr);\n...\n</code></pre> <p>Note</p> <p>Structure sc-address must be valid.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>How do I add my method to a <code>ScAgentContext</code>?</li> <li>How can I wait for an event indefinitely?</li> <li>What if I need to initiate agent on events from different nodes?</li> <li>When ScMultiset will be implemented?</li> <li>What do I need to initiate agent on <code>ScEventGeneratingIncomingArc</code> and <code>ScEventGeneratingOutgoingArc</code> for one node?</li> <li>What's the difference between <code>ScSet</code> and <code>ScStructure</code>?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#how-do-i-add-my-method-to-a-scagentcontext","title":"How do I add my method to a <code>ScAgentContext</code>?","text":"<p>You can generate a class that will inherit <code>ScAgentContext</code> class. If you want to use it in your agent, do this:</p> <pre><code>class MyContext : public ScAgentContext\n{\npublic:\n  // New methods.\n};\n\nclass MyAgent : public ScAgent&lt;MyEventType, MyContext&gt;\n{\npublic:\n  // Agent methods.\n};\n</code></pre> <p>You will be able to use context of class, which you specify, in the agent's methods.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#how-can-i-wait-for-an-event-indefinitely","title":"How can I wait for an event indefinitely?","text":"<p>By default, you can wait up to 5 seconds for an event to appear. You can wait for another time convenient for you. But we recommend waiting as long as you need, no longer. You don't need to generate waiters for several minutes or hours when the agent performs much faster, in milliseconds.</p> <p>You can't wait indefinitely for an event, there is always a maximum waiting time after which you stop waiting. But, in order to wait for some event indefinitely, you can implement and subscribe an agent for that event. It will be triggered when event to be occurred. See C++ Agents API to learn more about agents.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#what-if-i-need-to-initiate-agent-on-events-from-different-nodes","title":"What if I need to initiate agent on events from different nodes?","text":"<p>You can subscribe an agent to many different sc-elements, but for the same type of sc-event. You can use <code>SubscribeAgent</code> and <code>UnsubscribeAgent</code> to do this.</p> <pre><code>...\ncontext.SubscribeAgent&lt;MyAgent&gt;(nodeAddr1, nodeAddr2);\n// Here, you can provide array of subscriptions elements only \n// for agent classes inherited from `ScAgent` class.\n</code></pre> <p>But remember, that you have to unsubscribe the agent while the system is shutting down.</p> <pre><code>...\ncontext.UnsubscribeAgent&lt;MyAgent&gt;(nodeAddr1, nodeAddr2);\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#when-scmultiset-will-be-implemented","title":"When ScMultiset will be implemented?","text":"<p>Now, <code>ScSet</code> and <code>ScStructure</code> are implemented only. <code>ScSet</code> stores unique sc-elements. <code>ScMultiset</code> will be implemented soon.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#what-do-i-need-to-initiate-agent-on-sceventgeneratingincomingarc-and-sceventgeneratingoutgoingarc-for-one-node","title":"What do I need to initiate agent on <code>ScEventGeneratingIncomingArc</code> and <code>ScEventGeneratingOutgoingArc</code> for one node?","text":"<p>You can subscribe an agent to sc-event of generating sc-connector -- <code>ScEventGeneratingConnector</code>. Then the agent will be triggered on incoming and outgoing sc-arcs.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agent_context/#whats-the-difference-between-scset-and-scstructure","title":"What's the difference between <code>ScSet</code> and <code>ScStructure</code>?","text":"<p><code>ScSet</code> is a class that represents sc-set. It is an entity that links one or more entities into a whole. <code>ScStructure</code> is a class represents sc-structure. It is a set of sc-elements, which includes sc-connections or sc-structures linking these sc-elements. Removal of one of sc-elements of the sc-structure may lead to violation of the integrity of this sc-structure. <code>ScSet</code> and <code>ScStructure</code>  do not differ functionally. <code>ScStructure</code> is a stricter representation of sc-set.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/","title":"C++ Agents API","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>This section contains detailed documentation on the core functionalities of the C++ Agents API, which encompasses agent creation and management. It covers how to specify and instantiate agents and integrate them into systems.</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_agent.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#quick-start","title":"Quick start","text":"<p>Go to our Simple guide on how to quickly develop an agent in C++ from scratch.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#what-is-the-agent-driven-model","title":"What is the agent-driven model?","text":"<p>The sc-machine implements the agent-driven model to manage processing knowledge. In the agent-based model, agents exchange messages only through shared memory, adding a new agent or eliminating one or more existing agents does not result in changes to other agents, agent initiation is decentralized and most often independent of each other. </p> <p>All agents within the OSTIS Technology are divided into two classes: platform-independent, i.e. implemented only by means of SC-code, and platform-dependent, implemented by means of sc-machine API. Platform-independent agents can be implemented with help of SCP language which is interpreted by scp-machine. The sc-machine presents a powerful, but simple API for developing and maintaining platform-dependent agents in C++.</p> <p>All agents react to the occurrence of events in sc-memory (sc-events). That is, an agent is called implicitly when an sc-event occurs, for which type this agent is already subscribed. Knowledge about which sc-event will cause this agent to be called (awakening of this agent) is called primary initiation condition. Upon awakening, the agent checks for the presence of its full initiation condition. If the full initiation condition is successfully checked, the agent initiates an action of some class and starts performing it with a agent program (see C++ Actions API to learn more about actions). After executing its program, the agent can check if there is a result.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#what-does-agent-specification-represent","title":"What does agent specification represent?","text":"<p>All knowledge about an agent: primary initiation condition, class of actions it can perform, initiation condition, and result condition, are part of agent's specification. This specification can be represented either in a knowledge base, using SC-code, or programably, using sc-machine API.</p> <p>Let's describe specification for abstract sc-agent of counting power of specified set in SCs-code (SCg-code). An abstract sc-agent is a class of functionally equivalent agents, different instances of which can be implemented in different ways. Each abstract sc-agent has a specification corresponding to it.</p> <pre><code>// Abstract sc-agent\nagent_calculate_set_power\n&lt;- abstract_sc_agent;\n=&gt; nrel_primary_initiation_condition: \n    // Class of sc-event and listen (subscription) sc-element\n    (sc_event_after_generate_outgoing_arc =&gt; action_initiated); \n=&gt; nrel_sc_agent_action_class:\n    // Class of actions to be performed by agent\n    action_calculate_set_power; \n=&gt; nrel_initiation_condition_and_result: \n    (..agent_calculate_set_power_initiation_condition \n        =&gt; ..agent_calculate_set_power_result_condition);\n&lt;= nrel_sc_agent_key_sc_elements:\n// Set of key sc-elements used by this agent\n{\n    action_initiated;\n    action_calculate_set_power;\n    concept_set;\n    nrel_set_power\n};\n=&gt; nrel_inclusion: \n    // Instance of abstract sc-agent; concrete implementation of agent in C++\n    agent_calculate_set_power_implementation \n    (*\n        &lt;- platform_dependent_abstract_sc_agent;;\n        // Set of links with paths to sources of agent programs\n        &lt;= nrel_sc_agent_program: \n        {\n            [github.com/path/to/agent/sources] \n            (* =&gt; nrel_format: format_github_source_link;; *)\n        };; \n    *);;\n\n// Full initiation condition of agent\n..agent_calculate_set_power_initiation_condition\n= [*\n    action_calculate_set_power _-&gt; .._action;;\n    action_initiated _-&gt; .._action;;\n    .._action _-&gt; rrel_1:: .._set;;\n    concept_set _-&gt; .._set;;\n*];; \n// Agent should check by this template that initiated action is instance of \n// class `action_calculate_set_power` and that it has argument.\n\n// Full result condition of agent\n..agent_calculate_set_power_result_condition\n= [*\n    .._set _=&gt; nrel_set_power:: _[];;\n*];;\n// Agent should check by this template that action result contains \n// sc-construction generated after performing action.\n</code></pre> <p></p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#what-are-ways-of-providing-the-agents-specification","title":"What are ways of providing the agent's specification?","text":"<p>The sc-machine API provides two types of functionalities to implement an agent in C++:</p> <ul> <li>when the agent's specification is represented in the knowledge base and used by the agent;</li> <li>when the agent's specification is represented in C++ code and also used by the agent.</li> </ul> <p>In both cases, the agent's specification can be static, dynamic, or semi-dynamic.</p> <ol> <li>Static agent specification is a specification provided externally in the agent's class (via overriding public getters). This specification isn't saved in the knowledge base because changes in the knowledge base can't automatically alter user-specified code. To provide this type of agent specification, you can use overriding public getters in your agent's class (see documentation below).</li> <li>Dynamic agent specification is a specification provided in the knowledge base or initially in the code but automatically saved into the knowledge base. After that, the first agent changes the specification of the second agent, and the second agent uses the changed specification. To implement this type of specification, use the API of <code>ScModule</code> class and the API of <code>ScAgentBuilder</code> class (see C++ Modules).</li> <li>Semi-dynamic agent specification can be obtained when the specification is provided in the knowledge base or initially in the code and appended externally (via overriding public getters).</li> </ol> <p>Static agent specification can be useful if you are implementing an agent in C++ for the first time or if you want to minimize the number of searches in the knowledge base. Dynamic agent specification provides the opportunity to analyze and change this specification by other agents. Semi-dynamic specification can be useful if you want to change some parts of this specification but still want the agent's calls to be quick.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#static-agent-specification","title":"Static agent specification","text":"<p>Here, the API for implementing an agent with a static specification will be discussed. This is the easiest implementation variant to understand for you. To learn about dynamic agent specification, see C++ Modules API.</p> <p>There are two main classes that you can use to implement an agent: <code>ScAgent</code> and <code>ScActionInitiatedAgent</code>.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#scagent","title":"ScAgent","text":"<p>There is a base class for agents in C++. This class provides implemented methods to retrieve elements of the agent's specification from the knowledge base. All these methods can be overridden in your agent class.</p> <p>You should distinguish between an abstract sc-agent as some class of functional equivalent sc-agents described in the knowledge base and <code>ScAgent</code> as a C++ class that implements an API to work with abstract sc-agents in the knowledge base.</p> <p>This class can be used for all types of platform-dependent agents. Agents of this class react for events in the knowledge base, check the full initiation condition. If the check is successful, generate, initiate and execute the action. After that, they check full result condition. The example using this class is represented below.</p> <pre><code>// File my_agent.hpp\n#pragma once\n\n#include &lt;sc-memory/sc_agent.hpp&gt;\n\n// Inherit your agent class from `ScAgent` class and specify template argument \n// as sc-event class. Here `ScEventAfterGenerateIncomingArc&lt;\n// ScType::ConstPermPosArc&gt;` is type of event to which the given \n// agent reacts.\nclass MyAgent : public ScAgent&lt;\n  ScEventAfterGenerateIncomingArc&lt;ScType::ConstPermPosArc&gt;&gt;\n{\npublic:\n  // Here you should specify class of actions which the given agent performs. \n  // Here `GetActionClass` overrides `GetActionClass` \n  // in `ScAgent` class. This overriding is required.\n  ScAddr GetActionClass() const override;\n  // Here you should implement program of the given agent. \n  // This overriding is required.\n  ScResult DoProgram(\n    ScEventAfterGenerateIncomingArc&lt;\n      ScType::ConstPermPosArc&gt; const &amp; event, \n    ScAction &amp; action) override;\n\n  // Other user-defined methods.\n};\n</code></pre> <p>You can't override <code>DoProgram</code> without sc-event argument. There can be override one of these methods. </p> <pre><code>// File my_agent.hpp\n#pragma once\n\n#include &lt;sc-memory/sc_agent.hpp&gt;\n\nclass MyAgent : public ScAgent&lt;\n  ScEventAfterGenerateIncomingArc&lt;ScType::ConstPermPosArc&gt;&gt;\n{\npublic:\n  ScAddr GetActionClass() const override;\n  ScResult DoProgram(ScAction &amp; action) override;\n\n  // Other user-defined methods.\n};\n</code></pre> <p>See C++ Events API and C++ Event subscriptions API to learn how to use and handle sc-events.</p> <p>Note</p> <p>Define action class as keynode in agent class or keynodes class.</p> <p>Warning</p> <p>You should override methods <code>GetActionClass</code> and <code>DoProgram</code>. But if you provide specification of your agent in knowledge base, then you don't need to override <code>GetActionClass</code>. See C++ Modules API to learn how to implement agents with specification in the knowledge base.</p> <p>You can specify any existing event types as a template argument to the <code>ScAgent</code> class. For example, you can generate agent that will be triggered to sc-event of removing sc-element.</p> <pre><code>// File my_agent.hpp\n#pragma once\n\n#include &lt;sc-memory/sc_agent.hpp&gt;\n\nclass MyAgent : public ScAgent&lt;ScEventBeforeEraseElement&gt;\n{\npublic:\n  ScAddr GetActionClass() const override;\n  ScResult DoProgram(\n    ScEventBeforeEraseElement const &amp; event, ScAction &amp; action) override;\n\n  // Other user-defined methods.\n};\n</code></pre> <p>If you want to change specification of this agent in knowledge base, then write like this:</p> <pre><code>// File my_agent.hpp\n#pragma once\n\n#include &lt;sc-memory/sc_agent.hpp&gt;\n\nclass MyAgent : public ScElementaryEventAgent\n{\npublic:\n  ScAddr GetActionClass() const override;\n  ScResult DoProgram(\n    ScElementaryEvent const &amp; event, ScAction &amp; action) override;\n\n  // Other user-defined methods.\n};\n</code></pre> <p>This implementation allows to provide any sc-event type to <code>DoProgram</code>.</p> <p>Note</p> <p><code>ScElementaryEventAgent</code> is alias for <code>ScAgent&lt;ScElementaryEvent&gt;</code>.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#scactioninitiatedagent","title":"ScActionInitiatedAgent","text":"<p>In multi-agent systems most of the agents are implemented to execute actions initiated by other agents. While <code>ScAgent</code> is useful to generate broad event handling logic, using it to handle action initiations requires some boilerplate. We've implemented another agent class to make it easier for our users to implement action-executing agents. Implementing these agents requires passing action class node rather than checking initiation condition manually.</p> <p>This class can be only used for agents that should be triggered by generating an outgoing sc-arc from <code>action_initiated</code> class node.</p> <pre><code>// File my_agent.hpp\n#pragma once\n\n#include &lt;sc-memory/sc_agent.hpp&gt;\n\n// Inherit your agent class from `ScActionInitiatedAgent` class.\nclass MyAgent : public ScActionInitiatedAgent\n{\npublic:\n  // Here you should specify class of actions which the given agent performs. \n  // This overriding is required.\n  ScAddr GetActionClass() const override;\n  // Here you should implement program of the given agent. \n  // This overriding is required.\n  ScResult DoProgram(\n    ScActionInitiatedEvent const &amp; event, ScAction &amp; action) override;\n  // Here `ScActionInitiatedEvent` is type of event to which \n  // the given agent reacts.\n\n  // Other user-defined methods.\n};\n</code></pre> <p>Note</p> <p><code>ScActionInitiatedAgent</code> has default <code>GetInitiationConditionTemplate</code> that returns template that can be used to check that initiated action is action with class of specified agent.</p> <p>Note</p> <p><code>ScActionInitiatedEvent</code> is alias for <code>ScEventAfterGenerateOutgoingArc&lt;ScType::ConstPermPosArc&gt;</code> with subscription sc-element <code>action_initiated</code>.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#required-methods","title":"Required methods","text":""},{"location":"sc-memory/api/cpp/extended/agents/agents/#getactionclass","title":"GetActionClass","text":"<p>It gets action class that the agent of specified class performs. If the abstract sc-agent for this agent class does not have an action class, then method will throw <code>utils::ExceptionItemNotFound</code>.</p> <pre><code>// File my_agent.cpp\n#include \"my_agent.hpp\"\n\n#include \"keynodes/my_keynodes.hpp\"\n\nScAddr MyAgent::GetActionClass() const\n{\n  // You must specify valid sc-address of action class and you should \n  // provide action class that is include to the one of types: \n  // `receptor_action`, `effector_action`, `behavioral_action` or \n  // `information_action`.\n  // In other case, the given sc-agent can\u2019t be subscribed to sc-event.\n  return MyKeynodes::my_action;\n}\n</code></pre> <p>See C++ Keynodes API and learn how to define keynodes and use them for your agent.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#doprogram","title":"DoProgram","text":"<p>This method is executed when agent checked initiation condition successfully. Using program, the agent processes an input construction and generates an output construction. Each agent performs action with the help of its program.</p> <pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  // Class `ScAction` encapsulates information about sc-action. The provided \n  // action is action that the given agent performs right now. \n  // It belongs to `MyKeynodes::my_action` class.\n  // If your agent inherits `ScActionInitiatedAgent` class then this agent\n  // performs action initiated externally. If your agent inherits `ScAgent`\n  // then this agent generates action, initiates and performs new action, not\n  // provided externally.\n  // Actions are copyable and movable. `ScAction` is inherited from `ScAddr`.\n\n  // `ScActionInitiatedEvent` class is event type on which the given agent \n  // is triggered. It is encapsulate information about sc-event. \n  // The provided event is event on which the agent is triggered right now. \n  // It has methods to get information about initiated sc-event: `GetUser`, \n  // `GetArc`, `GetSubscriptionElement`, `GetArcSourceElement`.\n\n  // Implement logic of your agent...\n\n  // You must specify action state in all ends of your agent program. \n  // `FinishSuccessfully` sets action as `action_finished_successfully`.\n  // You can\u2019t generate object of `ScResult` via constructor, because it is \n  // private.\n  return action.FinishSuccessfully(); \n}\n</code></pre> <p><code>ScAgent</code> class has field <code>m_context</code>. It is an object of <code>ScAgentContext</code> class. You can use to complete operations in sc-memory. See C++ Agent context API to learn more about accessible methods.</p> <p><code>ScAgent</code> class has field <code>m_logger</code>. It is an object of <code>ScLogger</code> class. Use it to logging your code. See C++ Core API to learn how to use it.</p> <p>Warning</p> <p>If you don't catch sc-exceptions in <code>DoProgram</code> then sc-machine will catch them and will finish action with error and will warn you about it.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#handling-action-arguments","title":"Handling action arguments","text":"<p>There are many ways of methods that get action arguments. Use them, they can help you to simplify code.</p> <pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  auto [argAddr1, argAddr] = action.GetArguments&lt;2&gt;();\n\n  // Some logic...\n\n  return action.FinishSuccessfully(); \n}\n</code></pre> <pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  ScAddr const &amp; argAddr1 = action.GetArgument(ScKeynodes::rrel_1);\n  // Parameter has ScAddr type.\n\n  // Some logic...\n\n  return action.FinishSuccessfully();\n}\n</code></pre> <pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  ScAddr const &amp; argAddr1 = action.GetArgument(1); // size_t\n  // It would be the same if we pass ScKeynodes::rrel_1 instead of 1.\n\n  // Some logic...\n\n  return action.FinishSuccessfully();\n}\n</code></pre> <pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  ScAddr const &amp; argAddr1 \n    = action.GetArgument(1, MyKeynodes::default_text_link);\n  // If action hasn\u2019t the first argument, then MyKeynodes::default_text_link \n  // will return.\n\n  // Some logic...\n\n  return action.FinishSuccessfully();\n}\n</code></pre> <pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  // You can use object of ScAction as object of ScAddr.\n  ScIterator3Ptr const it3 = m_context.CreateIterator3(action, ..., ...);\n\n  // Some logic...\n\n  return action.FinishSuccessfully();\n}\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#handling-action-result","title":"Handling action result","text":"<pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  // Some logic...\n\n  action.FormResult(foundAddr1, generatedAddr1, ...); \n  // Or you can use `UpdateResult` method.\n  return action.FinishSuccessfully();\n}\n</code></pre> <p>To learn more about methods of <code>ScAction</code> class, see C++ Actions API.</p> <pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  // Some logic...\n\n  action.SetResult(structureAddr);\n  return action.FinishSuccessfully();\n}\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#handling-action-finish-state","title":"Handling action finish state","text":"<pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  // Some logic...\n\n  if (/* case 1 */)\n    return action.FinishSuccessfully();\n  else if (/* case 2 */)\n    return action.FinishUnsuccessfully();\n  else\n    return action.FinishWithError();\n}\n</code></pre> <pre><code>ScResult MyAgent::DoProgram(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  action.IsInitiated(); // result: true\n  action.IsFinished(); // result: false\n  action.IsFinishedSuccessfully(); // result: false\n\n  // Some logic...\n\n  return action.FinishSuccessfully();\n}\n</code></pre> <p>Warning</p> <p>The API of <code>ScAction</code> provides other methods. Don't use <code>GetResult</code> for initiated but not finished action and <code>Initiate</code> for initiated or finished action.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#not-required-methods","title":"Not required methods","text":""},{"location":"sc-memory/api/cpp/extended/agents/agents/#getabstractagent","title":"GetAbstractAgent","text":"<p>It searches abstract agent for agent of specified class. If the agent implementation for this agent class is not included in any abstract sc-agent, then <code>GetAbstractAgent</code> will throw <code>utils::ExceptionItemNotFound</code>.</p> <p>You can override this method in your agent class.</p> <pre><code>ScAddr MyAgent::GetAbstractAgent() const\n{\n  // You must specify valid sc-address of abstract agent. \n  // In other case, the given sc-agent can\u2019t be subscribed to sc-event.\n  return MyKeynodes::my_abstract_agent;\n}\n</code></pre> <p>Warning</p> <p>Remember, if you override only this method and required methods, then other getters will return elements of specification for specified abstract agent. All not override getters call <code>GetAbstractAgent</code>. </p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#geteventclass","title":"GetEventClass","text":"<p>It searches the sc-event class to which the agent class is subscribed. It will throw <code>utils::ExceptionItemNotFound</code> if the abstract sc-agent for this agent class does not have primary initiation condition.</p> <p>You can override this method in your agent class.</p> <pre><code>ScAddr MyAgent::GetEventClass() const\n{\n  // You must specify valid sc-address of event class. \n  // In other case, the given sc-agent can\u2019t be subscribed to sc-event.\n  return ScKeynodes::sc_event_after_generate_outgoing_arc;\n}\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#geteventsubscriptionelement","title":"GetEventSubscriptionElement","text":"<p>This method searches sc-event subscription sc-element for which sc-event initiates. It will throw <code>utils::ExceptionItemNotFound</code> if the abstract sc-agent for this agent class does not have primary initiation condition.</p> <p>You can override this method in your agent class.</p> <pre><code>ScAddr MyAgent::GetEventSubscriptionElement() const\n{\n  // You must specify valid sc-address of sc-event subscription sc-element. \n  // In other case, the given sc-agent can\u2019t be subscribed to sc-event.\n  return ScKeynodes::action_initiated;\n}\n</code></pre> <p>Warning</p> <p>Don't override <code>GetEventClass</code> and <code>GetEventSubscriptionElement</code> for agent with statically specified sc-event type. Your code can't be compiled. Override them, if your agent class inherit <code>ScAgent&lt;ScElementaryEvent&gt;</code> (<code>ScElementaryEventAgent</code>).</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#getinitiationcondition","title":"GetInitiationCondition","text":"<p>It gets initiation condition for agent of this class. Initiation condition is a sc-template (sc-structure) that is used by the agent to check necessary connections between sc-elements of sc-event triple and sc-elements in the knowledge base before the agent performs an action. This method will throw <code>utils::ExceptionItemNotFound</code> if the abstract sc-agent for this agent class does not have initiation condition.</p> <p>You can override this method in your agent class.</p> <pre><code>ScAddr MyAgent::GetInitiationCondition() const\n{\n  // You must specify valid sc-address or sc-template of initiation condition. \n  // In other case, the given sc-agent can\u2019t be called.\n  return ScKeynodes::my_initiation_condition;\n}\n</code></pre> <pre><code>// sc_keynodes.hpp\n...\n// Here you should specify template to check initiation condition before \n// starting agent.\nstatic inline ScTemplateKeynode const &amp; my_initiation_condition\n  = ScTemplateKeynode(my_initiation_condition)\n    // You must specify valid sc-address of initiation condition. Otherwise, \n    // the given sc-agent can\u2019t be called. For sc-event of generating (erasing) \n    // sc-connector (sc-arc or sc-edge), you must specify in template of \n    // initiation condition a triple in place of which agent have to substitute \n    // sc-elements involved in initiated event. These elements will be the \n    // sc-connector (sc-arc or sc-edge) and its incident sc-elements. \n    // For sc-event of changing sc-link content (or erasing sc-element), you \n    // should use sc-link (sc-element) in template of initiation condition \n    // explicitly. Otherwise your agent will not be called because its \n    // initiation condition is fulfilled for the action of another agent.\n    .Triple(\n      ScKeynodes::action_initiated,\n      ScType::VarPermPosArc,\n      ScType::VarNode &gt;&gt; \"_action\"\n    )\n    // After you should specify triples that only apply to your agent.\n    .Triple(\n      MyKeynodes::my_action,\n      ScType::VarPermPosArc,\n      \"_action\"\n    )\n    .Quintuple(\n      \"_action\",\n      ScType::VarPermPosArc,\n      ScType::VarNode,\n      ScType::VarPermPosArc,\n      ScKeynodes::rrel_1\n    );\n...\n</code></pre> <p>Warning</p> <p>Agent must have initiation condition template with only one triple that can be used to substitute sc-elements involved in initiated event, otherwise agent will not started performing sc-action.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#getinitiationconditiontemplate","title":"GetInitiationConditionTemplate","text":"<p>You can specify the initiation condition template in code rather than in the knowledge base. It can be useful if you want to quickly check agent initiation condition without loading the template into the knowledge base.</p> <pre><code>ScTemplate MyAgent::GetInitiationConditionTemplate(\n  ScActionInitiatedEvent const &amp; event) const\n{\n  // In this method, you shouldn't specify triple for sc-event sc-elements.\n  // You should specify triples that only apply to your agent.\n  initiationCondition.Triple(\n    MyKeynodes::my_action,\n    ScType::VarPermPosArc,\n    event.GetOtherElement() // It returns sc-action.\n  );\n  return initiationCondition;\n}\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#checkinitiationcondition","title":"CheckInitiationCondition","text":"<p>For speed, you can implement the agent initiation condition in the form of checks on iterators.</p> <pre><code>bool MyAgent::CheckInitiationCondition(ScActionInitiatedEvent const &amp; event)\n{\n // ScActionInitiatedEvent is event type on which the given agent triggered. \n // It is encapsulate information about sc-event. The provided event is event \n // on which the agent is triggered right now. It has methods to get \n // information about initiated sc-event: GetUser, GetArc, \n // GetSubscriptionElement, GetArcSourceElement, GetArcTargetElement.\n // All events are not copyable and movable.\n return m_context.CheckConnector(\n   ScType::ConstPermPosArc, \n   MyKeynodes::my_action, \n   event.GetArcTargetElement());\n}\n// You can use all opportunities of sc-memory API to check initiation \n// condition of your agent.\n</code></pre> <p>Note</p> <p>Each of these methods will be called before <code>DoProgram</code> call.</p> <p>Warning</p> <p>You can specify only one of methods: <code>GetInitiationCondition</code>, <code>GetInitiationConditionTemplate</code> and <code>CheckInitiationCondition</code>. Otherwise, your code can't be compiled.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#getresultcondition","title":"GetResultCondition","text":"<p>It gets result condition for agent of this class. Result condition is a sc-template (sc-structure) that is used by the agent to check necessary connections between sc-elements of sc-event triple and sc-elements in the knowledge base after the agent has performed an action. This method will throw <code>utils::ExceptionItemNotFound</code> if the abstract sc-agent for this agent class does not have result condition.</p> <p>You can override this method in your agent class.</p> <pre><code>ScAddr MyAgent::GetResultCondition() const\n{\n  // Here you should specify template to check action result content.\n  // You must specify valid sc-address or sc-template of result condition. \n  // In other case, the given sc-agent can\u2019t be finished successfully.\n  return ScKeynodes::my_result_condition;\n}\n</code></pre> <pre><code>// sc_keynodes.hpp\n...\n// Here you should specify template to check action result content.\nstatic inline ScTemplateKeynode const &amp; my_result_condition\n  = ScTemplateKeynode(my_result_condition)\n    .Triple(\n      MyKeynodes::my_class,\n      ScType::VarPermPosArc,\n      ScType::VarNode\n    );\n    // This template is used to check that agent generated sc-arc\n    // between `MyKeynodes::my_class` and some sc-node.\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#getresultconditiontemplate","title":"GetResultConditionTemplate","text":"<p>You can specify the result condition template in code rather than in the knowledge base.</p> <pre><code>ScTemplate MyAgent::GetResultConditionTemplate(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action) const\n{\n  // Here you should specify template to check action result content.\n  ScTemplate resultCondition;\n  resultCondition.Triple(\n    MyKeynodes::my_class,\n    ScType::VarPermPosArc,\n    ScType::VarNode\n  );\n  return resultCondition;\n}\n</code></pre> <p>Note</p> <p><code>GetResultCondition</code> and <code>GetResultConditionTemplate</code> are used to search sc-constructions in action result only.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#checkresultcondition","title":"CheckResultCondition","text":"<p>For speed, you can implement the agent result condition in the form of checks on iterators.</p> <pre><code>bool MyAgent::CheckResult(\n  ScActionInitiatedEvent const &amp; event, ScAction &amp; action)\n{\n  ScStructure const &amp; actionResult = action.GetResult();\n  ScIterator3Ptr const it3 = m_context.CreateIterator3(\n    MyKeynodes::my_class,\n    ScType::ConstPermPosArc,\n    ScType::ConstNode,\n    ScType::ConstPermPosArc,\n    actionResult\n  );\n  return it3-&gt;Next() \n    &amp;&amp; actionResult.Has(MyKeynodes::my_class) \n    &amp;&amp; actionResult.Has(it3-&gt;Get(2))\n    &amp;&amp; !it3-&gt;Next() // Check that action result has no more triples.\n    &amp;&amp; m_context.GetOutputArcsCount(actionResult) == 3;\n}\n</code></pre> <p>Note</p> <p>Each of these methods will be called after <code>DoProgram</code> call.</p> <p>Warning</p> <p>You can specify only one of methods: <code>GetResultCondition</code>, <code>GetResultConditionTemplate</code> and <code>CheckResultCondition</code>. Otherwise, your code can't be compiled.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>Is it possible to subscribe an agent for more than one sc-event?</li> <li>What happens if I don't specify full initiation condition in agent class?</li> <li>Can there be an agent without primary initiation condition?</li> <li>Is it possible to generate object of <code>ScAgent</code> class and call any of class methods?</li> <li>Is agent's call protocol preserved?</li> <li>What is advisable to do as an agent and what is not?</li> <li>What's the purpose of result condition? What is it used for?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#is-it-possible-to-subscribe-an-agent-for-more-than-one-sc-event","title":"Is it possible to subscribe an agent for more than one sc-event?","text":"<p>Future versions of the sc-machine will implement complex sc-events. Complex sc-events will be a set of elementary events. It will be possible to subscribe agents to such sc-events.</p> <p>If it is a question of whether it is possible to subscribe the one and the same agent to two different elementary sc-events, it is better not to do it. Each agent should be subscribed to only one type of sc-event. If you need to subscribe an agent to multiple types of sc-events, you're probably doing something wrong.</p> <p>Consider an example. Suppose you want to implement an agent to recalculate power of a set, which will react when a sc-arc is removed from the set and when a sc-arc is added from it. You should not do such an agent. It is better to split these two logics into two independent objects: an agent that will react when a sc-arc is erased from the specified set and an agent that will react when a sc-arc is generated from this set.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#what-happens-if-i-dont-specify-full-initiation-condition-in-agent-class","title":"What happens if I don't specify full initiation condition in agent class?","text":"<p>We allow not specifying full initiation condition for agents. However, remember, your agents will be executed every time an event occurs over the listen sc-element your agent is subscribed to.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#can-there-be-an-agent-without-primary-initiation-condition","title":"Can there be an agent without primary initiation condition?","text":"<p>No, agents can't be without primary initiation condition. Agents react to events in sc-memory. A primary initiation condition indicates which sc-event agent is subscribed to, i.e. when agent will be called.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#is-it-possible-to-generate-object-of-scagent-class-and-call-any-of-class-methods","title":"Is it possible to generate object of <code>ScAgent</code> class and call any of class methods?","text":"<p>Yes, you can call a method of agent class through object of that class. But remember that you can't generate necessary arguments for all methods.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#is-agents-call-protocol-preserved","title":"Is agent's call protocol preserved?","text":"<p>Until the sc-machine implements functionality for logging processes in sc-memory. It will be added in the next versions. However, the sc-machine does not remove anything by itself.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#what-is-advisable-to-do-as-an-agent-and-what-is-not","title":"What is advisable to do as an agent and what is not?","text":"<p>It depends on your goal. If you want to make an ostis-system, then the whole functionality of your system should be a collective of agents. If you want to use a machine as a database to store and process information in a convenient and simple way, not everything should be agents. To improve performance, use agents with static specification or without specification, combine multiple agents into one, optimize sc-memory requests and etc.</p>"},{"location":"sc-memory/api/cpp/extended/agents/agents/#whats-the-purpose-of-result-condition-what-is-it-used-for","title":"What's the purpose of result condition? What is it used for?","text":"<p>Now, it has no effect on agent finishing. But in the future it can be used for verification and debugging of agents' work.</p>"},{"location":"sc-memory/api/cpp/extended/agents/event_subscriptions/","title":"C++ Event Subscriptions API","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>The C++ Event Subscriptions API focuses on managing subscriptions to various events within the system. This documentation explains how agents can subscribe to specific events and receive notifications when these events occur. It is essential for building systems that require real-time updates and interactions based on event occurrences.</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_event_subscription.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/agents/event_subscriptions/#sceventsubscription","title":"ScEventSubscription","text":"<p><code>ScElementaryEventSubscription</code> is base class for all sc-event subscription, it can be used to catch all sc-events for specified sc-element.</p> <p>Each sc-event subscription constructor, besides <code>ScElementaryEventSubscription</code> constructor, takes 3 parameters:</p> <ul> <li><code>context</code> is an object of <code>ScMemoryContext</code> that will be used to work with sc-event;</li> <li><code>subscriptionElementAddr</code> is an object of <code>ScAddr</code> of sc-element that need to be listened for a specified sc-event;</li> <li><code>delegateFunc</code> is a delegate to a callback function, that will be called on each event emit (<code>void delegateFunc(TScEvent const &amp;)</code>), where <code>TScEvent</code> is corresponding sc-event class.</li> </ul> <p>Note</p> <p>Callback function will be called in another thread!</p> <p>Warning</p> <p>Subscription sc-element must be valid sc-element.</p> <p>Constructor of <code>ScElementaryEventSubscription</code> class takes 4 parameters:</p> <ul> <li><code>context</code> is an object of <code>ScMemoryContext</code> that will be used to work with sc-event;</li> <li><code>eventClassAddr</code> is an object of <code>ScAddr</code> of sc-event class;</li> <li><code>subscriptionElementAddr</code> is an object of <code>ScAddr</code> of sc-element that need to be listened for a specified sc-event;</li> <li><code>delegateFunc</code> is a delegate to a callback function, that will be called on each event emit (<code>void delegateFunc(ScElementaryEvent const &amp;)</code>).</li> </ul> <p>All these constructors are private, you can't call these. We provide more safe API to generate subscription. Use C++ Agent Context API to generate sc-event subscriptions.</p> <p>All sc-event classes are in core keynodes:</p> <ul> <li><code>ScKeynodes::sc_event_after_generate_connector</code>;</li> <li><code>ScKeynodes::sc_event_after_generate_outgoing_arc</code>;</li> <li><code>ScKeynodes::sc_event_after_generate_incoming_arc</code>;</li> <li><code>ScKeynodes::sc_event_after_generate_edge</code>;</li> <li><code>ScKeynodes::sc_event_before_erase_connector</code>;</li> <li><code>ScKeynodes::sc_event_before_erase_outgoing_arc</code>;</li> <li><code>ScKeynodes::sc_event_before_erase_incoming_arc</code>;</li> <li><code>ScKeynodes::sc_event_before_erase_edge</code>;</li> <li><code>ScKeynodes::sc_event_before_erase_element</code>;</li> <li><code>ScKeynodes::sc_event_before_change_link_content</code>.</li> </ul> <p>Use them as <code>eventClassAddr</code> for <code>CreateElementaryEventSubscription</code>.</p> <p>The table of description (parameters of callback function named on pictures, if there are no parameter name on picture, then it's would have an empty value):</p> <p>Note</p> <p>Here <code>context</code> is pointer to object of <code>ScAgentContext</code> class.</p> Class Description ScElementaryEventSubscription Example C++ code:       <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription(\n  eventClassAddr,\n  subscriptionElementAddr, \n  [](ScElementaryEvent const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      </code></pre> ScEventAfterGenerateConnector Example C++ code:       <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventAfterGenerateConnector&gt;(\n  subscriptionElementAddr, \n  [](ScEventAfterGenerateConnector const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      \n    \n  \n\n  \n    ScEventAfterGenerateOutgoingArc\n    \n      \n      Example C++ code:\n      <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventAfterGenerateOutgoingArc&gt;(\n  subscriptionElementAddr, \n  [](ScEventAfterGenerateOutgoingArc const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      \n    \n  \n\n  \n    ScEventAfterGenerateIncomingArc\n    \n      \n      Example C++ code:\n      <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventAfterGenerateIncomingArc&gt;(\n  subscriptionElementAddr, \n  [](ScEventAfterGenerateIncomingArc const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      \n    \n  \n\n  \n    ScEventAfterGenerateEdge\n    \n      \n      Example C++ code:\n      <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventAfterGenerateEdge&gt;(\n  subscriptionElementAddr, \n  [](ScEventAfterGenerateEdge const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      \n    \n  \n\n  \n    ScEventBeforeEraseConnector\n    \n      \n      Example C++ code:\n      <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventBeforeEraseConnector&gt;(\n  subscriptionElementAddr, \n  [](ScEventBeforeEraseConnector const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      \n    \n  \n\n  \n    ScEventBeforeEraseOutgoingArc\n    \n      \n      Example C++ code:\n      <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventBeforeEraseOutgoingArc&gt;(\n  subscriptionElementAddr, \n  [](ScEventBeforeEraseOutgoingArc const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      \n    \n  \n\n  \n    ScEventBeforeEraseIncomingArc\n    \n      \n      Example C++ code:\n      <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventBeforeEraseIncomingArc&gt;(\n  subscriptionElementAddr, \n  [](ScEventBeforeEraseIncomingArc const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      \n    \n  \n\n  \n    ScEventBeforeEraseEdge\n    \n      \n      Example C++ code:\n      <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventBeforeEraseEdge&gt;(\n  subscriptionElementAddr, \n  [](ScEventBeforeEraseEdge const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      \n    \n  \n\n  \n    ScEventBeforeEraseElement\n    \n      Example C++ code:\n      <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventBeforeEraseElement&gt;(\n  subscriptionElementAddr, \n  [](ScEventBeforeEraseElement const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      </code></pre>\n    \n  \n\n  \n    ScEventBeforeChangeLinkContent\n    \n      \n      Example C++ code:\n      <pre><code>\n...\nauto subscription = context-&gt;CreateElementaryEventSubscription&lt;\n  ScEventBeforeChangeLinkContent&gt;(\n  subscriptionElementAddr, \n  [](ScEventBeforeChangeLinkContent const &amp; event) -&gt; void\n{\n  // Handle sc-event.\n});\n...\n      </code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/event_subscriptions/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul>\n<li>Whether a function is considered an agent if this function is subscribed to a sc-event and which is called after that sc-event occurs?</li>\n<li>Why can't you call the constructor of a subscription class to sc-event?</li>\n<li>Are <code>ScEventAfterGenerateIncomingArc</code> or <code>ScEventAfterGenerateOutgoingArc</code> events trigger when <code>ScEventAfterGenerateEdge</code> event is triggered?</li>\n</ul>"},{"location":"sc-memory/api/cpp/extended/agents/event_subscriptions/#whether-a-function-is-considered-an-agent-if-this-function-is-subscribed-to-a-sc-event-and-which-is-called-after-that-sc-event-occurs","title":"Whether a function is considered an agent if this function is subscribed to a sc-event and which is called after that sc-event occurs?","text":"<p>No, such functions are not agents. Agents have a strict specification. See C++ Agents API.</p>"},{"location":"sc-memory/api/cpp/extended/agents/event_subscriptions/#why-cant-i-call-the-constructor-of-a-subscription-class-to-sc-event","title":"Why can't I call the constructor of a subscription class to sc-event?","text":"<p>First of all, it's not safe. We need more checks on input arguments because there are more of them. Secondly, it is correct from the OOP point of view. Constructors should not throw exceptions. Third, it is correct from the point of view of the architecture we use in the sc-machine. The <code>ScAgentContext</code> is a facade over all possible objects used by agents.</p>"},{"location":"sc-memory/api/cpp/extended/agents/event_subscriptions/#are-sceventaftergenerateincomingarc-or-sceventaftergenerateoutgoingarc-events-trigger-when-sceventaftergenerateedge-event-is-triggered","title":"Are <code>ScEventAfterGenerateIncomingArc</code> or <code>ScEventAfterGenerateOutgoingArc</code> events trigger when <code>ScEventAfterGenerateEdge</code> event is triggered?","text":"<p>No, the <code>ScEventAfterGenerateEdge</code> event only occurs when sc-edges are generated.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/","title":"C++ Events API","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>The C++ Events API is designed to handle event-driven programming within the sc-machine. This section details types of possible events and how to respond to triggered events.</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_event.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#what-is-event-driven-model","title":"What is event-driven model?","text":"<p>The sc-machine uses event-driven model to manage processing sc-constructions. The sc-memory stores SC-code constructions, which are graph structures, then any kind of events, occurring in sc-memory, is related to changes in these graph constructions.</p> <p>These are methods that generate events: </p> <ul> <li><code>GenerateConnector</code>, </li> <li><code>EraseElement</code>,</li> <li><code>SetLinkContent</code>.</li> </ul> <p>They publish events to an event queue without needing to know which consumers will receive them. These components filter and distribute events to appropriate consumers. They manage the flow of events and ensure that they reach the correct destinations. Event consumers are the components that listen for and process events. Event consumers can be modules, agents or something else. See FAQ to find out why it works that way.</p> <p>Within the OSTIS Technology, events are considered only situations in which relationships have changed or new relationships have been generated, or link content have been changed, or some sc-element have been erased.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#scevent","title":"ScEvent","text":"<p>The sc-machine provides functionality for subscribing to the following elementary types of sc-events:</p> <ul> <li><code>ScElementaryEvent</code> is base class for all sc-events, it can be used to handle all sc-events for specified sc-element;</li> <li><code>ScEventAfterGenerateConnector</code>, emits each time, when sc-connector from or to specified sc-element is generated;</li> <li><code>ScEventAfterGenerateOutgoingArc</code>, emits each time, when outgoing sc-arc from specified sc-element is generated;</li> <li><code>ScEventAfterGenerateIncomingArc</code>, emits each time, when incoming sc-arc to specified sc-element is generated;</li> <li><code>ScEventAfterGenerateEdge</code>, emits each time, when sc-edge from or to specified sc-element is generated;</li> <li><code>ScEventBeforeEraseConnector</code>, emits each time, when sc-connector from or to specified sc-element is erasing;</li> <li><code>ScEventBeforeEraseOutgoingArc</code>, emits each time, when outgoing sc-arc from specified sc-element is erasing;</li> <li><code>ScEventBeforeEraseIncomingArc</code>, emits each time, when incoming sc-arc to specified sc-element is erasing;</li> <li><code>ScEventBeforeEraseEdge</code>, emits each time, when sc-edge from or to specified sc-element is erasing;</li> <li><code>ScEventBeforeEraseElement</code>, emits, when specified sc-element is erasing;</li> <li><code>ScEventBeforeChangeLinkContent</code>, emits each time, when content of specified sc-link is changing.</li> </ul> <p>The following classes correspond to them:</p> <ul> <li><code>class ScElementaryEvent</code>;</li> <li><code>template &lt;ScType const &amp; connectorType&gt; class ScEventAfterGenerateConnector</code>;</li> <li><code>template &lt;ScType const &amp; arcType&gt; class ScEventAfterGenerateOutgoingArc</code>;</li> <li><code>template &lt;ScType const &amp; arcType&gt; class ScEventAfterGenerateIncomingArc</code>;</li> <li><code>template &lt;ScType const &amp; edgeType&gt; class ScEventAfterGenerateEdge</code>;</li> <li><code>template &lt;ScType const &amp; connectorType&gt; class ScEventBeforeEraseConnector</code>;</li> <li><code>template &lt;ScType const &amp; arcType&gt; class ScEventBeforeEraseOutgoingArc</code>;</li> <li><code>template &lt;ScType const &amp; arcType&gt; class ScEventBeforeEraseIncomingArc</code>;</li> <li><code>template &lt;ScType const &amp; edgeType&gt; class ScEventBeforeEraseEdge</code>;</li> <li><code>class ScEventBeforeEraseElement</code>;</li> <li><code>class ScEventBeforeChangeLinkContent</code>.</li> </ul> <p>Note</p> <p>All these sc-events classes are inherited from <code>ScElementaryEvent</code> class. <code>ScElementaryEvent</code> class is inherited from <code>ScEvent</code> class that is an abstract class.</p> <p>Note</p> <p>Types of sc-connectors are specified for sc-events of adding (erasing) sc-arc (sc-edge). </p> <p>Warning</p> <p>You can't generate objects of these classes. All constructors of these classes are private.</p> <p>Warning</p> <p>All objects of sc-event classes are not copyable and not movable.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#scelementaryevent","title":"ScElementaryEvent","text":"<p>This class provides three common methods for all sc-events: <code>GetUser</code>, <code>GetSubscriptionElement</code> and <code>GetTriple</code>.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getuser","title":"GetUser","text":"<p>Use this method to get sc-address of who initiated the current sc-event.</p> <pre><code>...\nScAddr const userAddr = event.GetUser();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getsubscriptionelement","title":"GetSubscriptionElement","text":"<p>Each event occurs within a semantic neighbourhood of some sc-element. This sc-element is called sc-event subscription sc-element. In other words, it is an element that is permanently listening for the occurrence of certain sc-events within its neighbourhood. To get it, use this method.</p> <pre><code>...\nScAddr const subscriptionElement = event.GetSubscriptionElement();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#gettriple","title":"GetTriple","text":"<p>To get information about sc-elements in initiated sc-event, you can use this method. It returns tuple of three ScAddr. For more information see the table below.</p> Class Description ScEventAfterGenerateConnector Example C++ code:       <pre><code>\n...\nauto const [subscriptionElementAddr, connectorAddr, otherAddr] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of source or \n// target sc-element (listen it in sc-event).\n// `connectorAddr` is sc-address of generated sc-connector \n// to or from `subscriptionElementAddr`.\n// `otherAddr` is sc-address of source or target sc-element \n// of `arcAddr`.\n...\n      </code></pre> ScEventAfterGenerateOutgoingArc Example C++ code:       <pre><code>\n...\nauto const [subscriptionElementAddr, arcAddr, otherAddr] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of source sc-element \n// (listen it in sc-event).\n// `arcAddr` is sc-address of generated outgoing sc-arc \n// from `subscriptionElementAddr`.\n// `otherAddr` is sc-address of target sc-element of `arcAddr`.\n...\n      </code></pre> ScEventAfterGenerateIncomingArc Example C++ code:       <pre><code>\n...\nauto const [subscriptionElementAddr, arcAddr, otherAddr] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of target sc-element \n// (listen it in sc-event).\n// `arcAddr` is sc-address of generated incoming sc-arc \n// to `subscriptionElementAddr`.\n// `otherAddr` is sc-address of source sc-element of `arcAddr`.\n...\n      </code></pre> ScEventAfterGenerateEdge Example C++ code:       <pre><code>\n...\nauto const [subscriptionElementAddr, edgeAddr, otherAddr] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of source \n// or target sc-element (listen it in sc-event).\n// `edgeAddr` is sc-address of generated sc-edge \n// to or from `subscriptionElementAddr`.\n// `otherAddr` is sc-address of source or target sc-element \n// of `edgeAddr`.\n...\n      </code></pre> ScEventBeforeEraseConnector Example C++ code:     <pre><code>\n...\nauto const [subscriptionElementAddr, connectorAddr, otherAddr] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of source or\n// target sc-element (listen it in sc-event).\n// `connectorAddr` is sc-address of erasable sc-connector \n// to or from `subscriptionElementAddr`.\n// `otherAddr` is sc-address of source or target sc-element \n// of `arcAddr`.\n...\n      </code></pre> ScEventBeforeEraseOutgoingArc Example C++ code:       <pre><code>\n...\nauto const [subscriptionElementAddr, arcAddr, otherAddr] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of source sc-element \n// (listen it in sc-event).\n// `arcAddr` is sc-address of erasable outgoing sc-arc \n// from `subscriptionElementAddr`.\n// `otherAddr` is sc-address of target sc-element of `arcAddr`.\n...\n      </code></pre> ScEventBeforeEraseIncomingArc Example C++ code:       <pre><code>\n...\nauto const [subscriptionElementAddr, arcAddr, otherAddr] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of target sc-element \n// (listen it in sc-event).\n// `arcAddr` is sc-address of erasable incoming sc-arc \n// to `subscriptionElementAddr`.\n// `otherAddr` is sc-address of source sc-element of `arcAddr`.\n...\n      </code></pre> ScEventBeforeEraseEdge Example C++ code:       <pre><code>\n...\nauto const [subscriptionElementAddr, edgeAddr, otherAddr] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of source or \n// target sc-element \n// (listen it in sc-event).\n// `edgeAddr` is sc-address of erasable sc-edge \n// to or from `subscriptionElementAddr`.\n// `otherAddr` is sc-address of source or target sc-element \n// of `edgeAddr`.\n...\n      </code></pre> ScEventBeforeEraseElement Example C++ code:       <pre><code>\n...\nauto const [subscriptionElementAddr, _1, _2] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of erasable \n// sc-element \n// (listen it in sc-event).\n// `_1` is empty sc-address.\n// `_2` is empty sc-address.\n...\n      </code></pre> ScEventBeforeChangeLinkContent Example C++ code:       <pre><code>\n...\nauto const [subscriptionElementAddr, _1, _2] \n  = event.GetTriple();\n// `subscriptionElementAddr` is sc-address of sc-link \n// that has changable content.\n// (listen it in sc-event).\n// `_1` is empty sc-address.\n// `_2` is empty sc-address.\n...\n      </code></pre> <p>Note</p> <p>All described methods of <code>ScElementaryEvent</code> class are public and accessible from child classes.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#sceventaftergenerateconnector","title":"ScEventAfterGenerateConnector","text":"<p><code>ScEventAfterGenerateConnector</code> is class that represents sc-event of generating sc-connector to or from specified sc-element.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getconnector","title":"GetConnector","text":"<p>Method <code>GetConnector</code> returns generated sc-connector to or from listen sc-element (subscription sc-element).</p> <pre><code>...\nScAddr const connectorAddr = event.GetConnector();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getconnectortype","title":"GetConnectorType","text":"<p>It returns sc-type of generated sc-connector.</p> <pre><code>...\nScType const connectorType = event.GetConnectorType();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getconnectorincidentelements","title":"GetConnectorIncidentElements","text":"<p>A sc-connector can be a sc-arc or a sc-edge, so method <code>GetConnectorIncidentElements</code> returns two incident elements for the generated sc-connector at once.</p> <pre><code>...\nauto const [elementAddr1, elementAddr2] = event.GetConnectorIncidentElements();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#sceventaftergenerateoutgoingarc-and-sceventaftergenerateincomingarc","title":"ScEventAfterGenerateOutgoingArc and ScEventAfterGenerateIncomingArc","text":"<p><code>ScEventAfterGenerateOutgoingArc</code> is class that represents sc-event of generating outgoing sc-arc from specified sc-element. <code>ScEventAfterGenerateIncomingArc</code> represents sc-event of generating incoming sc-arc to specified sc-element.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getarc","title":"GetArc","text":"<p>Method <code>GetArc</code> returns generated sc-arc from (for <code>ScEventAfterGenerateOutgoingArc</code>) or to (for <code>ScEventAfterGenerateIncomingArc</code>) listen sc-element (subscription sc-element).</p> <pre><code>...\nScAddr const arcAddr = event.GetArc();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getarctype","title":"GetArcType","text":"<p>It returns sc-type of generated sc-arc.</p> <pre><code>...\nScType const arcType = event.GetArcType();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getarcsourceelement","title":"GetArcSourceElement","text":"<p>To get source and target sc-elements of generated sc-arc you can use <code>GetArcSourceElement</code> and <code>GetArcTargetElement</code> methods. For <code>ScEventAfterGenerateOutgoingArc</code> method <code>GetArcSourceElement</code> returns sc-address of listen sc-element, for <code>ScEventAfterGenerateIncomingArc</code> method <code>GetArcTargetElement</code> returns sc-address of listen sc-element.</p> <pre><code>...\nScAddr const sourceElementAddr = event.GetArcSourceElement();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getarctargetelement","title":"GetArcTargetElement","text":"<pre><code>...\nScAddr const targetElementAddr = event.GetArcTargetElement();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#sceventaftergenerateedge","title":"ScEventAfterGenerateEdge","text":"<p>This class represents sc-event of adding sc-edge from or to specified sc-element.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getedge","title":"GetEdge","text":"<p>Method <code>GetEdge</code> returns generated sc-edge from or to listen sc-element (subscription sc-element).</p> <pre><code>...\nScAddr const edgeAddr = event.GetEdge();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getedgetype","title":"GetEdgeType","text":"<p>It returns sc-type of generated sc-edge.</p> <pre><code>...\nScAddr const edgeType = event.GetEdgeType();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getedgeincidentelements","title":"GetEdgeIncidentElements","text":"<p>To get incident sc-elements of generated sc-edge you can use <code>GetEdgeIncidentElements</code> method.</p> <pre><code>...\nauto const [elementAddr1, elementAddr2] = event.GetEdgeIncidentElements();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#sceventbeforeeraseconnector","title":"ScEventBeforeEraseConnector","text":"<p><code>ScEventBeforeEraseConnector</code> is class that represents sc-event of erasing sc-connector to or from specified sc-element.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getconnector_1","title":"GetConnector","text":"<p>Method <code>GetConnector</code> returns erasable sc-connector to or from listen sc-element (subscription sc-element).</p> <pre><code>...\nScAddr const connectorAddr = event.GetConnector();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getconnectortype_1","title":"GetConnectorType","text":"<p>It returns sc-type of erasable sc-connector.</p> <pre><code>...\nScType const connectorType = event.GetConnectorType();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getconnectorincidentelements_1","title":"GetConnectorIncidentElements","text":"<p>Method <code>GetConnectorIncidentElements</code> returns two incident elements for the erasable sc-connector at once.</p> <pre><code>...\nauto const [elementAddr1, elementAddr2] = event.GetConnectorIncidentElements();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#sceventbeforeeraseoutgoingarc-and-sceventbeforeeraseincomingarc","title":"ScEventBeforeEraseOutgoingArc and ScEventBeforeEraseIncomingArc","text":"<p><code>ScEventBeforeEraseOutgoingArc</code> is class that represents sc-event of erasing outgoing sc-arc from specified sc-element. <code>ScEventBeforeEraseIncomingArc</code> represents sc-event of erasing incoming sc-arc to specified sc-element.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getarc_1","title":"GetArc","text":"<p>Method <code>GetArc</code> returns erasable sc-arc from (for <code>ScEventBeforeEraseOutgoingArc</code>) or to (for <code>ScEventBeforeEraseIncomingArc</code>) listen sc-element (subscription sc-element).</p> <pre><code>...\nScAddr const arcAddr = event.GetArc();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getarctype_1","title":"GetArcType","text":"<p>It returns sc-type of erasable sc-arc.</p> <pre><code>...\nScAddr const arcType = event.GetArcType();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getarcsourceelement_1","title":"GetArcSourceElement","text":"<p>To get source and target sc-elements of erasable sc-arc you can use <code>GetArcSourceElement</code> and <code>GetArcTargetElement</code> methods. For <code>ScEventBeforeEraseOutgoingArc</code> method <code>GetArcSourceElement</code> returns sc-address of listen sc-element, for <code>ScEventBeforeEraseIncomingArc</code> method <code>GetArcTargetElement</code> returns sc-address of listen sc-element.</p> <pre><code>...\nScAddr const arcSourceElement = event.GetArcSourceElement();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getarctargetelement_1","title":"GetArcTargetElement","text":"<pre><code>...\nScAddr const arcTargetElement = event.GetArcTargetElement();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#sceventbeforeeraseedge","title":"ScEventBeforeEraseEdge","text":"<p>This class represents sc-event of erasing sc-edge from or to specified sc-element.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getedge_1","title":"GetEdge","text":"<p>Method <code>GetEdge</code> returns erasable sc-edge from or to listen sc-element (subscription sc-element).</p> <pre><code>...\nScAddr const edgeAddr = event.GetEdge();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getedgetype_1","title":"GetEdgeType","text":"<p>It returns sc-type of erasable sc-edge.</p> <pre><code>...\nScAddr const edgeType = event.GetEdgeType();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#getedgeincidentelements_1","title":"GetEdgeIncidentElements","text":"<p>To get incident sc-elements of erasable sc-edge you can use <code>GetEdgeIncidentElements</code> method.</p> <pre><code>...\nauto const [elementAddr1, elementAddr2] = event.GetEdgeIncidentElements();\n...\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/events/#sceventbeforeeraseelement","title":"ScEventBeforeEraseElement","text":"<p>This class represents sc-event of erasing specified listen sc-element. You can use all methods from objects of this class that are accessible from <code>ScElementaryEvent</code> class.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#sceventbeforechangelinkcontent","title":"ScEventBeforeChangeLinkContent","text":"<p>This class represents sc-event of changing content for listen sc-link. You can use all methods from objects of this class that are accessible from <code>ScElementaryEvent</code> class.</p> <p>Note</p> <p>For <code>ScEventBeforeEraseElement</code> and <code>ScEventBeforeChangeLinkContent</code> method <code>GetTriple</code> returns tuple of three sc-address. The first one is a sc-event subscription sc-element. The other ones should be empty sc-addresses.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>Is there sc-event of creating sc-node?</li> <li>Is fact of what happened recorded in the knowledge base? Are sc-events recorded in the knowledge base?</li> <li>Why do we need connector events?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/agents/events/#is-there-sc-event-of-creating-sc-node","title":"Is there sc-event of creating sc-node?","text":"<p>A sc-event is defined as the addition, modification or erasing of connections between sc-elements, or changing link content, or erasing sc-element. This is so because knowledge is not a single sc-element, and knowledge is construction of three sc-elements at least. A sc-element does not carry any knowledge in itself. Therefore, a sc-event is considered to be emergence of some new knowledge. But there is an exception, erasing sc-elements with no connections with other sc-elements is considered an event.</p> <p>Also, even if events were defined differently, it doesn't negate the fact that one cannot subscribe to sc-event of creating sc-node, since we don't know about that node in advance, because it doesn't exist.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#is-fact-of-what-happened-recorded-in-the-knowledge-base-are-sc-events-recorded-in-the-knowledge-base","title":"Is fact of what happened recorded in the knowledge base? Are sc-events recorded in the knowledge base?","text":"<p>Right now, sc-events are not recorded in the knowledge base. It will be implemented in the future versions of the sc-machine.</p>"},{"location":"sc-memory/api/cpp/extended/agents/events/#why-do-we-need-connector-events","title":"Why do we need connector events?","text":"<p>Event of generating (erasing) sc-connector is needed to subscribe to both generating (erasing) sc-arc and sc-edge.</p> <p>For example, man B is a brother for woman A, and man B is a brother for man C. Here, the relation <code>to be a brother</code> between woman A and man B is oriented, i.e. they are connected by a sc-arc, not by a sc-edge, and the relation <code>to be a brother</code> between man C and man B is undirected, i.e. these men are connected by a sc-edge. In order for an agent to react to appearance of both a sc-arc and a sc-edge from man B to woman A and man C correspondingly, it is necessary to subscribe that agent to appearance of a sc-connector, i.e sc-arc or sc-edge from man B.</p>"},{"location":"sc-memory/api/cpp/extended/agents/keynodes/","title":"C++ Keynodes API","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>The C++ Keynodes API allows developers to work with key elements in the knowledge graph that represent significant entities. This documentation describes how to create, retrieve, and manipulate keynodes within the sc-machine.</p> <p>A keynode is a key sc-element used by some program (agent) during its operation. Typically, keynodes can be classes and relations, which are sc-elements that program (agent) uses to find constructions in sc-memory or generate new ones. However, keynodes can be any sc-elements (incl. connectors between sc-elements).</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_keynodes.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/agents/keynodes/#sckeynode","title":"ScKeynode","text":"<p>It is a base class for all keynodes. Use it to generate keynodes in the <code>ScKeynodes</code> class for use in agent programs.</p> <pre><code>#include &lt;sc-memory/sc_keynodes.hpp&gt;\n\nstatic ScKeynode const my_keynode_class{\n    \"my_keynode_class\", ScType::ConstNodeClass};\n</code></pre> <p>Note</p> <p>We recommend to name keynode as a system identifier of key element.</p> <p>Note</p> <p>Keynodes can be defined not only in classes inherited from the <code>ScKeynodes</code> class. You can define them as static objects anywhere.</p> <p>Warning</p> <p>Use this class only for static object declarations.</p> <p>Also, you can convert any keynode to string.</p> <pre><code>std::string const &amp; systemIdtf = my_keynode_class;\n</code></pre> <p>It can be useful if you want logging keynode system identifiers.</p>"},{"location":"sc-memory/api/cpp/extended/agents/keynodes/#sctemplatekeynode","title":"ScTemplateKeynode","text":"<p>It is a base class to generate sc-templates as keynodes. This class is useful when you want use programably represented sc-template in different places in the code or when you don't want specify sc-template in knowledge base and use it in <code>ScAgentBuilder</code>.</p> <pre><code>#include &lt;sc-memory/sc_keynodes.hpp&gt;\n\nstatic ScTemplateKeynode const &amp; my_agent_initiation_condition =\n  ScTemplateKeynode(\"my_agent_initiation_condition\")\n     .Triple(\n        ScKeynodes::action_initiated,\n        ScType::VarPermPosArc,\n        ScType::VarNode &gt;&gt; \"_action\")\n     .Triple(\n        MyKeynodes::my_action,\n        ScType::VarPermPosArc,\n        \"_action\");\n</code></pre> <p>Note</p> <p>Objects of this class can be used as <code>ScTemplate</code> and <code>ScAddr</code>.</p> <p>Warning</p> <p>Use this class only for static object declarations.</p>"},{"location":"sc-memory/api/cpp/extended/agents/keynodes/#sckeynodes","title":"ScKeynodes","text":"<p>This class is a base class for keynodes declaration. It's like a namespace. Use it as a base class for own keynodes. This class already contains frequently used keynodes. Use them in your code.</p> <pre><code>// File my_keynodes.hpp:\n#pragma once\n\n#include &lt;sc-memory/sc_keynodes.hpp&gt;\n\nclass MyKeynodes : public ScKeynodes\n{\npublic:\n  static inline ScKeynode const my_keynode_class_a{\n    \"my_keynode_class_a\", ScType::ConstNodeClass};\n  static inline ScKeynode const my_keynode_relation_b{\n    \"my_keynode_relation_b\", ScType::ConstNodeNonRole};\n};\n</code></pre> <p>You don't have to inherit class <code>ScKeynodes</code>, you can do it this way.</p> <pre><code>// File my_keynodes.hpp:\n#pragma once\n\n#include &lt;sc-memory/sc_keynodes.hpp&gt;\n\nclass MyKeynodes\n{\npublic:\n  static inline ScKeynode const my_keynode_class_a{\n    \"my_keynode_class_a\", ScType::ConstNodeClass};\n  static inline ScKeynode const my_keynode_relation_b{\n    \"my_keynode_relation_b\", ScType::ConstNodeNonRole};\n};\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/keynodes/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>Is it possible to generate the same keynodes in different modules but with different types?</li> <li>Is it possible to generate a keynode inside an agent class?</li> <li>When are keynodes initialized?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/agents/keynodes/#is-it-possible-to-generate-the-same-keynodes-in-different-modules-but-with-different-types","title":"Is it possible to generate the same keynodes in different modules but with different types?","text":"<p>You can generate the same keynodes in different modules. The main thing is that there should be no name conflict in the classes in which these keynodes are declared. However, you cannot generate identical keynodes in different modules with different types, for example, as structure and as class. All sc-elements with the same system identifiers are automatically glued together.</p>"},{"location":"sc-memory/api/cpp/extended/agents/keynodes/#is-it-possible-to-generate-a-keynode-inside-an-agent-class","title":"Is it possible to generate a keynode inside an agent class?","text":"<p>Yes, the algorithm is exactly the same if you were to generate this keynode in a separate special class for keynodes.</p>"},{"location":"sc-memory/api/cpp/extended/agents/keynodes/#when-are-keynodes-initialized","title":"When are keynodes initialized?","text":"<p>They are initialized during sc-memory initialization. Do not use them before the memory has been initialized.</p>"},{"location":"sc-memory/api/cpp/extended/agents/modules/","title":"C++ Modules API","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>The C++ Modules API outlines how to create and manage modules that group agents within sc-machine. This section describes how to register agents in an application.</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_module.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/agents/modules/#scmodule","title":"ScModule","text":"<p>This class is a base class for subscribing/unsubscribing agents to/from sc-events. It's like a complex component that contains connected agents.</p> <p>To subscribe your agents to sc-events, implement module class and call <code>Agent</code> methods to subscribe these agents.</p> <pre><code>// File my_module.hpp\n#pragma once\n\n#include &lt;sc-memory/sc_module.hpp&gt;\n\nclass MyModule : public ScModule\n{\n};\n</code></pre> <pre><code>// File my_module.cpp:\n#include \"my-module/my_module.hpp\"\n\n#include \"my-module/keynodes/my_keynodes.hpp\"\n#include \"my-module/agent/my_agent.hpp\"\n\nSC_MODULE_REGISTER(MyModule)\n// It initializes static object of `MyModule` class that can be \n// used to call methods for subscribing agents to sc-events.\n  -&gt;Agent&lt;MyAgent&gt;(); \n  // It subscribes agent and returns object of `MyModule`.\n  // `MyAgent` is inherited from `ScActionInitiatedAgent`.\n  // This method pointers to module that agent class `MyAgent`\n  // should be subscribed to sc-event of adding outgoing sc-arc from \n  // sc-element `action_initiated`. It is default parameter\n  // in these method if you want to subscribe agent class inherited \n  // from `ScActionInitiatedAgent`.\n</code></pre> <p>You must call <code>Agent</code> method for agent classes inherited from <code>ScActionInitiatedAgent</code> without arguments, but you should call it providing sc-event subscription sc-element for agent classes inherited from <code>ScAgent</code>.</p> <p>A module subscribed agents when the sc-memory initializes and it unsubscribes them when the sc-memory shutdowns. Also, you can use module to subscribe a set of agents.</p> <pre><code>// File my_module.cpp:\n#include \"my-module/my_module.hpp\"\n\n#include \"my-module/agent/my_agent1.hpp\"\n#include \"my-module/agent/my_agent2.hpp\"\n#include \"my-module/agent/my_agent3.hpp\"\n#include \"my-module/agent/my_agent4.hpp\"\n#include \"my-module/agent/my_agent5.hpp\"\n\nSC_MODULE_REGISTER(MyModule)\n  -&gt;Agent&lt;MyAgent1&gt;()\n  -&gt;Agent&lt;MyAgent2&gt;()\n  -&gt;Agent&lt;MyAgent3&gt;()\n  -&gt;Agent&lt;MyAgent4&gt;()\n  -&gt;Agent&lt;MyAgent5&gt;()\n  // ...\n  ;\n</code></pre> <p>If you need to initialize not agent objects in module, you can override <code>Initialize</code> and <code>Shutdown</code> methods in your module class.</p> <pre><code>// File my_module.hpp:\nclass MyModule : public ScModule\n{\n+ void Initialize(ScMemoryContext * context) override;\n+ void Shutdown(ScMemoryContext * context) override;\n};\n</code></pre> <pre><code>// File my_module.cpp:\n#include \"my-module/my_module.hpp\"\n\n#include \"my-module/agent/my_agent.hpp\"\n\nSC_MODULE_REGISTER(MyModule)\n  -&gt;Agent&lt;MyAgent&gt;(); \n\n+ // This method will be called once. \n+ void MyModule::Initialize(ScMemoryContext * context)\n+ {\n+   // Implement initialize of your objects here.\n+ }\n+ // This method will be called once. \n+ void MyModule::Shutdown(ScMemoryContext * context)\n+ {\n+   // Implement shutdown of your objects here.\n+ }\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/modules/#dynamic-agent-specification","title":"Dynamic agent specification","text":"<p>Modules allow to subscribe agents with dynamic specification provided in knowledge base or in code. Dynamic specification can be changed by other agents. To learn more about types of agent specifications in C++ Agents API.</p> <p>For this <code>ScModule</code> class has <code>AgentBuilder</code> method. You can call this method with agent class providing keynode of agent implementation specified in knowledge base or calling methods after this method to set the specification elements for the given agent.</p>"},{"location":"sc-memory/api/cpp/extended/agents/modules/#scagentbuilder","title":"ScAgentBuilder","text":"<p>The <code>AgentBuilder</code> method generates object of <code>ScAgentBuilder</code> class that is needed to initialize agent specification from code or from knowledge base.</p>"},{"location":"sc-memory/api/cpp/extended/agents/modules/#loading-initial-agent-specification-in-c","title":"Loading initial agent specification in C++","text":"<p>You can specify initial specification for your agent class in code with help of <code>ScAgentBuilder</code>.</p> <pre><code>// File my_module.cpp:\n#include \"my-module/my_module.hpp\"\n\n#include \"my-module/agent/my_agent.hpp\"\n\nSC_MODULE_REGISTER(MyModule)\n  -&gt;AgentBuilder&lt;MyAgent&gt;()\n    // Abstract agent must belong to `abstract_sc_agent`.\n    -&gt;SetAbstractAgent(MyKeynodes::my_abstract_agent)\n    -&gt;SetPrimaryInitiationCondition({\n        // Event class must belong to `sc_event`.\n        ScKeynodes::sc_event_after_generate_outgoing_arc, \n        ScKeynodes::action_initiated\n    }) \n    // You should provide action class that is include to the one of types: \n    // `receptor_action`, `effector_action`, `behavioral_action` or \n    // `information_action`.\n    -&gt;SetActionClass(MyKeynodes::my_action_class)\n    -&gt;SetInitiationConditionAndResult({\n        MyKeynodes::my_agent_initiation_condition_template,\n        MyKeynodes::my_agent_result_condition_template\n    })\n    -&gt;FinishBuild();\n</code></pre> <p>So you can load the initial specification for your agent into the knowledge base from the code. You can change it or not, it depends on your problem.</p> <p>Note</p> <p>If specification for an agent already exists in the knowledge base, no new connections will be generated, i.e. there will be no duplicates.</p> <p>Note</p> <p>All provided arguments must be valid, otherwise you module will not be subscribed, because errors will occur.</p> <p>Warning</p> <p>If specification for an agent isn't already in the knowledge base, you should call all the methods listed after <code>AgentBuilder</code> call.</p> <p>Warning</p> <p>At the end of list after <code>AgentBuilder</code> call you should call <code>FinishBuild</code> method, otherwise your code can't be compiled.</p>"},{"location":"sc-memory/api/cpp/extended/agents/modules/#loading-agent-specification-from-knowledge-base","title":"Loading agent specification from knowledge base","text":"<p>If you has specification for your agent in the knowledge base wrote in SCs-code or SCg-code, then you can just specify implementation of your agent.</p> <p>Write scs-specification (or scg-specification) of your agent and use it with to subscribe your agent within module.</p> <pre><code>// Specification of agent in knowledge base.\nmy_abstract_agent\n&lt;- abstract_sc_agent;\n=&gt; nrel_primary_initiation_condition: \n    (sc_event_after_generate_outgoing_arc =&gt; action_initiated); \n=&gt; nrel_sc_agent_action_class:\n    my_action_class; \n=&gt; nrel_initiation_condition_and_result: \n    (my_agent_initiation_condition_template \n        =&gt; my_agent_result_condition_template);\n&lt;= nrel_sc_agent_key_sc_elements:\n{\n    action_initiated;\n    my_action_class;\n    my_class\n};\n=&gt; nrel_inclusion: \n    my_agent_implementation \n    (*\n        &lt;- platform_dependent_abstract_sc_agent;;\n        &lt;= nrel_sc_agent_program: \n        {\n            [github.com/path/to/agent/sources] \n            (* =&gt; nrel_format: format_github_source_link;; *)\n        };; \n    *);;\n\nmy_agent_initiation_condition_template\n= [*\n    my_action_class _-&gt; .._action;;\n    action_initiated _-&gt; .._action;;\n    .._action _-&gt; rrel_1:: .._parameter;;\n*];; \n\nmy_agent_result_condition_template\n= [*\n    my_class _-&gt; .._my_node;;\n*];;\n</code></pre> <p></p> <pre><code>// File my_module.cpp:\n#include \"my-module/my_module.hpp\"\n\n#include \"my-module/agent/my_agent.hpp\"\n\nSC_MODULE_REGISTER(MyModule)\n  -&gt;AgentBuilder&lt;MyAgent&gt;(ScKeynodes::my_agent_implementation)\n    -&gt;FinishBuild();\n</code></pre> <p>Note</p> <p>If specification of your agent isn't full in the knowledge base, then module will not be subscribed, because errors will occur. Other correctly specified agents will be subscribed without errors.</p>"},{"location":"sc-memory/api/cpp/extended/agents/modules/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>Is it possible to subscribe an agent without calling a method to subscribe it?</li> <li>Is it possible to generate one module and subscribe all agents in it?</li> <li>If there is a difference in what order to subscribe agents?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/agents/modules/#is-it-possible-to-subscribe-an-agent-without-calling-a-method-to-subscribe-it","title":"Is it possible to subscribe an agent without calling a method to subscribe it?","text":"<p>You can implement an agent that will traverse all agent specifications in the knowledge base and subscribe agents according its specifications.</p>"},{"location":"sc-memory/api/cpp/extended/agents/modules/#is-it-possible-to-generate-one-module-and-subscribe-all-agents-in-it","title":"Is it possible to generate one module and subscribe all agents in it?","text":"<p>You can do that, but we advise you to build components from agents, meaning agents should be included in the same module if they make sense to be in the same component. Get used to having every module be a component.</p>"},{"location":"sc-memory/api/cpp/extended/agents/modules/#if-there-is-a-difference-in-what-order-to-subscribe-agents","title":"If there is a difference in what order to subscribe agents?","text":"<p>Probably, not. Agents shouldn't be dependent on each other. But if you did, it's better not to do so.</p>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/","title":"C++ Waiters API","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>The C++ Waiters API provides functionality for implementing wait conditions within agent workflows. This section covers how to create waiters that pause agent execution until specified conditions are met or events are triggered. It is particularly useful for synchronizing actions across multiple agents or ensuring that certain prerequisites are fulfilled before proceeding with tasks.</p> <p>Note</p> <p>To include this API provide <code>#include &lt;sc-memory/sc_waiter.hpp&gt;</code> in your hpp source.</p>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#scwaiter-and-scconditionwaiter","title":"ScWaiter and ScConditionWaiter","text":"<p>This type of objects is used to wait until some event emits until the maximum waiting time expires. It is usually used, when one of an <code>ScAgent</code> wants to wait result of another one. There are next kind of <code>ScWaiter</code> objects:</p> <ul> <li><code>ScWaiter</code> locks run flow until simple event emits. You can see the list of these events in the C++ Events API.</li> <li><code>ScConditionWaiter</code> locks run flow until simple event emits and specified conditional check returns <code>true</code>. In other   words, this works like an <code>ScWaiter</code>, but returns to run flow if special condition function returns <code>true</code>. Condition   function receives 3 parameters (see C++ Events API for more details about them).</li> </ul>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#scwaiter","title":"ScWaiter","text":"<p>To generate object of this class, you should call <code>CreateEventWaiter</code> method from object of <code>ScAgentContext</code> class. You can't use constructors of <code>ScWaiter</code> class, because they are private.</p> <pre><code>...\n// Generate or find some sc-node and generate waiter to wait until \n// a sc-connector of the specified type is generated from or to this sc-node.\nauto waiter = context.CreateEventWaiter&lt;\n  ScEventAfterGenerateConnector&lt;ScType::ConstPermPosArc&gt;&gt;(\n    nodeAddr,\n    []() -&gt; void\n    {\n      // Provide logic here, that should be called at exactly the same time \n      // when waiter will start to wait for sc-event to occur.\n    });\n...\n</code></pre> <p>We recommend to use <code>auto</code> instead of full type of waiter. In provided example waiter has <code>std::shared_ptr&lt;ScEventWaiter&lt;ScEventAfterGenerateConnector&lt;ScType::ConstPermPosArc&gt;&gt;&gt;</code> type.</p>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#wait","title":"Wait","text":"<p>Call this method from object of <code>ScWaiter</code> class to wait for sc-event to occur.</p> <pre><code>bool const isWaited = waiter.Wait(200); // milliseconds.\n// Here `200` is maximum waiting time for the specified event to occur.\n// The event can happen faster than 200 milliseconds, then the result \n// will be obtained earlier too.\n</code></pre> <p>By default, this method has default wait time the equals to 5000 milliseconds.</p> <p>There is also a version of this method with three arguments. You can provide function that will be called after successful completion of waiting for the event to occur, and function that will be called after unsuccessful completion of waiting for the event to occur.</p> <pre><code>bool const isWaited = waiter.Wait(\n  200, \n  []() -&gt; void\n  {\n    // Handle if waiter waited for sc-event to occur.\n  },\n  []() -&gt; void\n  {\n    // Handle if waiter didn't wait for sc-event to occur.\n  });\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#setonwaitstartdelegate","title":"SetOnWaitStartDelegate","text":"<p>Use this method, when you want to change or provide function that should be called at exactly the same time when waiter will start to wait for sc-event to occur.</p> <pre><code>waiter.SetOnWaitStartDelegate([]() -&gt; void\n{\n  // Provide logic of this function here.\n});\n</code></pre>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#resolve","title":"Resolve","text":"<p>You can tell a waiter to stop waiting.</p> <pre><code>waiter.Resolve();\n</code></pre> <p>Then the <code>Wait</code> method will stop waiting for the specified event to occur.</p>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#scconditionwaiter","title":"ScConditionWaiter","text":"<p>This class represents waiter for condition to occur. To generate object of this class, you should call <code>CreateConditionWaiter</code> method from object of <code>ScAgentContext</code> class. You can't also use constructors of <code>ScConditionWaiter</code> class, because they are private.</p> <pre><code>...\n// Generate or find some sc-node and generate waiter to wait until \n// a sc-connector of the specified type is generated from or to this sc-node.\nauto waiter = context.GenerateConditionWaiter&lt;\n  ScEventAfterGenerateConnector&lt;ScType::ConstPermPosArc&gt;&gt;(\n    nodeAddr,\n    []() -&gt; void\n    {\n      // Provide logic here, that should be called at exactly the same time \n      // when waiter will start to wait for sc-event to occur.\n    },\n    [](ScEventAfterGenerateConnector&lt;ScType::ConstPermPosArc&gt;\n        const &amp; event) -&gt; bool\n    {\n      // Check here, that occurred sc-event is sc-event that this waiter \n      // has been waiting for.\n    };\n...\n</code></pre> <p><code>ScConditionWaiter</code> class inherits <code>ScWaiter</code> class. You can use all methods of <code>ScWaiter</code> class for objects of <code>ScConditionWaiter</code> class.</p>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#examples-of-using-waiters","title":"Examples of using waiters","text":"<p>There are some examples of usage for specified <code>ScWaiter</code> objects:</p> <ul> <li>Wait input sc-connector into sc-element with <code>nodeAddr</code>:</li> </ul> <pre><code>auto waiter = context.CreateEventWaiter&lt;\n  ScEventAfterGenerateIncomingArc&lt;ScType::ConstPermPosArc&gt;&gt;(nodeAddr);\nwaiter.Wait();\n</code></pre> <ul> <li>Wait input sc-connector into sc-element with <code>nodeAddr</code>, with condition:</li> </ul> <pre><code>auto const CheckCallback \n  = [](ScEventAfterGenerateIncomingArc&lt;\n    ScType::ConstPermPosArc&gt; const &amp; event)\n{\n  // Check condition here.\n  // Return true or false depending on condition.\n  return false;\n};\n\nauto waiter = context.CreateConditionWaiter&lt;\n  ScEventAfterGenerateIncomingArc&lt;\n    ScType::ConstPermPosArc&gt;&gt;(nodeAddr, CheckCallback);\n// Provide wait time value.\nwaiter.Wait(10000); // milliseconds.\n</code></pre> <p>Warning</p> <p>All constructors of these classes are private. You should C++ Agent context API to generate waiters.</p>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>Why can't I call the constructor of a waiter for sc-event?</li> <li>Is it possible to represent a waiter in a knowledge base to wait for sc-event to occur?</li> </ul>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#why-cant-i-call-the-constructor-of-a-waiter-for-sc-event","title":"Why can't I call the constructor of a waiter for sc-event?","text":"<p>First of all, it's not safe. We need more checks on input arguments because there are more of them. Secondly, it is correct from the OOP point of view. Constructors should not throw exceptions. Third, it is correct from the point of view of the architecture we use in the sc-machine. The <code>ScAgentContext</code> is a facade over all possible objects used by agents.</p>"},{"location":"sc-memory/api/cpp/extended/agents/waiters/#is-it-possible-to-represent-a-waiter-in-a-knowledge-base-to-wait-for-sc-event-to-occur","title":"Is it possible to represent a waiter in a knowledge base to wait for sc-event to occur?","text":"<p>Yes, you can make an agent that will do that.</p>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/","title":"C++ Simple Guide for Implementing Agent","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>All agents in C++ represent some classes in C++. To implement an agent in C++, you need to perform the following common steps:</p> <ol> <li>Write input (initial) construction and output (result) construction of your future agent in SC-code.</li> <li>Generate folder with source and header files for sc-agent implementation.</li> <li>Also you need write <code>CMakeLists.txt</code> file. We use cmake to build projects in C++.</li> <li>In header file, define a class in C++ for this agent and specifies in it at least class of actions that this agent performs and its program. In such class you can also specify primary initiation condition, initiation condition, and result condition.</li> <li>In source file, implement all declared methods of agent's class. You can also implement your own methods and use them in an agent program. You can use all C++ and OOP tools as much as possible. </li> <li>Generate file and implement class for keynodes used by implemented agent.</li> <li>Implement class for module for subscribing implemented agent.</li> <li>Write tests for implemented agent.</li> </ol> <p>Let's consider an example of implementing an agent to count power of the given set:</p>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#1-specify-inputs-and-outputs-of-your-future-agent","title":"1. Specify inputs and outputs of your future agent.","text":"<p>The initial construction of agent might look like this:</p> <pre><code>..action\n&lt;- action_calculate_set_power;\n&lt;- action_initiated;\n-&gt; rrel_1: ..some_set;;\n\n..some_set\n-&gt; ..element_1;\n-&gt; ..element_2;\n-&gt; ..element_3;;\n</code></pre> <p></p> <p>The result construction of agent might look like this:</p> <pre><code>..some_action\n=&gt; nrel_result: [*\n  ..some_set =&gt; nrel_set_power: [3];;\n*];;\n</code></pre> <p></p> <p>In addition to agents that initiate actions themselves and then perform these actions, there is a need to implement agents that perform actions initiated by other agents. For this class of agents, it is much easier to generate a initial initiation construction in the knowledge base. See C++ Actions API to learn more about actions.</p>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#2-generate-folder-with-source-and-header-files-for-agent-and-cmakeliststxt-file","title":"2. Generate folder with source and header files for agent and <code>CMakeLists.txt.</code> file.","text":"<p>You should get something like this structure:</p> <pre><code>set-agents-module/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 agent/\n\u2502   \u251c\u2500\u2500 sc_agent_calculate_set_power.hpp\n\u2502   \u2514\u2500\u2500 sc_agent_calculate_set_power.cpp\n</code></pre>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#3-write-cmakeliststxt-file","title":"3. Write <code>CMakeLists.txt</code> file.","text":"<p>The <code>CMakeLists.txt</code> file should describe a process of building your agent code. It should contain various instructions and parameters needed to compile and link agent source code to sc-machine libraries.</p> <p>CMakeLists.txt</p> <pre><code>file(GLOB SOURCES CONFIGURE_DEPENDS\n    \"*.cpp\" \"*.hpp\"\n    \"agent/*.cpp\" \"agent/*.hpp\"\n)\n\n# Generate and link your library with using libraries.\nadd_library(set-agents SHARED ${SOURCES})\ntarget_link_libraries(set-agents LINK_PUBLIC sc-machine::sc-memory)\ntarget_include_directories(set-agents PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})\n# Set output path for your extension `set-agents.so`. \n# Make sure that variable `SC_EXTENSIONS_DIRECTORY` has value.\nset_target_properties(set-agents \n    PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${SC_EXTENSIONS_DIRECTORY}\n)\n</code></pre> <p>Note</p> <p><code>LIBRARY_OUTPUT_DIRECTORY</code> property should be set only for libraries that represent modules with agents.</p> <p>Note</p> <p>You can set <code>CMAKE_OUTPUT_LIBRARY_DIRECTORY</code> instead of setting <code>LIBRARY_OUTPUT_DIRECTORY</code> property for each extension.</p> <p>Note</p> <p><code>SC_EXTENSIONS_DIRECTORY</code> variable should have path to the directory with extensions for the sc-machine. After building module with agent this directory path should be specified via <code>--extensions</code> when starting the sc-machine to load implemented module with agent.</p>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#4-define-a-class-in-c-for-this-agent-and-specifies-class-of-actions-that-this-agent-performs-and-its-program","title":"4. Define a class in C++ for this agent and specifies class of actions that this agent performs and its program.","text":"<p>sc_agent_calculate_set_power.hpp</p> <pre><code>#pragma once\n\n#include &lt;sc-memory/sc_agent.hpp&gt;\n\nclass ScAgentCalculateSetPower : public ScActionInitiatedAgent\n{\npublic:\n  ScAddr GetActionClass() const override;\n\n  ScResult DoProgram(ScAction &amp; action) override;\n};\n</code></pre> <p>An agent's class to be implemented must comply with the following requirements:</p> <ul> <li> <p>It must inherit one of the common classes for implementing agents: </p> </li> <li> <p><code>template &lt;class TScEvent&gt; class ScAgent</code>,</p> </li> <li>or <code>class ScActionInitiatedAgent</code>.</li> </ul> <p>The base class <code>ScAgent</code> contains API to implement agents that react to any sc-events. The base class <code>ScActionInitiatedAgent</code> inherits base class <code>ScAgent</code> and provides API to implement agents that react to sc-events of initiating sc-action.</p> <ul> <li> <p>It must override at least methods <code>ScAddr GetAction() const</code> and <code>ScResult DoProgram(ScActionInitiatedEvent const &amp; event, ScAction &amp; action)</code>.</p> </li> <li> <p>Override methods must be public. Otherwise, you won't be able to build your code because the sc-machine won't be able to call methods on your agent class.</p> </li> <li> <p>You can implement other methods in agent's class.</p> </li> </ul> <p>To learn more about opportunities and restrictions for implementing agents, see C++ Agents API.</p>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#5-implement-all-declared-methods-of-agents-class","title":"5. Implement all declared methods of agent's class.","text":"<p>sc_agent_calculate_set_power.cpp</p> <pre><code>#include \"sc_agent_calculate_set_power.hpp\"\n\n#include &lt;sc-memory/sc_memory_headers.hpp&gt;\n\nScAddr ScAgentCalculateSetPower::GetActionClass() const\n{\n  return m_context.SearchElementBySystemIdentifier(\"action_calculate_set_power\");\n  // You have to make sure that this class is in the knowledge base.\n}\n// You must specify valid action class. In other case, the agent can\u2019t be \n// subscribed to sc-event.\n\nScResult ScAgentCalculateSetPower::DoProgram(ScAction &amp; action)\n{\n  // `ScAction` class encapsulates information about sc-action. \n  // The provided action is action that the given agent performs right now. \n  // It belongs to class action_calculate_set_power`. \n  // Actions are copyable and movable. ScAction is inherited from ScAddr.\n\n  auto const &amp; [setAddr] = action.GetArguments&lt;1&gt;(); \n  // This method finds construction `action -&gt; rrel_1: setAddr`.\n  // Here the 1 is number of arguments which action must have. In step 1, \n  // we specified that an action should have a set as its the first and \n  // only one argument. But the one who calls this agent may not specify \n  // argument for the action. So we need to check that the action has argument. \n  if (!m_context.IsElement(setAddr))\n  {\n    m_logger.Error(\"Action does not have argument.\"); \n    // output: \"ScAgentCalculateSetPower: Action does not have argument.\"\n    return action.FinishWithError();\n  }\n  // There may be a situation where someone is trying to specify a number of \n  // arguments more then it is needed. You can also check this by specifying, \n  // for example, number 2 instead of number 1. But you don't always need \n  // to do this.\n\n  // To calculate power of the set, we can traverse all accessory constant \n  // positive permanents arcs from the set and count number of these arcs. \n  // But, in any problem, the presence of NON-factors must be considered, \n  // but this is omitted here.\n  uint32_t setPower = 0;\n  ScIterator3Ptr const it3 = m_context.CreateIterator3( \n    setAddr,\n    ScType::ConstPermPosArc,\n    ScType::ConstNode\n  );\n  while (it3-&gt;Next())\n    ++setPower;\n\n  ScAddr const &amp; setPowerAddr = m_context.GenerateLink(ScType::ConstNodeLink);\n  m_context.SetLinkContent(setPowerAddr, setPower);\n  ScAddr const &amp; arcCommonAddr \n    = m_context.GenerateConnector(ScType::ConstCommonArc, setAddr, setPowerAddr);\n  ScAddr const &amp; nrelSetPowerAddr \n    = m_context.SearchElementBySystemIdentifier(\"nrel_set_power\");\n  // You have to make sure that this non-role relation is in the knowledge base.\n  ScAddr const &amp; membershipArcAddr = m_context.GenerateConnector(\n    ScType::ConstPermPosArc, nrelSetPowerAddr, arcCommonAddr);\n\n  action.FormResult(\n    setAddr, arcCommonAddr, setPowerAddr, membershipArcAddr, nrelSetPowerAddr);\n  m_logger.Debug(\"Set power was counted: \", setPower, \".\");\n\n  // At the end of the agent's program, you must call one of three methods \n  // (`FinishSuccessfully`, `FinishUnsuccessfully`, `FinishWithError`) \n  // to indicate that the agent's performing of action is complete:\n  // - Method `FinishSuccessfully` indicates that action was performed \n  // by agent successfully (sets class `action_finished_successfully`). \n  // It means that the agent solved specified problem.\n  // - Method `FinishUnsuccessfully` indicates that action was performed \n  // by agent unsuccessfully (sets class `action_finished_unsuccessfully`). \n  // It means that the agent didn't solved specified problem.\n  // - Method `FinishWithError` indicates that action was performed by agent\n  // with error (sets class `action_finished_with_error`). \n  // It means that some incorrect situation was occurred in knowledge base.\n  // All these methods return objects of `ScResult` class. \n  // You can\u2019t generate object of ScResult via constructor, because it is private.\n  return action.FinishSuccessfully();\n}\n</code></pre>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#6-define-keynodes-for-implemented-agent-and-integrate-their-in-agent-program","title":"6. Define keynodes for implemented agent and integrate their in agent program.","text":"<p>For each agent, you can specify key sc-elements that this agent uses during the execution of its program. These key sc-elements are sc-elements that agent does not generate, but uses in the process of searching for or creating connections between entities in knowledge base. Key sc-elements are named keynodes. You can find these keynodes by its system identifiers (method <code>SearchElementBySystemIdentifier</code>) if they have such identifiers. Also, you can use class <code>ScKeynode</code> to define keynodes as static objects and use them in agents.</p> <pre><code>set-agents-module/\n \u251c\u2500\u2500 CMakeLists.txt\n \u251c\u2500\u2500 agent/\n \u2502   \u251c\u2500\u2500 sc_agent_calculate_set_power.hpp\n \u2502   \u2514\u2500\u2500 sc_agent_calculate_set_power.cpp\n+\u251c\u2500\u2500 keynodes/\n+\u2502   \u2514\u2500\u2500 sc_set_keynodes.hpp\n</code></pre> <p>CMakeLists.txt</p> <pre><code>file(GLOB SOURCES CONFIGURE_DEPENDS\n    \"*.cpp\" \"*.hpp\"\n    \"agent/*.cpp\" \"agent/*.hpp\"\n+   \"keynodes/*.hpp\"\n)\n</code></pre> <p>sc_set_keynodes.hpp</p> <pre><code>#include &lt;sc-memory/sc_keynodes.hpp&gt;\n\n// This class unites keynodes that used by agents of one module \n// (with one sense). You can implement hierarchies of keynodes.\nclass ScSetKeynodes : public ScKeynodes\n{\npublic:\n  static inline ScKeynode const action_calculate_set_power{\n    \"action_calculate_set_power\", ScType::ConstNodeClass};\n  static inline ScKeynode const nrel_set_power{\n    \"nrel_set_power\", ScType::ConstNodeNonRole};\n  // Here the first argument in constructor is system identifier of \n  // sc-keynode and the second argument is sc-type of this sc-keynode.\n  // If there is no sc-keynode with such system identifier in \n  // knowledge base, then the one with specified sc-type will be generated.\n  // You don't should specify type of sc-keynode here, be default it is \n  // `ScType::ConstNode`. But you sure that your code will use this \n  // keynode with type `ScType::ConstNode` correctly.\n};\n</code></pre> <p>Warning</p> <p>You can't specify sc-keynode with empty system identifier. It can be invalid.</p> <p>Warning</p> <p>All keynodes must be static objects. You can define keynodes as static objects everywhere (not only in classes).</p> <p><code>ScKeynodes</code> class is base class for all classes with keynodes. It contains core keynodes, that can be used in each agent. See C++ Keynodes API to learn more about keynodes.</p> <p>sc_agent_calculate_set_power.cpp</p> <pre><code>#include \"sc_agent_calculate_set_power.hpp\"\n\n#include &lt;sc-memory/sc_memory_headers.hpp&gt;\n\n+ #include \"keynodes/sc_set_keynodes.hpp\"\n\nScAddr ScAgentCalculateSetPower::GetActionClass() const\n{\n- return m_context.SearchElementBySystemIdentifier(\"action_calculate_set_power\");\n+ return ScSetKeynodes::action_calculate_set_power;\n}\n\nScResult ScAgentCalculateSetPower::DoProgram(ScAction &amp; action)\n{\n  ...\n\n- ScAddr const &amp; nrelSetPowerAddr \n-   = m_context.SearchElementBySystemIdentifier(\"nrel_set_power\");\n- ScAddr const &amp; membershipArcAddr = m_context.GenerateConnector(\n-   ScType::ConstPermPosArc, nrelSetPowerAddr, arcCommonAddr);\n+ ScAddr const &amp; membershipArcAddr = m_context.GenerateConnector(\n+   ScType::ConstPermPosArc, \n+   ScSetKeynodes::nrel_set_power, \n+   arcCommonAddr);\n- action.FormResult(\n-   setAddr, arcCommonAddr, setPowerAddr, membershipArcAddr, nrelSetPowerAddr);\n+ action.FormResult(\n+   setAddr, \n+   arcCommonAddr,\n+   setPowerAddr,\n+   membershipArcAddr, \n+   ScSetKeynodes::nrel_set_power);\n  ...\n}\n</code></pre>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#7-implement-module-class-to-subscribe-your-agent-to-specified-sc-event","title":"7. Implement module class to subscribe your agent to specified sc-event.","text":"<p>Someone should subscribe your agent to event. It can be other agent, or any code at all. You can implement class, that allows subscribing agents. This class is named sc-module. Each sc-module should subscribe agents with common sense.</p> <pre><code> set-agents-module/\n \u251c\u2500\u2500 CMakeLists.txt\n \u251c\u2500\u2500 agent/\n \u2502   \u251c\u2500\u2500 sc_agent_calculate_set_power.hpp\n \u2502   \u2514\u2500\u2500 sc_agent_calculate_set_power.cpp\n \u251c\u2500\u2500 keynodes/\n \u2502   \u2514\u2500\u2500 sc_set_keynodes.hpp\n+\u251c\u2500\u2500 sc_set_module.hpp\n+\u2514\u2500\u2500 sc_set_module.cpp\n</code></pre> <p>sc_set_module.hpp</p> <pre><code>#pragma once\n\n#include &lt;sc-memory/sc_module.hpp&gt;\n\nclass ScSetModule : public ScModule\n{\n  // Here class is empty. You doesn't need to implement any methods. \n  // `ScModule` class contains all necessary API to subscribe your \n  // agents as separate sc-module.\n};\n</code></pre> <p>sc_set_module.cpp</p> <pre><code>#include \"sc_set_module.hpp\"\n\n#include \"agent/sc_agent_calculate_set_power.hpp\"\n\nSC_MODULE_REGISTER(ScSetModule)\n  -&gt;Agent&lt;ScAgentCalculateSetPower&gt;();\n  // This method pointers to module that agent class `ScAgentCalculateSetPower`\n  // should be subscribed to sc-event of adding outgoing sc-arc from sc-element\n  // `action_initiated`. It is default parameter in this method if you want to\n  // subscribe agent class inherited from `ScActionInitiatedAgent`.\n\n// This way of subscribing agents makes it easier to write code. \n// You don't have to think about unsubscribing agents after \n// the system shutdown - your module will do it all by itself.\n</code></pre> <p>If you want to initialize something else in your module besides agents, you can override methods <code>Initialize(ScMemoryContext * context) override;</code> and <code>Shutdown(ScMemoryContext * context) override;</code>.</p> <p>sc_set_module.hpp</p> <pre><code>class ScSetModule : public ScModule\n{\n+ void Initialize(ScMemoryContext * context) override;\n+ void Shutdown(ScMemoryContext * context) override;\n};\n</code></pre> <p>sc_set_module.cpp</p> <pre><code>SC_MODULE_REGISTER(ScSetModule)\n  -&gt;Agent&lt;ScAgentCalculateSetPower&gt;();\n\n+ // This method will be called once. \n+ void ScSetModule::Initialize(ScMemoryContext * context)\n+ {\n+   // Implement initialize of your objects here.\n+ }\n+ // This method will be called once. \n+ void ScSetModule::Shutdown(ScMemoryContext * context)\n+ {\n+   // Implement shutdown of your objects here.\n+ }\n</code></pre> <p>You can find all modules functionality in the C++ Modules API.</p>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#8-write-tests-for-implemented-agent-check-agent-logic","title":"8. Write tests for implemented agent. Check agent logic.","text":"<p>To make sure how your agent works it is best to generate tests and cover in them all possible cases that your agent has to handle. For this, generate a separate file with test cases and implement them.</p> <pre><code> set-agents-module/\n \u251c\u2500\u2500 CMakeLists.txt\n \u251c\u2500\u2500 agent/\n \u2502   \u251c\u2500\u2500 sc_agent_calculate_set_power.hpp\n \u2502   \u2514\u2500\u2500 sc_agent_calculate_set_power.cpp\n \u251c\u2500\u2500 keynodes/\n \u2502   \u2514\u2500\u2500 sc_set_keynodes.hpp\n+\u251c\u2500\u2500 tests/\n+\u2502   \u2514\u2500\u2500 test_sc_agent_calculate_set_power.cpp\n \u251c\u2500\u2500 sc_set_module.hpp\n \u2514\u2500\u2500 sc_set_module.cpp\n</code></pre> <p>CMakeLists.txt</p> <pre><code>file(GLOB SOURCES CONFIGURE_DEPENDS\n    \"*.cpp\" \"*.hpp\"\n    \"agent/*.cpp\" \"agent/*.hpp\"\n    \"keynodes/*.hpp\"\n)\n\nadd_library(set-agents SHARED ${SOURCES})\ntarget_link_libraries(set-agents LINK_PUBLIC sc-machine::sc-memory)\ntarget_include_directories(set-agents PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})\nset_target_properties(set-agents\n    PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${SC_EXTENSIONS_DIRECTORY}\n)\n\n+file(GLOB TEST_SOURCES CONFIGURE_DEPENDS\n+    \"tests/*.cpp\"\n+)\n\n# Generate executable for tests.\n+add_executable(set-agents-tests ${TEST_SOURCES})\n+target_link_libraries(set-agents-tests\n+    LINK_PRIVATE GTest::gtest_main\n+    LINK_PRIVATE set-agents\n+)\n+target_include_directories(set-agents-tests\n+    PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}\n+)\n\n+gtest_discover_tests(set-agents-tests\n+    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/tests\n+)\n</code></pre> <p>test_sc_agent_calculate_set_power.cpp</p> <pre><code>#include &lt;sc-memory/test/sc_test.hpp&gt;\n\n#include &lt;sc-memory/sc_memory_headers.hpp&gt;\n\n#include \"agent/sc_agent_calculate_set_power.hpp\"\n#include \"keynodes/sc_set_keynodes.hpp\"\n\nusing AgentTest = ScMemoryTest;\n\nTEST_F(AgentTest, AgentCalculateSetPowerFinishedSuccessfully)\n{\n  // Generate action with class that your agent performs.\n  ScAction action \n    = m_ctx-&gt;GenerateAction(ScSetKeynodes::action_calculate_set_power);\n\n  // Generate set with two sc-elements.\n  ScSet set = m_ctx-&gt;GenerateSet();\n  ScAddr nodeAddr1 = m_ctx-&gt;GenerateNode(ScType::ConstNode);\n  ScAddr nodeAddr2 = m_ctx-&gt;GenerateNode(ScType::ConstNode);\n  set &lt;&lt; nodeAddr1 &lt;&lt; nodeAddr2;\n\n  // Set generated set as argument for action.\n  action.SetArgument(1, set);\n\n  // Initiate and wait while action will be finished.\n  action.InitiateAndWait();\n\n  // Check that action is finished successfully.\n  EXPECT_TRUE(action.IsFinishedSuccessfully());\n\n  // Get action result structure.\n  ScStructure structure = action.GetResult();\n  // Check that it has sc-elements.\n  EXPECT_FALSE(structure.IsEmpty());\n\n  // Check sc-constructions in result structure.\n  // Check the first three element construction.\n  ScIterator3Ptr it3 = m_ctx-&gt;CreateIterator3(\n    structure, ScType::ConstPermPosArc, ScType::ConstCommonArc);\n  EXPECT_TRUE(it3-&gt;Next());\n  ScAddr arcAddr = it3-&gt;Get(2);\n\n  auto [beginAddr, linkAddr]\n    = m_ctx-&gt;GetConnectorIncidentElements(arcAddr);\n  EXPECT_EQ(beginAddr, set);\n  EXPECT_TRUE(m_ctx-&gt;GetElementType(linkAddr).IsLink());\n\n  // Check that link content is 2.\n  uint32_t setPower;\n  EXPECT_TRUE(m_ctx-&gt;GetLinkContent(linkAddr, setPower));\n  EXPECT_EQ(setPower, 2u);\n\n  // Check the second three element construction.\n  it3 = m_ctx-&gt;CreateIterator3(\n    structure, ScType::ConstPermPosArc, ScType::ConstPermPosArc);\n  EXPECT_TRUE(it3-&gt;Next());\n  ScAddr arcAddr2 = it3-&gt;Get(2);\n\n  auto [relationAddr, targetArcAddr]\n    = m_ctx-&gt;GetConnectorIncidentElements(arcAddr2);\n  EXPECT_EQ(relationAddr, ScSetKeynodes::nrel_set_power);\n  EXPECT_EQ(targetArcAddr, arcAddr);\n}\n\n// Provide tests for unsuccessful and error situations.\n...\n</code></pre> <p>Note</p> <p>A good code is a code covered by tests.</p> <p><code>ScMemoryTest</code> class includes <code>m_ctx</code> that is object of <code>ScAgentContext</code> class. You can use it to work with sc-memory. See C++ Core API and C++ Agent context API to learn more about available methods for working with sc-memory.</p> <p>By default, the sc-machine repository contains configuration for launching tests in vscode. If you're developing on vscode, you can use this configuration and extension C++ TestMate for debugging code.</p>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>What is the correct way to write CMakeLists.txt? What is it? How to work with it?</li> <li>How to write tests correctly?</li> </ul>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#what-is-the-correct-way-to-write-cmakeliststxt-what-is-it-how-to-work-with-it","title":"What is the correct way to write CMakeLists.txt? What is it? How to work with it?","text":"<p>CMake is a widely used build system that facilitates the management of software builds, particularly for C++ projects. It allows developers to define the build process in a platform-independent manner, which can then be used to generate native build scripts for different environments. </p> <p>Use this guide to write CMakeLists.txt correctly.</p>"},{"location":"sc-memory/api/cpp/guides/simple_guide_for_implementing_agent/#how-to-write-tests-correctly","title":"How to write tests correctly?","text":"<p>We use GoogleTest to test our code. GoogleTest, often referred to as gtest, is a C++ testing framework developed by Google. It is used for writing and running unit tests in C++ projects. </p> <p>Use this guide to write good tests.</p>"},{"location":"sc-tools/kb_repo_file/","title":"Knowledge Base Repo File","text":""},{"location":"sc-tools/kb_repo_file/#knowledge-base-repository-file-repopath","title":"Knowledge base repository file - repo.path","text":"<p>For more complex KB setups (with several folders across the filesystem, for example), we've created an internal file format called <code>repo.path</code>. It allows you to specify all the folders that should be built into the KB or exclude some files or subfolders.</p>"},{"location":"sc-tools/kb_repo_file/#example","title":"Example","text":"<pre><code># Comments should start with hashtag as a first character in the line\n# Here you can specify path to one or several kb folders\n# Paths can be relative\n../ims.ostis.kb\n/full/path/to/kb\n../custom_kb\n# you can also exclude files or folders by adding a \"!\" symbol at the beginning of the line\n!../ims.ostis.kb/ims/ostis_tech\n!../custom_kb/test.scs\n</code></pre>"},{"location":"sc-tools/migrate_to_new_agent_api/","title":"Migrate to New Agent API","text":"<p>This is a program that translates sc-machine usage from old API into new API.</p> <p>Changed files include:</p> <ul> <li>cmake instructions that mention codegen;</li> <li>keynodes files with codegen;</li> <li>module files with codegen;</li> <li>agent files with codegen;</li> <li>in-line declarations of <code>SC_PROPERTY</code>;</li> <li><code>#include</code> statements with removed files;</li> <li>outdated <code>scAgentsCommon::CoreKeynodes</code> usages;</li> <li>outdated sc-events usages;</li> <li>deprecated methods usages;</li> <li>deprecated sc-types usages;</li> <li><code>utils::AgentUtils</code> usages;</li> <li>outdated agent registration and unregistration statements.</li> </ul> <p>Example of usage: <pre><code>./scripts/migration/migrate_to_new_agent_api.sh path/to/folder/with/source/files\n</code></pre></p> <p>Note</p> <p>Provide path to source files that does not contain subfolders with other projects. All files located at that path may be modified by this tool, even if they are from another project or don't have sc-machine usages.</p> <p>There may be a situation when this program won't be able to replace code correctly, these places in code are marked with <code>//todo(codegen-removal):</code></p>"},{"location":"sc-tools/migrate_to_new_agent_api/#if-you-want-to-run-this-program-you-will-need-java-with-version-8-or-higher-installed","title":"If you want to run this program you will need Java with version 8 or higher installed","text":""},{"location":"sc-tools/sc_builder/","title":"Knowledge Base Builder","text":"<p>Sc-builder tool allows to translate knowledge base sources into binaries. You can find it in a <code>/build/&lt;Release|Debug&gt;/bin</code> directory.</p> <pre><code>Usage:\n  ./build/&lt;Release|Debug&gt;/bin/sc-builder [options]\n\nRequired options:\n  --input|-i &lt;directory&gt;|&lt;repo&gt;.path       Specify the path to a directory containing knowledge base sources (.scs, .gwf) or a &lt;repo-name&gt;.path file.\n                                           The specified file should contain knowledge base directories (or sources) that should or shouldn't be translated into binaries.\n                                           This path can also be provided via the `input` option in the [sc-builder] group of the configuration file specified with --config|-c.\n                                           If both options are provided, the value from --input|-i takes precedence.\n  --output|-o &lt;directory&gt;                  Specify the path to the directory where the knowledge base binaries will be generated.\n                                           This path can also be provided via the `output` option in the [sc-builder] group of the configuration file provided via --config|-c.\n                                           If both options are provided, the value from --output|-o takes precedence.\n  --config|-c &lt;config-name&gt;.ini            Specify the path to a configuration file that can set input and output paths.\n                                           Use the `input` option in the [sc-builder] group for the input path, and the `output` option for the output path for ./build/&lt;Release|Debug&gt;/bin/sc-builder.\n\nAdditional Options:\n  --clear                                  Run sc-builder in a mode that overwrites existing knowledge base binaries.\n  --version                                Display the version of ./build/&lt;Release|Debug&gt;/bin/sc-builder.\n  --help                                   Display this help message.\n</code></pre> <p>Example of usage:</p> <pre><code>cd sc-machine\n./build/&lt;Release|Debug&gt;/bin/sc-builder -i ./kb -o ./kb.bin --clear -c ./sc-machine.ini\n</code></pre>"},{"location":"sc-tools/sc_machine/","title":"sc-machine Runner","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p> <p>Sc-machine is a sc-memory with opportunity to add modules consistent with the general sc-machine interface. All such modules are named extensions, must be shared libraries (with file extension <code>.so</code> or <code>.dylib</code>) and stored in common directory (by default it is <code>./build/&lt;Release|Debug&gt;/lib/extensions</code>). By default, sc-machine contains sc-server that allows to communicate with sc-memory through network. You can find <code>sc-machine</code> in a <code>/build/&lt;Release|Debug&gt;/bin</code> directory.</p> <pre><code>Usage:\n  ./build/&lt;Release|Debug&gt;/bin/sc-machine [options]\n\nRequired options:\n  --storage|-s &lt;directory&gt;                Provide a path to directory with knowledge base binaries. Knowledge base binaries should be generated by sc-builder binary.\n                                          This path can also be provided via the `storage` option in the [sc-memory] group of the configuration file specified with --config|-c.\n                                          If both options are provided, the value from --storage|-s takes precedence.\n  --config|-c &lt;config-name&gt;.ini           Provide a path to configuration file. If `storage` option is not provided as argument, then this file should contain `storage` option in `[sc-memory]` group.\n                                          Configuration file can be used to set additional (optional) options for ./build/&lt;Release|Debug&gt;/bin/sc-machine.\n\nOptions:\n  --extensions|-e &lt;directory&gt;             Provide a path to directories containing extensions. Extensions should represent compiled dynamic libraries of agent sc-modules.\n                                          This path can also be provided via the `extensions` option in the [sc-memory] group of the configuration file specified with --config|-c.\n                                          If both options are provided, the value from --extensions|-e takes precedence.\n  --clear                                 Run sc-memory in the mode when it overwrites existing knowledge base binaries.\n  --verbose|-v                            Shutdown sc-memory without dumping its state into knowledge base binaries.\n  --test|-t                               Test sc-memory state. If this flag is specified, sc-memory will be initialized and shutdown immediately.\n  --version                               Display version of ./build/&lt;Release|Debug&gt;/bin/sc-machine.\n  --help                                  Display this help message.\n\nEnvironment variables:\n  SC_SERVER_HOST                          Specifies a host for sc-server extension. If not set, the value defaults to the `host` option in the `[sc-server]` group of the configuration file.\n                                          If neither is specified, the default host is 127.0.0.1.\n  SC_SERVER_PORT                          Specifies a port for sc-server extension. If not set, the value defaults to the `port` option in the `[sc-server]` group of the configuration file.\n                                          If neither is specified, the default port is 8090.\n</code></pre> <p>Example of usage:</p> <pre><code>cd sc-machine\n./build/&lt;Release|Debug&gt;/bin/sc-machine -c ./sc-machine.ini\n</code></pre>"},{"location":"scs/sc_element_types/","title":"sc-element Types","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.10.0.</p>"},{"location":"scs/sc_element_types/#type-values","title":"Type values","text":"C++ name Decimal value Hex value ScType::Unknown 0 0x0 ScType::Node 1 0x1 ScType::Connector 16384 0x4000 ScType::CommonEdge 16388 0x4004 ScType::Arc 49152 0xC000 ScType::CommonArc 49160 0xC008 ScType::MembershipArc 49168 0xC010 ScType::Const 32 0x20 ScType::Var 64 0x40 ScType::ConstNode 33 0x21 ScType::VarNode 65 0x41 ScType::ConstConnector 16416 0x4020 ScType::VarConnector 16448 0x4040 ScType::ConstCommonEdge 16420 0x4024 ScType::VarCommonEdge 16452 0x4044 ScType::ConstArc 49184 0xC020 ScType::VarArc 49216 0xC040 ScType::ConstCommonArc 49192 0xC028 ScType::VarCommonArc 49224 0xC048 ScType::ConstMembershipArc 49200 0xC030 ScType::VarMembershipArc 49232 0xC050 ScType::PermArc 51216 0xC810 ScType::TempArc 50192 0xC410 ScType::ConstPermArc 51248 0xC830 ScType::VarPermArc 51280 0xC850 ScType::ConstTempArc 50224 0xC430 ScType::VarTempArc 50256 0xC450 ScType::ActualTempArc 54288 0xD410 ScType::InactualTempArc 58384 0xE410 ScType::ConstActualTempArc 54320 0xD430 ScType::VarActualTempArc 54352 0xD450 ScType::ConstInactualTempArc 58416 0xE430 ScType::VarInactualTempArc 58448 0xE450 ScType::PosArc 49296 0xC090 ScType::NegArc 49424 0xC110 ScType::FuzArc 49680 0xC210 ScType::ConstPosArc 49328 0xC0B0 ScType::VarPosArc 49360 0xC0D0 ScType::PermPosArc 51344 0xC890 ScType::TempPosArc 50320 0xC490 ScType::ActualTempPosArc 54416 0xD490 ScType::InactualTempPosArc 58512 0xE490 ScType::ConstPermPosArc 51376 0xC8B0 ScType::ConstTempPosArc 50352 0xC4B0 ScType::ConstActualTempPosArc 54448 0xD4B0 ScType::ConstInactualTempPosArc 58544 0xE4B0 ScType::VarPermPosArc 51408 0xC8D0 ScType::VarTempPosArc 50384 0xC4D0 ScType::VarActualTempPosArc 54480 0xD4D0 ScType::VarInactualTempPosArc 58576 0xE4D0 ScType::ConstNegArc 49456 0xC130 ScType::VarNegArc 49488 0xC150 ScType::PermNegArc 51472 0xC910 ScType::TempNegArc 50448 0xC510 ScType::ActualTempNegArc 54544 0xD510 ScType::InactualTempNegArc 58640 0xE510 ScType::ConstPermNegArc 51504 0xC930 ScType::ConstTempNegArc 50480 0xC530 ScType::ConstActualTempNegArc 54576 0xD530 ScType::ConstInactualTempNegArc 58672 0xE530 ScType::VarPermNegArc 51536 0xC950 ScType::VarTempNegArc 50512 0xC550 ScType::VarActualTempNegArc 54608 0xD550 ScType::VarInactualTempNegArc 58704 0xE550 ScType::ConstFuzArc 49712 0xC230 ScType::VarFuzArc 49744 0xC250 ScType::NodeLink 3 0x3 ScType::NodeLinkClass 2051 0x803 ScType::NodeTuple 129 0x81 ScType::NodeStructure 257 0x101 ScType::NodeRole 513 0x201 ScType::NodeNonRole 1025 0x401 ScType::NodeClass 2049 0x801 ScType::NodeSuperclass 4097 0x1001 ScType::NodeMaterial 8193 0x2001 ScType::ConstNodeLink 35 0x23 ScType::ConstNodeLinkClass 2083 0x823 ScType::ConstNodeTuple 161 0xA1 ScType::ConstNodeStructure 289 0x121 ScType::ConstNodeRole 545 0x221 ScType::ConstNodeNonRole 1057 0x421 ScType::ConstNodeClass 2081 0x821 ScType::ConstNodeSuperclass 4129 0x1021 ScType::ConstNodeMaterial 8225 0x2021 ScType::VarNodeLink 67 0x43 ScType::VarNodeLinkClass 2115 0x843 ScType::VarNodeTuple 193 0xC1 ScType::VarNodeStructure 321 0x141 ScType::VarNodeRole 577 0x241 ScType::VarNodeNonRole 1089 0x441 ScType::VarNodeClass 2113 0x841 ScType::VarNodeSuperclass 4161 0x1041 ScType::VarNodeMaterial 8257 0x2041"},{"location":"scs/sc_element_types/#scg-designations-and-scs-designations-of-sc-nodes","title":"sc.g-designations and sc.s-designations of sc-nodes","text":"C++ name SCg-code SCs-code ScType::Node Not specified sc_node ScType::ConstNode sc_node ScType::VarNode sc_node ScType::NodeLink Not specified sc_link ScType::NodeLinkClass Not specified sc_link_class ScType::NodeTuple Not specified sc_node_tuple ScType::NodeStructure Not specified sc_node_structure ScType::NodeRole Not specified sc_node_role_relation ScType::NodeNonRole Not specified sc_node_non_role_relation ScType::NodeClass Not specified sc_node_class ScType::NodeSuperclass Not specified sc_node_superclass ScType::NodeMaterial Not specified sc_node_material ScType::ConstNodeLink sc_link ScType::ConstNodeLinkClass Not specified sc_link_class ScType::ConstNodeTuple sc_node_tuple ScType::ConstNodeStructure sc_node_structure ScType::ConstNodeRole sc_node_role_relation ScType::ConstNodeNonRole sc_node_non_role_relation ScType::ConstNodeClass sc_node_class ScType::ConstNodeSuperclass Not specified sc_node_superclass ScType::ConstNodeMaterial sc_node_material ScType::VarNodeLink sc_link ScType::VarNodeLinkClass Not specified sc_link_class ScType::VarNodeTuple sc_node_tuple ScType::VarNodeStructure sc_node_structure ScType::VarNodeRole sc_node_role_relation ScType::VarNodeNonRole sc_node_non_role_relation ScType::VarNodeClass sc_node_class ScType::VarNodeSuperclass Not specified sc_node_superclass ScType::VarNodeMaterial sc_node_material"},{"location":"scs/sc_element_types/#scg-designations-and-scs-designations-of-sc-connectors","title":"sc.g-designations and sc.s-designations of sc-connectors","text":"C++ name SCg-code SCs-code ScType::CommonEdge Not specified <code>?&lt;=&gt;</code> ScType::CommonArc Not specified <code>?=&gt; or &lt;=?</code> ScType::MembershipArc Not specified <code>?.?&gt; or &lt;?.?</code> ScType::ConstCommonEdge <code>&lt;=&gt;</code> ScType::VarCommonEdge <code>_&lt;=&gt;</code> ScType::ConstCommonArc <code>=&gt; or &lt;=</code> ScType::VarCommonArc <code>_=&gt; or &lt;=_</code> ScType::ConstMembershipArc Not specified <code>.?&gt; or &lt;?.</code> ScType::VarMembershipArc Not specified <code>_.?&gt; or &lt;?._</code> ScType::PermArc Not specified <code>?-?&gt; or &lt;?-?</code> ScType::TempArc Not specified <code>?..?&gt; or &lt;?..?</code> ScType::ConstPermArc Not specified <code>-?&gt; or &lt;?-</code> ScType::VarPermArc Not specified <code>_-?&gt; or &lt;?-_</code> ScType::ConstTempArc Not specified <code>..?&gt; or &lt;?..</code> ScType::VarTempArc Not specified <code>_..?&gt; or &lt;?.._</code> ScType::ActualTempArc Not specified <code>?~?&gt; or &lt;?~?</code> ScType::InactualTempArc Not specified <code>?%?&gt; or &lt;?%?</code> ScType::ConstActualTempArc Not specified <code>~?&gt; or &lt;?~</code> ScType::VarActualTempArc Not specified <code>_~?&gt; or &lt;?~_</code> ScType::ConstInactualTempArc Not specified <code>%?&gt; or &lt;?%</code> ScType::VarInactualTempArc Not specified <code>_%?&gt; or &lt;?%_</code> ScType::PosArc Not specified <code>?.&gt; or &lt;.?</code> ScType::NegArc Not specified <code>?.|&gt; or &lt;|.?</code> ScType::FuzArc Not specified <code>?/&gt; or &lt;/?</code> ScType::ConstPosArc Not specified <code>.&gt; or &lt;.</code> ScType::VarPosArc Not specified <code>_.&gt; or &lt;._</code> ScType::PermPosArc Not specified <code>?-&gt; or &lt;-?</code> ScType::TempPosArc Not specified <code>?..&gt; or &lt;..?</code> ScType::ActualTempPosArc Not specified <code>?~&gt; or &lt;~?</code> ScType::InactualTempPosArc Not specified <code>?%&gt; or &lt;%?</code> ScType::ConstPermPosArc <code>-&gt; or &lt;-</code> ScType::ConstTempPosArc <code>..&gt; or &lt;..</code> ScType::ConstActualTempPosArc Not specified <code>~&gt; or &lt;~</code> ScType::ConstInactualTempPosArc Not specified <code>%&gt; or &lt;%</code> ScType::VarPermPosArc <code>_-&gt; or &lt;-_</code> ScType::VarTempPosArc <code>_..&gt; or &lt;.._</code> ScType::VarActualTempPosArc Not specified <code>_~&gt; or &lt;~_</code> ScType::VarInactualTempPosArc Not specified <code>_%&gt; or &lt;%_</code> ScType::ConstNegArc Not specified <code>?|&gt; or &lt;|?</code> ScType::VarNegArc Not specified <code>_?|&gt; or &lt;|?_</code> ScType::PermNegArc Not specified <code>?-|&gt; or &lt;|-?</code> ScType::TempNegArc Not specified <code>?..|&gt; or &lt;|..?</code> ScType::ActualTempNegArc Not specified <code>?~|&gt; or &lt;|~?</code> ScType::InactualTempNegArc Not specified <code>?%|&gt; or &lt;|%?</code> ScType::ConstPermNegArc <code>-|&gt; or &lt;|-</code> ScType::ConstTempNegArc <code>..|&gt; or &lt;|..</code> ScType::ConstActualTempNegArc Not specified <code>~|&gt; or &lt;|~</code> ScType::ConstInactualTempNegArc Not specified <code>%|&gt; or &lt;|%</code> ScType::VarPermNegArc <code>_-|&gt; or &lt;|-_</code> ScType::VarTempNegArc <code>_..|&gt; or &lt;|.._</code> ScType::VarActualTempNegArc Not specified <code>_~|&gt; or &lt;|~_</code> ScType::VarInactualTempNegArc Not specified <code>_%|&gt; or &lt;|%_</code> ScType::ConstFuzArc <code>/&gt; or &lt;/</code> ScType::VarFuzArc <code>_/&gt; or &lt;/_</code>"},{"location":"scs/sc_element_types/#rules-for-constructing-scs-designations-of-sc-connectors","title":"Rules for constructing sc.s-designations of sc-connectors","text":"<p>The rules for constructing sc.s-designations of membership sc-arcs follow the rule for constructing sc.s-designation of membership sc-arc of unspecified constancy, permanence and positivity -- <code>?.?&gt;</code>.</p> <ul> <li>The first sign <code>?</code> indicates that constancy is not specified for membership sc-arc. If membership sc-arc is constant, no sign is placed in the front of its sc.s-designation. If membership sc-arc is variable, the sign <code>_</code> is placed in the front of its sc.s-designation.</li> <li>The second sign <code>.</code> indicates that permanence is not specified for membership sc-arc. If membership sc-arc is permanent, the sign <code>-</code> is placed in the middle of its sc.s-designation. If membership sc-arc is temporal, the sign <code>..</code> is placed in the middle of its sc.s-designation. If membership sc-arc is actual temporal, the sign <code>~</code> is placed in the middle of its sc.s-designation. If membership sc-arc is inactual temporal, the sign <code>%</code> is placed in the middle of its sc.s-designation.</li> <li>The third sign <code>?</code> indicates that positivity is not specified for membership sc-arc. If membership sc-arc is positive, no sign is placed at the end of its sc.s-designation. If membership sc-arc is negative, the sign <code>|</code> is placed at the end of its sc.s-designation.</li> <li>The fourth sign <code>&gt;</code> indicates the direction of membership sc-arc.</li> </ul> <p>These rules also work for sc-arcs of fuzzy membership, but no permanence is specified for them in any way.</p> <p>The rules for constructing sc.s-designations of common sc-arcs follow the rule for constructing sc.s-designation of common sc-arc of unspecified constancy -- <code>?=&gt;</code>.</p> <ul> <li>The first sign <code>?</code> indicates that constancy is not specified for common sc-arc. If common sc-arc is constant, no sign is placed in the front of its sc.s-designation. If common sc-arc is variable, the sign <code>_</code> is placed in the front of its sc.s-designation.</li> <li>The second sign <code>=</code> indicates that sc-arc is not membership sc-arc, i.e. it has common subtype.</li> <li>The third sign <code>&gt;</code> indicates the direction of common sc-arc.</li> </ul> <p>For all reversed designations of sc-arcs, the construction rules work in reverse order.</p> <p>The rules for construction sc.s-designations of common sc-edge follow the rules for constructing sc.s-designations of common sc-arc. The difference is that the sign <code>&lt;</code> is added between the first and second signs. </p>"},{"location":"scs/scs/","title":"SCs-code","text":"<p>Note</p> <p>This is correct for only versions of sc-machine that &gt;= 0.9.0.</p>"},{"location":"scs/scs/#common","title":"Common","text":"<p>SCs-code - is a text representation of SC-code. Whole text consist of sentences, that separated by <code>;;</code> symbols.</p>"},{"location":"scs/scs/#comments","title":"Comments","text":"<p>You can use C-style comments in sc.s-text: <pre><code>// one line comment\nfruit -&gt; apple;\n/* Multiline\n * comment\n */\n</code></pre></p>"},{"location":"scs/scs/#link-to-files","title":"Link to files","text":"<p>To make an <code>sc-link</code> into specified file you can use special type identifier: <pre><code>\"file://&lt;file name&gt;\"\n</code></pre></p> <ul> <li><code>\"file://&lt;file name&gt;\"</code> - is a relative path to a file. According to a file, where it used;</li> <li><code>\"file:///&lt;file_name&gt;\"</code> - is an absolute path to a file.</li> </ul>"},{"location":"scs/scs/#names","title":"Names","text":"<p>There are some tricks with sc-node names:</p> <ul> <li><code>...</code> - is an unnamed sc-node;</li> <li><code>_&lt;node name&gt;</code> - all sc-node names, that starts with symbol <code>_</code> represents a variable type of sc-nodes.</li> </ul> <p>Objects identifier visibility. By default, all objects with name <code>x</code> are visible anywhere. After translating it into memory this object will have a system identifier equal to <code>x</code>. So if you use <code>x</code> in different scs files, then you designate the same object in them (would be the same element in a knowledge base).</p> <p>Sometimes you need to designate the same objects in different files, but do not generate a system identifier in memory for it. In this case you should to prefix it name with a <code>.</code> symbol. For example: <code>.x</code>.</p> <p>In case, when you need to make a named object just local for an scs file, then you should to use <code>..</code> prefix (example: <code>..x</code>).</p> <p>So a rule to build identifier is:</p> <pre><code>[visibility][variable]&lt;identifier&gt;\n</code></pre> <p>For example identifier <code>.._x</code> locally visible variable identifier.</p>"},{"location":"scs/scs/#aliases","title":"Aliases","text":"<p>You can use alias for any sc-element by using <code>=</code> operator. There are some examples:</p> <pre><code>@file_alias = \"file://...\";;\n@link_alias = [];;\n@element_alias = element_idtf;;\n@arc_alias = (c -&gt; b);;\n@alias_to_alias = @element_alias;;\n</code></pre> <p>Warning</p> <p>Aliases visible just in a file scope.  You should define alias before usage.</p> <p>Note</p> <p>SCs-code is split into levels. Each level allows to minimize number of string symbols to represent the same structures.</p>"},{"location":"scs/scs/#scs-code-level-1","title":"SCs-code level 1","text":"<p>SCs-code level 1 is a simple representation of SC-code. It represents SC-texts with just simple triples. Each triple contains <code>subject</code>, <code>predicate</code>, <code>object</code> that are split by <code>|</code> symbol. Line <code>sc_node#subject_identifier | sc_membership_arc#predicate_identifier | sc_node#object_identifier;;</code> is a sentence.</p> <p>Identifier of <code>subject</code>, <code>predicate</code>, <code>object</code> build with rule:</p> <pre><code>&lt;type&gt;#&lt;identifier&gt;\n</code></pre> <p>If object or subject is sc-link, then you should use the next one:</p> <pre><code>\"file://&lt;file name&gt;\"\n</code></pre> <p>Where <code>type</code> is an element type specification. It can be one of possible values:</p> <ul> <li><code>sc_node</code> - equal to ;</li> <li><code>sc_link</code> - equal to ;</li> <li><code>sc_common_edge</code> - equal to ;</li> <li><code>sc_common_arc</code> - equal to ;</li> <li><code>sc_membership_arc</code> - equal to ;</li> <li><code>sc_main_arc</code> - equal to .</li> </ul> <p>Examples</p> SCg construction Equal SCs-code level 1 text <pre>\n        <code>\n// append set of apples into fruit set\nsc_node#fruit\n  | sc_main_arc#..arc \n  | sc_node#apple;;\n// append set of bananas into fruit set\nsc_node#fruit\n  | sc_main_arc#..arc\n  | sc_node#banana;;\n        </code>\n      </pre> <pre>\n        <code>\nsc_node#apple \n  | sc_common_arc#..common_arc \n  | \"file://apple.png\";;\n/*append sc-arc from nrel_image relation into\n  sc-arc between apple set and it's image*/\nsc_node_non_role_relation#nrel_image \n  | sc_main_arc#..membership_arc \n  | sc_common_arc#..common_arc;;\n        </code>\n      </pre> <p>SCs-code level 1 allows you to represent any kind of SC-code construction. It's a low-level representation and commonly used as a transport format, that is very simple for parsing.</p>"},{"location":"scs/scs/#scs-code-level-2","title":"SCs-code level 2","text":"<p>This level of SCs-code add two new features:</p> <ul> <li>using of extended alphabet of sc-connectors;</li> <li>using of compound identifiers of sc-connectors.</li> </ul> <p>On this level you can make sentences by rule: <pre><code>&lt;element&gt; &lt;connector&gt; &lt;element&gt;;;\n</code></pre></p> <p>Where <code>&lt;connector&gt;</code> can be on of values:</p> SCs-code SCg-code <code>?&lt;=&gt;</code> Not specified <code>?=&gt; or &lt;=?</code> Not specified <code>?.?&gt; or &lt;?.?</code> Not specified <code>&lt;=&gt;</code> <code>_&lt;=&gt;</code> <code>=&gt; or &lt;=</code> <code>_=&gt; or &lt;=_</code> <code>??&gt; or &lt;??</code> Not specified <code>_??&gt; or &lt;??_</code> Not specified <code>?-?&gt; or &lt;?-?</code> Not specified <code>?..?&gt; or &lt;?..?</code> Not specified <code>-?&gt; or &lt;?-</code> Not specified <code>_-?&gt; or &lt;?-_</code> Not specified <code>..?&gt; or &lt;?..</code> Not specified <code>_..?&gt; or &lt;?.._</code> Not specified <code>?~?&gt; or &lt;?~?</code> Not specified <code>?%?&gt; or &lt;?%?</code> Not specified <code>~?&gt; or &lt;?~</code> Not specified <code>_~?&gt; or &lt;?~_</code> Not specified <code>%?&gt; or &lt;?%</code> Not specified <code>_%?&gt; or &lt;?%_</code> Not specified <code>??&gt; or &lt;??</code> Not specified <code>??|&gt; or &lt;|??</code> Not specified <code>?/&gt; or &lt;/?</code> Not specified <code>.&gt; or &lt;.</code> Not specified <code>_.&gt; or &lt;._</code> Not specified <code>?-&gt; or &lt;-?</code> Not specified <code>?..&gt; or &lt;..?</code> Not specified <code>?~&gt; or &lt;~?</code> Not specified <code>?%&gt; or &lt;%?</code> Not specified <code>-&gt; or &lt;-</code> <code>..&gt; or &lt;..</code> <code>~&gt; or &lt;~</code> Not specified <code>%&gt; or &lt;%</code> Not specified <code>_-&gt; or &lt;-_</code> <code>_..&gt; or &lt;.._</code> <code>_~&gt; or &lt;~_</code> Not specified <code>_%&gt; or &lt;%_</code> Not specified <code>?|&gt; or &lt;|?</code> Not specified <code>_?|&gt; or &lt;|?_</code> Not specified <code>?-|&gt; or &lt;|-?</code> Not specified <code>?..|&gt; or &lt;|..?</code> Not specified <code>?~|&gt; or &lt;|~?</code> Not specified <code>?%|&gt; or &lt;|%?</code> Not specified <code>-|&gt; or &lt;|-</code> <code>..|&gt; or &lt;|..</code> <code>~|&gt; or &lt;|~</code> Not specified <code>%|&gt; or &lt;|%</code> Not specified <code>_-|&gt; or &lt;|-_</code> <code>_..|&gt; or &lt;|.._</code> <code>_~|&gt; or &lt;|~_</code> Not specified <code>_%|&gt; or &lt;|%_</code> Not specified <code>/&gt; or &lt;/</code> <code>_/&gt; or &lt;/_</code> SCg construction Equal SCs-code level 2 text <pre>\n        <code>\nfruit -&gt; apple;;\n// backward direction\nbanana &lt;- fruit;;\n        </code>\n      </pre> <p>Compound identifier of a sc-connector builds as a sentence in SCs-code level 2, but without <code>;;</code> separator and inside brackets <code>()</code>: <code>(&lt;element&gt; &lt;connector&gt; &lt;element&gt;)</code>. So that allows to simplify usage of a sc-connector as a source or target of another one.</p> <p>Examples</p> SCg construction Equal SCs-code level 2 text <pre>\n        <code>\nnrel_image -&gt; (fruit =&gt; \"file://apple.png\");;\n        </code>\n      </pre> <pre>\n        <code>\nd -&gt; (c -&gt; (a -&gt; b));;\n        </code>\n      </pre> <pre>\n        <code>\n(a -&gt; b) -&gt; (c &lt;- d);;\n        </code>\n      </pre>"},{"location":"scs/scs/#scs-code-level-3","title":"SCs-code level 3","text":"<p>This level of SCs-code allows to minimize symbols to represent constructions like this one: </p> <pre><code>c -&gt; (a -&gt; b);;\n</code></pre> <p>To do that you should use sentence like this:</p> <pre><code>&lt;object&gt; &lt;connector&gt; &lt;attribute&gt;: &lt;object&gt;\n</code></pre> <p>For this example it would be like this:</p> <pre><code>a -&gt; c: b;;\n</code></pre> <p>In case, when outgoing sc-arc from <code>c</code> is a variable, then use <code>::</code> splitter instead of <code>:</code>:</p> <pre><code>a -&gt; c:: b;;\n</code></pre> <p>equal to:</p> <pre><code>c _-&gt; (a -&gt; b);;\n</code></pre> <p>Note</p> <p>You can use <code>:</code>, <code>::</code> just to replace <code>-&gt;</code> or <code>_-&gt;</code> sc-arcs.</p> <p>Examples</p> SCg construction Equal SCs-code level 3 text <pre>\n        <code>\napple =&gt; nrel_image: \"file://apple.png\";;\n        </code>\n      </pre> Note: it is possible to use any number of <code>:</code>, <code>::</code> in one sentence.        <pre>\n        <code>\na &lt;=&gt; c: d:: b;;\n        </code>\n      </pre>"},{"location":"scs/scs/#scs-code-level-4","title":"SCs-code level 4","text":"<p>This level of SCs-code allows to combine many sentences with one element into one. For that purposes used ';' symbol. So if we have some sentences like:</p> <pre><code>x -&gt; y;;\nx &lt;- z;;\nx =&gt; h: r;;\n</code></pre> <p>Then using SCs level 4 we can write them like this:</p> <pre><code>x \n-&gt; y;\n&lt;- z;\n=&gt; h: r;;\n</code></pre> <p>In other words, this level of SCs-code allows to use source element one time.</p> <p>Examples</p> SCg-code Equal SCs-code level 4 text <pre>\n        <code>\nfruit \n-&gt; apple;\n-&gt; banana;;\n        </code>\n      </pre> <pre>\n        <code>\na\n-&gt; c: d: b;\n-&gt; e;\n-&gt; g: f;;\n        </code>\n      </pre>"},{"location":"scs/scs/#scs-code-level-5","title":"SCs-code level 5","text":"<p>Internal sentences added to SCs-code on this level. They are wrapped by <code>(* ... *)</code> brackets. This type of sentences allow to describe connections of an element inplace. You can place these internal sentences after <code>object</code> element in triple (<code>subject -&gt; object (* ... *);;</code>), but before <code>;;</code> separator. You can use level <code>2-4</code> sentences inside this one. But there is a just one rule: </p> <p>You doesn't need to specify start element for each sentence. Because object (for which internal sentence builds)  is going to be a subject for all internal sentences </p> <p>Look at the examples, to understand how it works:</p> SCs-code level 2-4 SCs-code level 5 Description <pre>\n        <code>\nset -&gt; attr: item;;\nitem -&gt; subitem;;\n          </code>\n        </pre> <pre>\n        <code>\nset\n-&gt; attr: item \n(*\n  -&gt; subitem;;\n*);;\n        </code>\n      </pre>      This is a simple example, that allow to make an sc.s-text more readable and useful. In this case text has a sublevels, that allows     to read it faster.      <pre>\n        <code>\nset -&gt; attr: item;;\nitem -&gt; subitem;;\nitem -&gt; attr2: subitem2;;\n        </code>\n      </pre> <pre>\n        <code>\nset \n-&gt; attr: item\n(* \n  -&gt; subitem;;\n  -&gt; attr2: subitem2;;\n*);;\n        </code>\n      </pre>      You can use as much as you need sentences in <code>(* *)</code>, but all of them should be separated by <code>;;</code>.      <pre>\n        <code>\n@en_idtf = [sc-element];;\n@ru_idtf = [sc-\u044d\u043b\u0435\u043c\u0435\u043d\u0442];;\n@en_idtf &lt;- lang_en;;\n@ru_idtf &lt;- lang_ru;;\nsc_element \n=&gt; nrel_main_idtf: \n  @en_idtf;\n  @ru_idtf;;\n        </code>\n      </pre> <pre>\n        <code>\nsc_element\n=&gt; nrel_main_idtf:\n  [sc-element]\n  (* &lt;- lang_en;; *);\n=&gt; nrel_main_idtf:\n  [sc-\u044d\u043b\u0435\u043c\u0435\u043d\u0442]\n  (* &lt;- lang_ru;; *);;\n        </code>\n      </pre>      This type of syntax is very useful, when you need to specify some meta information on <code>sc-link</code>'s.     In this example we specify two main identifiers for a <code>sc_element</code>. One is an english (<code>lang_en</code>) identifier,     another one is a russian (<code>lang_ru</code>)."},{"location":"scs/scs/#scs-code-level-6","title":"SCs-code level 6","text":"<p>There are some new complex aliases, that adds by this level of SCs-code:</p> <ul> <li><code>[...]</code> - this is a short representation of <code>sc-link</code> with a content. You can create <code>sc-link</code> with a specified content by using this feature. There are all possible cases:</li> </ul> Type Description Example `string` You can write any string that you wish inside <code>[ ... ]</code> alias <pre>\n          <code>\nx -&gt; [any string];;\nx -&gt; [this is a \n multiline text];;\n          </code>\n        </pre> `number` You can specify a number as a binary data. To do that, just use syntax:         <code>[^\"type: value\"]</code>. Where <code>type</code> is a one of possible types:         <ul> <li><code>int</code> - signed integer value (32 bit). You can also use such types for an integer:             <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> </li> <li><code>uint</code> - unsigned integer value (32 bit). You can also use such type for an unsigned integer:             <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> </li> <li><code>float</code> - 32-bit float value</li> <li><code>double</code> - 64-bit float value</li> </ul> <pre><code>\nx -&gt; [^\"float: 435.2346\"];;\nx -&gt; [^\"int8: 7\"];;\nx -&gt; [^\"uint: 781236\"];;\n        </code></pre> <ul> <li><code>[* ... *]</code> this is a short representation of <code>sc-structure</code>. You can use just sc.s-text inside these brackets.   So these brackets will designate an <code>sc-structure</code> (<code>sc-node</code> with a type <code>sc_node_structure</code>). All elements inside   brackets will have incoming sc-arc (type <code>sc_main_arc</code>) from that <code>sc-node</code>.  SCs-code level 2-5 SCs-code level 6 <pre><code>\n@arc_alias = (set -&gt; item);;\nstructure -&gt; set; item; @arc_alias;;\n        </code></pre> <pre>\n          <code>\n@structure = [* set -&gt; item;; *];;\n          </code>\n        </pre> </li> </ul> <p>That's important</p> <p>S\u0441.s-text inside <code>[* ... *]</code> has the same rules and semantic, like it will be in a separated file</p> <ul> <li><code>{ ... }</code> is a short representation of non-oriented set. This feature allow to make sets in very fast way.   Syntax looks like:</li> </ul> <pre><code>@non_oriented_set = {\n  element1;\n  attr2: element2;\n  ...\n  last_element // no semicolon after last element\n};;\n</code></pre> <ul> <li><code>&lt; ... &gt;</code> is a short representation of oriented set. This feature allow to make sets in very fast way.   Syntax looks like:</li> </ul> <pre><code>@oriented_set = &lt;\n  element1;\n  attr2: element2;\n  ...\n  last_element // no semicolon after last element\n&gt;;;\n</code></pre> SCs-code level 2-5 SCs-code level 6 Comments <pre>\n        <code>\nset\n&lt;- sc_node_tuple;\n-&gt; element1;\n-&gt; attr2: element2;\n-&gt; element3;;\n        </code>\n      </pre> <pre>\n        <code>\n@set = {\n  element1;\n  attr2: element2;\n  element3 // no semicolon\n};;\n        </code>\n      </pre> Using set looks much cleaner. You can use even attributes on it. <pre>\n        <code>\nmeta_set \n&lt;- sc_node_tuple;\n-&gt; set1;\n-&gt; set2;;\n\nset1\n&lt;- sc_node_tuple;\n-&gt; element1;\n-&gt; attr2: element2;\n-&gt; element3;;\n\nset2\n&lt;- sc_node_tuple;\n-&gt; element5;\n-&gt; element6;;\n\nset3\n&lt;- sc_node_tuple;\n-&gt; element10;;\n\nelement \n=&gt; nrel_relation: set3;;\n        </code>\n      </pre> <pre>\n        <code>\n@meta_set = {\n  {\n    element1;\n    attr2: element2;\n    element3\n  };\n  {\n    element5;\n    element6\n  }\n};;\n\nelement \n=&gt; nrel_relation:\n{\n  element10\n};;\n        </code>\n      </pre> You can use set alias inside any other complex aliases and triples. <pre>\n        <code>\nset\n&lt;- sc_node_tuple;;\n\n@first_arc = (set -&gt; rrel_1: element1);;\n@second_arc = (set -&gt; element2);;\n\nnrel_basic_sequence\n-&gt; (@first_arc =&gt; @second_arc);;\n        </code>\n      </pre> <pre>\n        <code>\n@set = &lt;\n  element1;\n  element2 // no semicolon\n&gt;;;\n        </code>\n      </pre> Using set looks much cleaner. You can use even attributes on it."},{"location":"scs/scs/#keynodes","title":"Keynodes","text":"<p>There are a list of element type keynodes, that can be used to specify type of sc-element:</p> Keynode Equal sc-type Possible sc.g-elements sc_node ScType::Node sc_link ScType::ConstNodeLink sc_common_edge ScType::ConstCommonEdge sc_common_arc ScType::ConstCommonArc sc_membership_arc ScType::MembershipArc sc_main_arc ScType::ConstPermPosArc sc_node_tuple ScType::NodeTuple sc_node_structure ScType::NodeStructure sc_node_role_relation ScType::NodeRole sc_node_non_role_relation ScType::NodeNonRole sc_node_class ScType::NodeClass sc_node_superclass ScType::NodeSuperclass Not specified sc_node_material ScType::NodeMaterial <p>There is an example of usage:</p> SCs-code Equal SCg-code <pre>\na &lt;- sc_node_class;;\na _-&gt; _b;;\n_b &lt;- sc_node_material;;\n      </pre> <pre>\n_x =&gt; nrel_y: t;;\nnrel_y &lt;- sc_node_non_role_relation;;\n      </pre>"},{"location":"scs/scs/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<ul> <li>What SCs-code level is recommended to use?</li> <li>Can I combine different levels in one SCs file?</li> <li>What is the difference between <code>set -&gt; a; -&gt; b; -&gt; c;;</code> and <code>set -&gt; a; b; c;;</code>?</li> </ul>"},{"location":"scs/scs/#what-scs-code-level-is-recommended-to-use","title":"What SCs-code level is recommended to use?","text":"<p>The first levels of SCs-code have minimal syntax, so it is simple to handle sc.s-text of these levels. But the last levels of SCs-code allow you to make sc.s-text more compact, but these levels of SCs-code have more complicated syntax.</p>"},{"location":"scs/scs/#can-i-combine-different-levels-in-one-scs-file","title":"Can I combine different levels in one SCs file?","text":"<p>All levels of SCs-code can be combined. Usually it is useful to use 4-6 levels if you use 2-3 levels.</p>"},{"location":"scs/scs/#what-is-the-difference-between-set-a-b-c-and-set-a-b-c","title":"What is the difference between <code>set -&gt; a; -&gt; b; -&gt; c;;</code> and <code>set -&gt; a; b; c;;</code>?","text":"<p>These sc.s-texts are identical. The second sc.s-text is just short version of the first sc.s-text, it allows to not duplicate sc.s-connectors between sc.s-elements.</p>"}]}