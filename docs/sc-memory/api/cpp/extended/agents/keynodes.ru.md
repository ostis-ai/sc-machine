# **C++ Keynodes API**

!!! примечание
    Это верно только для версий sc-machine >= 0.10.0.
--- 

**C++ Keynodes API** позволяет разработчикам работать с ключевыми элементами графа знаний, которые представляют важные сущности. В этой документации описывается, как создавать, извлекать ключевые узлы и манипулировать ими в sc-machine.

Ключевой узел — ключевой sc-элемент, используемый некоторой программой (агентом) в процессе ее работы. Обычно ключевыми узлами могут быть классы и отношения, представляющие собой sc-элементы, которые программа (агент) использует для поиска конструкций в sc-памяти или генерации новых. Однако ключевыми узлами могут быть любые sc-элементы (включая коннекторы между sc-элементами).

!!! примечание
    Чтобы подключить этот API, укажите #include <sc-memory/sc_keynodes.hpp> в исходном файле hpp.

## **ScKeynode**

Это базовый класс для всех ключевых узлов. Используйте его для создания ключевых узлов в классе `ScKeynodes` для использования в программах агентов.

```cpp
#include <sc-memory/sc_keynodes.hpp>

static ScKeynode const my_keynode_class{
    "my_keynode_class", ScType::ConstNodeClass};
```

!!! примечание
    Мы рекомендуем называть ключевой узел системным идентификатором ключевого элемента.

!!! примечание
    Ключевые узлы могут определяться не только в классах, унаследованных от класса `ScKeynodes`. Вы можете определить их как статические объекты где угодно.

!!! предупреждение
    Используйте этот класс только для объявлений статических объектов.

Кроме того, вы можете преобразовать любой ключевой узел в строку.

```cpp
std::string const & systemIdtf = my_keynode_class;
```

Это может быть полезно, если вы хотите регистрировать системные идентификаторы ключевых узлов.

## **ScTemplateKeynode**

Это базовый класс для создания sc-шаблонов в качестве ключевых узлов. Этот класс полезен, когда вы хотите использовать программно представленный sc-шаблон в разных местах кода или когда вы не хотите указывать sc-шаблон в базе знаний и использовать его в `ScAgentBuilder`.

```cpp
#include <sc-memory/sc_keynodes.hpp>

static ScTemplateKeynode const & my_agent_initiation_condition =
  ScTemplateKeynode("my_agent_initiation_condition")
     .Triple(
        ScKeynodes::action_initiated,
        ScType::VarPermPosArc,
        ScType::VarNode >> "_action")
     .Triple(
        MyKeynodes::my_action,
        ScType::VarPermPosArc,
        "_action");
```

!!! примечание
    Объекты этого класса можно использовать как `ScTemplate` и `ScAddr`.

!!! предупреждение
    Используйте этот класс только для объявлений статических объектов.

### **ScKeynodes**

Этот класс является базовым классом для объявления ключевых узлов. Это что-то вроде пространства имен. Используйте его как базовый класс для собственных ключевых узлов. Этот класс уже содержит часто используемые ключевые узлы. Используйте их в своем коде.

```cpp
// файл my_keynodes.hpp:
#pragma once

#include <sc-memory/sc_keynodes.hpp>

class MyKeynodes : public ScKeynodes
{
public:
  static inline ScKeynode const my_keynode_class_a{
    "my_keynode_class_a", ScType::ConstNodeClass};
  static inline ScKeynode const my_keynode_relation_b{
    "my_keynode_relation_b", ScType::ConstNodeNonRole};
};
```

Вам не обязательно наследовать класс ScKeynodes, вы можете сделать это следующим образом.

```cpp
// файл my_keynodes.hpp:
#pragma once

#include <sc-memory/sc_keynodes.hpp>

class MyKeynodes
{
public:
  static inline ScKeynode const my_keynode_class_a{
    "my_keynode_class_a", ScType::ConstNodeClass};
  static inline ScKeynode const my_keynode_relation_b{
    "my_keynode_relation_b", ScType::ConstNodeNonRole};
};
```

--- 

## **Часто Задаваемые Вопросы**

<!-- no toc -->
- [Можно ли генерировать одни и те же ключевые узлы в разных модулях, но с разными типами?](#is-it-possible-to-generate-the-same-keynodes-in-different-modules-but-with-different-types)
- [Можно ли создать ключевой узел внутри класса агента?](#is-it-possible-to-generate-a-keynode-inside-an-agent-class)
- [Когда инициализируются ключевые узлы?](#when-are-keynodes-initialized)

### **IМожно ли генерировать одни и те же ключевые узлы в разных модулях, но с разными типами?**

Вы можете создавать одни и те же ключевые узлы в разных модулях. Главное, чтобы не было конфликта имен в классах, в которых эти кейноды объявлены. Однако нельзя создавать одинаковые ключевые узлы в разных модулях с разными типами, например, как структура и как класс. Все sc-элементы с одинаковыми системными идентификаторами автоматически склеиваются.

### **Можно ли создать ключевой узел внутри класса агента?**

Да, алгоритм будет точно таким же, если бы вы сгенерировали этот ключевой узел в отдельном специальном классе для ключевых узлов.

### **Когда инициализируются ключевые узлы?**

Они инициализируются во время инициализации sc-памяти. Не используйте их до инициализации памяти.
