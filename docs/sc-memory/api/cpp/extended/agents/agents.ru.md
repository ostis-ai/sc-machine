# **C++ Agents API**

!!! примечание
    Это верно только для версий sc-machine, которые >= 0.10.0.
--- 

Этот раздел содержит подробную документацию по основным функциональным возможностям C++ Agents API, которая охватывает создание и управление агентами. В нем описывается, как описывать и создавать экземпляров агентов, а также интегрировать их в системы.

!!! примечание
    Чтобы подключить этот API, укажите "#include <sc-memory/sc_agent.hpp>` в вашем исходном файле hpp.

## **Быстрый старт**

Ознакомьтесь с нашим [Простым руководством](../../guides/simple_guide_for_implementing_agent.md)  о том, как быстро разработать агент на C++ с нуля.

## **Что такое агентно-ориентированная модель?**

Sc-machine реализует агентно-управляемую модель для управления знаниями, получаемыми при обработке данных. 
В агентно-ориентированной модели агенты обмениваются сообщениями только через общую память, добавление нового агента
или удаление одного или нескольких существующих агентов не приводит к изменениям в других агентах, инициализация
агентов децентрализована и чаще всего независима друг от друга.

Все агенты в рамках технологии OSTIS делятся на два класса: платформенно-независимые, т.е. реализуемые только
с помощью SC-кода, и платформенно-зависимые, реализуемые с помощью sc-machine API. Независимые от платформы агенты 
могут быть реализованы с помощью языка SCP, который интерпретируется [**scp-machine**](https://github.com/ostis-ai/scp-machine). Sc-machine представляет собой мощный, 
но простой API для разработки и поддержки платформозависимых агентов на C++.


Все агенты реагируют на появление событий в sc-памяти (sc-events). То есть агент вызывается неявно при возникновении 
sc-события, на тип которого этот агент уже подписан. Знание о том, какое sc-событие вызовет вызов этого агента 
(пробуждение этого агента), называется условием первичной инициализации. После пробуждения агент проверяет наличие 
у него условия полной инициализации. Если условие полной инициализации успешно выполнено, агент инициирует действие 
некоторого класса и начинает выполнять его с помощью программы агента 
(подробнее о действиях см. в разделе [**C++ Actions API**](actions.md)).
После выполнения своей программы агент может проверить, есть ли результат.


## **Что представляет собой спецификация агента?**

Все сведения об агенте: *первичное условие запуска*, *класс действий*, которые он может выполнять, *условие 
запуска* и *условие результата* - являются частью **спецификации агента**. Эта спецификация может быть 
представлена либо в базе знаний с использованием SC-кода, либо программно с использованием sc-machine API.


Давайте опишем спецификацию абстрактного sc-агента с вычислительной мощностью указанного набора в SCs-коде (SCg-code). 
Абстрактный sc-агент - это класс функционально эквивалентных агентов, разные экземпляры которых
могут быть реализованы разными способами. Каждый абстрактный sc-агент имеет соответствующую ему спецификацию.

```scs
// Abstract sc-agent
agent_calculate_set_power
<- abstract_sc_agent;
=> nrel_primary_initiation_condition: 
    // Класс sc-события и sc-элемента для прослушивания (подписки)
    (sc_event_after_generate_outgoing_arc => action_initiated); 
=> nrel_sc_agent_action_class:
    // Класс действий, которые должен выполнить агент
    action_calculate_set_power; 
=> nrel_initiation_condition_and_result: 
    (..agent_calculate_set_power_initiation_condition 
        => ..agent_calculate_set_power_result_condition);
<= nrel_sc_agent_key_sc_elements:
// Набор ключевых sc-элементов, используемых данным агентом
{
    action_initiated;
    action_calculate_set_power;
    concept_set;
    nrel_set_power
};
=> nrel_inclusion: 
    // Экземпляр абстрактного sc-агента; конкретная реализация агента на C++
    agent_calculate_set_power_implementation 
    (*
        <- platform_dependent_abstract_sc_agent;;
        // Набор ссылок с путями к исходным текстам программ-агентов
        <= nrel_sc_agent_program: 
        {
            [github.com/path/to/agent/sources] 
            (* => nrel_format: format_github_source_link;; *)
        };; 
    *);;

// Состояние полной инициации агента
..agent_calculate_set_power_initiation_condition
= [*
    action_calculate_set_power _-> .._action;;
    action_initiated _-> .._action;;
    .._action _-> rrel_1:: .._set;;
    concept_set _-> .._set;;
*];; 
// Агент должен проверить с помощью этого шаблона, что инициируемое действие является экземпляром 
// class `action_calculate_set_power` и что у него есть аргумент.

// Полное результативное состояние агента
..agent_calculate_set_power_result_condition
= [*
    .._set _=> nrel_set_power:: _[];;
*];;
// Агент должен проверить с помощью этого шаблона, содержит ли результат действия 
// sc-конструкцию, сгенерированную после выполнения действия.

```

<image src="../images/agents/agent_calculate_set_power_specification.png"></image>

## **Каковы способы предоставления спецификации агента?**

API sc-machine предоставляет два типа функциональных возможностей для реализации агента на C++:

* когда спецификация агента представлена в базе знаний и используется агентом;
* когда спецификация агента представлена в коде на C++ и также используется агентом.

В обоих случаях спецификация агента может быть статической, динамической или полудинамической.

1. **Спецификация статического агента** — это спецификация, предоставляемая извне в классе
агента (путем переопределения общедоступные средств получения (геттеров)). Эта спецификация не сохраняется в базе знаний, поскольку изменения
 в базе знаний не могут автоматически изменить код, указанный пользователем. Чтобы предоставить этот тип спецификации агента,
 вы можете использовать переопределение общедоступных геттеров в классе вашего агента (см. документацию ниже).

2. **Динамическая спецификация агента** - это спецификация, предоставленная в базе знаний или изначально содержащаяся в коде,
 но автоматически сохраняемая в базе знаний. После этого первый агент изменяет спецификацию второго агента, а второй агент
 использует измененную спецификацию. Чтобы реализовать этот тип спецификации, используйте API класса
 ScModule и API класса ScAgentBuilder (смотреть [**C++ Modules**](modules.md)).

3. **Полудинамическая спецификация агента** может быть получена, когда спецификация предоставляется в базе
 знаний или изначально содержится в коде и добавляется извне (через переопределяющие общедоступные средства получения(геттеры)).

Статическая спецификация агента может быть полезна, если вы впервые внедряете агент на C++ или хотите свести к минимуму количество поисков в базе знаний. Динамическая спецификация агента предоставляет возможность анализировать и изменять эту спецификацию другими агентами. Полудинамическая спецификация может быть полезна, если вы хотите изменить некоторые части этой спецификации, но при этом хотите, чтобы вызовы агента выполнялись быстро.

---

## **Спецификация статического агента**

Здесь будет рассмотрен API для реализации агента со статической спецификацией. Это самый простой вариант реализации, который вам будет понятен. Чтобы узнать о динамической спецификации агента, смотрите [**C++ Modules API**](modules.md).

Существует два основных класса, которые вы можете использовать для реализации агента: `ScAgent` и `ScActionInitiatedAgent`.

### **ScAgent**

В C++ существует базовый класс для агентов. Этот класс предоставляет реализованные методы для извлечения элементов спецификации агента из базы знаний. Все эти методы могут быть переопределены в вашем классе агента.

Вы должны различать абстрактный sc-агент как некоторый класс функционально эквивалентных sc-агентов, описанных в базе знаний, и `ScAgent` как класс C++, который реализует API для работы с абстрактными sc-агентами в базе знаний.

Этот класс можно использовать для всех типов платформозависимых агентов. Агенты этого класса реагируют на события в базе знаний, проверяют условие полной инициализации. Если проверка прошла успешно, генерируют, инициируют и выполняют действие. После этого они проверяют условие полной результативности. Пример использования этого класса представлен ниже.

```cpp
// файл my_agent.hpp
#pragma once

#include <sc-memory/sc_agent.hpp>

// Наследуйте свой класс agent от класса `ScAgent` и укажите аргумент шаблона 
// как класс sc-события. Здесь `ScEventAfterGenerateIncomingArc<
// ScType::ConstPermPosArc>` - это тип события, на которое реагирует данный агент.

class MyAgent : public ScAgent<
  ScEventAfterGenerateIncomingArc<ScType::ConstPermPosArc>>
{
public:
  // Здесь вы должны указать класс действий, которые выполняет данный агент. 
 // Здесь `GetActionClass` переопределяет `GetActionClass` 
 // в классе `ScAgent`. Это переопределение обязательно.
  ScAddr GetActionClass() const override;
 // Здесь вы должны реализовать программу данного агента. 
 // Это переопределение обязательно.
  ScResult DoProgram(
    ScEventAfterGenerateIncomingArc<
      ScType::ConstPermPosArc> const & event, 
    ScAction & action) override;

  // Другие методы, определяемые пользователем.
};
```

Вы не можете переопределить `DoProgram` без аргумента sc-event. Можно переопределить один из этих методов.

```cpp
// файл my_agent.hpp
#pragma once

#include <sc-memory/sc_agent.hpp>

class MyAgent : public ScAgent<
  ScEventAfterGenerateIncomingArc<ScType::ConstPermPosArc>>
{
public:
  ScAddr GetActionClass() const override;
  ScResult DoProgram(ScAction & action) override;

  // Другие методы, определяемые пользователем.
};
```

Смотрите [**C++ Events API**](events.md) и [**C++ Event subscriptions API**](event_subscriptions.md), чтобы узнать, как использовать sc-события и обрабатывать их.

!!! примечание
    Определите класс действий как ключевой узел в классе агентов или классе ключевых узлов.

!!! предупреждение
    Вам следует переопределить методы `GetActionClass` и `DoProgram`. Но если вы предоставите спецификацию вашего агента в базе знаний, то вам не нужно будет переопределять `GetActionClass`. Смотрите [**C++ Modules API**](modules.md), чтобы узнать, как реализовать агенты со спецификацией в базе знаний.

Вы можете указать любые существующие типы событий в качестве аргумента шаблона для класса `ScAgent`. Например, вы можете сгенерировать агент, который будет запускаться при sc-событии удаления sc-элемента.

```cpp
// файл my_agent.hpp
#pragma once

#include <sc-memory/sc_agent.hpp>

class MyAgent : public ScAgent<ScEventBeforeEraseElement>
{
public:
  ScAddr GetActionClass() const override;
  ScResult DoProgram(
    ScEventBeforeEraseElement const & event, ScAction & action) override;

 // Другие методы, определяемые пользователем.
};
```

Если вы хотите изменить спецификацию этого агента в базе знаний, то напишите следующим образом:

```cpp
// файл my_agent.hpp
#pragma once

#include <sc-memory/sc_agent.hpp>

class MyAgent : public ScElementaryEventAgent
{
public:
  ScAddr GetActionClass() const override;
  ScResult DoProgram(
    ScElementaryEvent const & event, ScAction & action) override;

   // Другие методы, определяемые пользователем.
};
```

Эта реализация позволяет запрограммировать любой тип sc-события в "DoProgram`.

!!! примечание
    `ScElementaryEventAgent` - это псевдоним для "ScAgent<элементарное событие>`.

### **ScActionInitiatedAgent**

В мультиагентных системах большинство агентов реализованы для выполнения действий, инициированных другими агентами. Хотя `ScAgent` полезен для создания общей логики обработки событий, его использование для обработки инициализации действий требует некоторого шаблона. Мы внедрили еще один класс агентов, чтобы нашим пользователям было проще внедрять агенты, выполняющие действия. Для реализации этих агентов требуется передать узел класса действий, а не проверять условие запуска вручную.

Этот класс может использоваться только для агентов, которые должны запускаться путем генерации исходящей sc-дуги из узла класса `action_initiated`.

```cpp
// файл my_agent.hpp
#pragma once

#include <sc-memory/sc_agent.hpp>

// Наследуйте свой класс agent от класса `ScActionInitiatedAgent`.
class MyAgent : public ScActionInitiatedAgent
{
public:
 // Здесь вы должны указать класс действий, которые выполняет данный агент. 
 // Это переопределение обязательно.
  ScAddr GetActionClass() const override;
  // Здесь вы должны реализовать программу данного агента. 
  // Это переопределение обязательно.
  ScResult DoProgram(
    ScActionInitiatedEvent const & event, ScAction & action) override;
  // Здесь `ScActionInitiatedEvent` - это тип события, на которое реагирует 
  // данный агент.

  // Другие методы, определяемые пользователем.
};
```

!!! примечание
    `ScActionInitiatedAgent` имеет значение по умолчанию `GetInitiationConditionTemplate`, которое возвращает шаблон, который можно использовать для проверки того, что инициированное действие является действием с классом указанного агента.

!!! примечание
    `ScActionInitiatedEvent` - это псевдоним для `ScEventAfterGenerateOutgoingArc<ScType::ConstPermPosArc>` с элементом sc подписки `action_initiated`.

---

### **Required methods**

#### **GetActionClass**

Он получает класс действия, который выполняет агент указанного класса. Если абстрактный sc-агент для этого класса агента не имеет класса действия, то метод выдаст `utils::ExceptionItemNotFound`.

```cpp
// Файл my_agent.cpp
#include "my_agent.hpp"

#include "keynodes/my_keynodes.hpp"

ScAddr MyAgent::GetActionClass() const
{
  // Вы должны указать действительный sc-адрес класса действия, и вы должны 
  // предоставить класс действия, который относится к одному из типов: 
  // `receptor_action`, `effector_action`, `behavioral_action` или 
  // `information_action`.
  // В противном случае данный sc-агент не может быть подписан на sc-event.
  return MyKeynodes::my_action;
}
```

Смотрите [**C++ Keynodes API**](keynodes.md) и узнайте, как определять ключевые узлы и использовать их для своего агента.

#### **DoProgram**

Этот метод выполняется, когда агент успешно проверил условие запуска. Используя программу, агент обрабатывает входную конструкцию и генерирует выходную конструкцию.
Каждый агент выполняет действие с помощью своей программы.

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  // Класс `ScAction` инкапсулирует информацию о sc-действии. Предоставленное 
  // действие — это действие, которое данный агент выполняет прямо сейчас. 
  // Он принадлежит классу `MyKeynodes::my_action`.
  // Если ваш агент наследует класс `ScActionInitiatedAgent`, то этот агент
  // выполняет действие, инициированное извне. Если ваш агент наследует `ScAgent`
  // затем этот агент генерирует действие, инициирует и выполняет новое действие, а не
  // предоставляется извне.
  // Действия можно копировать и перемещать. `ScAction` унаследован от `ScAddr`.

  // Класс `ScActionInitiatedEvent` — это тип события, на котором данный агент 
  // срабатывает. Это инкапсулированная информация о sc-событии. 
  // Предоставленное событие — это событие, по которому агент срабатывает прямо сейчас. 
  // Имеет методы для получения информации об инициированном sc-событии: `GetUser`, 
  // `GetArc`, `GetSubscriptionElement`, `GetArcSourceElement`.
 
  // Реализуйте логику вашего агента...

  // Вы должны указать состояние действия на всех концах вашей программы-агента. 
  // `FinishSuccessful` устанавливает действие как `action_finished_successful`.
  // Вы не можете сгенерировать объект `ScResult` через конструктор, потому что он 
  // закрытый(private).
  
  return action.FinishSuccessfully(); 
}
```
Класс `ScAgent` имеет поле `m_context`. Это объект класса `ScAgentContext`. Вы можете использовать для завершения операций в sc-памяти. Смотрите [**API контекста агента C++**](agent_context.md), чтобы узнать больше о доступных методах.

!!! предупреждение
    Если вы не перехватываете sc-исключения в `DoProgram`, то sc-machine перехватит их, завершит действие с ошибкой и предупредит вас об этом.

##### Обработка аргументов действия

Существует множество способов получения аргументов действия. Используйте их, они помогут вам упростить код.

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  auto [argAddr1, argAddr] = action.GetArguments<2>();

  // Какая-то логика...

  return action.FinishSuccessfully(); 
}
```

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  ScAddr const & argAddr1 = action.GetArgument(ScKeynodes::rrel_1);
  // Параметр имеет тип ScAddr.

  // Какая-то логика...

  return action.FinishSuccessfully();
}
```

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  ScAddr const & argAddr1 = action.GetArgument(1); // size_t
  // Было бы то же самое, если бы мы передали ScKeynodes::rrel_1 вместо 1.
  
  // Какая-то логика...

  return action.FinishSuccessfully();
}
```

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  ScAddr const & argAddr1 
    = action.GetArgument(1, MyKeynodes::default_text_link);
  //Если действие не имеет первого аргумента, тогда будет возвращено 
  //MyKeynodes::default_text_link. 
  

  // Какая-то логика...

  return action.FinishSuccessfully();
}
```

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  // Вы можете использовать объект ScAction как объект ScAddr.
  ScIterator3Ptr const it3 = m_context.CreateIterator3(action, ..., ...);

  // Какая-то логика...

  return action.FinishSuccessfully();
}
```

##### Обработка результата действия

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  // Какая-то логика...
 
  action.FormResult(foundAddr1, generatedAddr1, ...); 
  // Или вы можете использовать метод `UpdateResult`.
  return action.FinishSuccessfully();
}
```

Дополнительные сведения о методах класса ScAction смотрите в разделе [**C++ Actions API**](actions.md).

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  // Какая-то логика...
 
  action.SetResult(structureAddr);
  return action.FinishSuccessfully();
}
```

##### Обработка состояния завершения действия

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  // Какая-то логика...

  if (/* случай 1 */)
    return action.FinishSuccessfully();
  else if (/* случай 2 */)
    return action.FinishUnsuccessfully();
  else
    return action.FinishWithError();
}
```

```cpp
ScResult MyAgent::DoProgram(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  action.IsInitiated(); // результат: true
  action.IsFinished(); // результат: false
  action.IsFinishedSuccessfully(); // результат: false

  // Какая-то логика...

  return action.FinishSuccessfully();
}
```

!!! предупреждение
    API `ScAction` предоставляет другие методы. Не используйте `GetResult` для инициированного, но не завершенного действия и `Initiate` для инициированного или завершенного действия.

---

### **Необязательные методы**

#### **GetAbstractAgent**

Он ищет в абстрактном агенте агента указанного класса. Если реализация агента для этого класса агента не включена ни в один абстрактный sc-агент, то `GetAbstractAgent` выдаст `utils::ExceptionItemNotFound`.

Вы можете переопределить этот метод в своем классе агента.

```cpp
ScAddr MyAgent::GetAbstractAgent() const
{
  // Вы должны указать действительный sc-адрес абстрактного агента. 
  // В противном случае данный sc-агент не может быть подписан на sc-event.
  return MyKeynodes::my_abstract_agent;
}
```

!!! предупреждение
    Помните: если вы переопределите только этот метод и необходимые методы, другие методы получения(геттеры) будут возвращать элементы спецификации для указанного абстрактного агента. Все непереопределяемые геттеры вызывают `GetAbstractAgent`.
    
#### **GetEventClass**

Он выполняет поиск в классе sc-event, на который подписан класс агента. Он выдаст `utils::ExceptionItemNotFound`, если абстрактный sc-агент для этого класса агентов не имеет основного условия инициализации.

Вы можете переопределить этот метод в своем классе агента.

```cpp
ScAddr MyAgent::GetEventClass() const
{
  // Вы должны указать действительный sc-адрес класса события. 
  // В противном случае данный sc-агент не может быть подписан на sc-event.
  return ScKeynodes::sc_event_after_generate_outgoing_arc;
}
```

#### **GetEventSubscriptionElement**

Этот метод ищет sc-элемент подписки на sc-событие, для которого инициируется sc-событие. Он выдаст `utils::ExceptionItemNotFound`, если абстрактный sc-агент для этого класса агентов не имеет первичного условия инициализации.

Вы можете переопределить этот метод в своем классе агента.

```cpp
ScAddr MyAgent::GetEventSubscriptionElement() const
{
  // Вы должны указать действительный sc-адрес sc-элемента подписки sc-события. 
  // В противном случае данный sc-агент не может быть подписан на sc-событие.

  return ScKeynodes::action_initiated;
}
```

!!! предупреждение
    Не переопределяйте `GetEventClass` и `GetEventSubscriptionElement` для агента со статически указанным типом sc-события. Ваш код не может быть скомпилирован. Переопределите их, если ваш класс агента наследует `ScAgent<ScElementaryEvent>` (`ScElementaryEventAgent`).

#### **GetInitiationCondition**

Он получает условие инициации для агента этого класса. Условием инициации является sc-шаблон (sc-структура), который используется агентом для проверки необходимых связей между sc-элементами тройки sc-события и sc-элементами в базе знаний перед выполнением агентом действия. Этот метод выдаст `utils::ExceptionItemNotFound`, если абстрактный sc-агент для этого класса агента не имеет условия инициации.

Вы можете переопределить этот метод в своем классе агента.

```cpp
ScAddr MyAgent::GetInitiationCondition() const
{
  // Вы должны указать действительный sc-адрес или sc-шаблон условия инициации. 
  // В противном случае данный sc-агент не может быть вызван.
  return ScKeynodes::my_initiation_condition;
}
```

```cpp
// sc_keynodes.hpp
...
// Здесь вы должны указать шаблон для проверки условия запуска перед 
// стартом агента.
static inline ScTemplateKeynode const & my_initiation_condition
  = ScTemplateKeynode(my_initiation_condition)
    // Необходимо указать действительный sc-адрес условия инициации. В противном случае, 
    // данный sc-агент не может быть вызван. Для sc-события генерации (удаления) 
    // sc-коннектор (sc-дуга или sc-ребро), необходимо указать в шаблоне 
    // условие инициации: тройка, вместо которой агент должен подставить 
    // sc-элементы, участвующие в инициированном событии. Эти элементы будут 
    // sc-коннектор (sc-дуга или sc-ребро) и его инцидентные sc-элементы. 
    // Для sc-события изменения содержимого sc-ссылки (или удаления sc-элемента) 
    // следует использовать sc-ссылку (sc-элемент) в шаблоне условия инициации 
    // явно. В противном случае ваш агент не вызовется, потому что его 
    // условие инициации выполнено для действия другого агента.

    .Triple(
      ScKeynodes::action_initiated,
      ScType::VarPermPosArc,
      ScType::VarNode >> "_action"
    )
    // After you should specify triples that only apply to your agent.
    .Triple(
      MyKeynodes::my_action,
      ScType::VarPermPosArc,
      "_action"
    )
    .Quintuple(
      "_action",
      ScType::VarPermPosArc,
      ScType::VarNode,
      ScType::VarPermPosArc,
      ScKeynodes::rrel_1
    );
...
```

!!! предупреждение
    Агент должен иметь шаблон условия инициации только с одной тройкой, которую можно использовать для замены sc-элементов, участвующих в инициированном событии, иначе агент не начнет выполнять sc-действие.

#### **GetInitiationConditionTemplate**

Вы можете задать шаблон условия инициации в коде, а не в базе знаний. Это может быть полезно, если вы хотите быстро проверить условие инициации агента без загрузки шаблона в базу знаний.

```cpp
ScTemplate MyAgent::GetInitiationConditionTemplate(
  ScActionInitiatedEvent const & event) const
{
  // В этом методе не следует указывать тройку для sc-элементов sc-события.
  // Вы должны указать тройки, которые применимы только к вашему агенту.
  initiationCondition.Triple(
    MyKeynodes::my_action,
    ScType::VarPermPosArc,
    event.GetOtherElement() // Он возвращает sc-действие.
  );
  return initiationCondition;
}
```

#### **CheckInitiationCondition**

Для повышения скорости вы можете реализовать условие инициации агента в виде проверок на итераторах.

```cpp
bool MyAgent::CheckInitiationCondition(ScActionInitiatedEvent const & event)
{
 // ScActionInitiatedEvent — тип события, по которому сработал данный агент. 
 // Это инкапсуляция информации о sc-событии. Предоставленное событие является событием 
 // на которое прямо сейчас срабатывает агент. У него есть методы получения 
 // информация об инициированном sc-событии: GetUser, GetArc, 
 // GetSubscriptionElement, GetArcSourceElement, GetArcTargetElement.
 // Все события нельзя копировать и перемещать.
 return m_context.CheckConnector(
   ScType::ConstPermPosArc, 
   MyKeynodes::my_action, 
   event.GetArcTargetElement());
}
// Вы можете использовать все возможности sc-memory API для проверки условия инициации 
// вашего агента.
```

!!! примечание
    Каждый из этих методов будет вызываться перед вызовом `DoProgram`.

!!! предупреждение
    Вы можете указать только один из методов: `GetInitiationCondition`, `GetInitiationConditionTemplate` и `CheckInitiationCondition`. В противном случае ваш код не сможет быть скомпилирован.

#### **GetResultCondition**

Он получает условие результата для агента этого класса. Условие результата — это sc-шаблон (sc-структура), который используется агентом для проверки необходимых связей между sc-элементами тройки sc-события и sc-элементами в базе знаний после выполнения агентом действия. Этот метод выдаст `utils::ExceptionItemNotFound`, если абстрактный sc-агент для этого класса агента не имеет условия результата.

Вы можете переопределить этот метод в своем классе агента.

```cpp
ScAddr MyAgent::GetResultCondition() const
{
  // Здесь вы должны указать шаблон для проверки содержимого результата действия.
  // Вы должны указать действительный sc-адрес или sc-шаблон условия результата. 
  // В противном случае данный sc-агент не может быть успешно завершен.
  return ScKeynodes::my_result_condition;
}
```

```cpp
// sc_keynodes.hpp
...
// Здесь вы должны указать шаблон для проверки содержимого результата действия.
static inline ScTemplateKeynode const & my_result_condition
  = ScTemplateKeynode(my_result_condition)
    .Triple(
      MyKeynodes::my_class,
      ScType::VarPermPosArc,
      ScType::VarNode
    );
    // Этот шаблон используется для проверки того, что агент сгенерировал sc-дугу
    // между `MyKeynodes::my_class` и некоторым sc-узлом.
...
```

#### **GetResultConditionTemplate**

Шаблон условия результата можно указать в коде, а не в базе знаний.

```cpp
ScTemplate MyAgent::GetResultConditionTemplate(
  ScActionInitiatedEvent const & event, ScAction & action) const
{
  // Здесь вы должны указать шаблон для проверки содержимого результата действия.
  ScTemplate resultCondition;
  resultCondition.Triple(
    MyKeynodes::my_class,
    ScType::VarPermPosArc,
    ScType::VarNode
  );
  return resultCondition;
}
```

!!! примечание
    `GetResultCondition` и `GetResultConditionTemplate` для поиска sc-конструкций используются только в результате действия.

#### **CheckResultCondition**

Для повышения скорости вы можете реализовать условие инициации агента в виде проверок на итераторах.

```cpp
bool MyAgent::CheckResult(
  ScActionInitiatedEvent const & event, ScAction & action)
{
  ScStructure const & actionResult = action.GetResult();
  ScIterator3Ptr const it3 = m_context.CreateIterator3(
    MyKeynodes::my_class,
    ScType::ConstPermPosArc,
    ScType::ConstNode,
    ScType::ConstPermPosArc,
    actionResult
  );
  return it3->Next() 
    && actionResult.HasElement(MyKeynodes::my_class) 
    && actionResult.HasElement(it3->Get(2))
    && !it3->Next() // Check that action result has no more triples.
    && m_context.GetOutputArcsCount(actionResult) == 3;
}
```

!!! примечание
    Каждый из этих методов будет вызываться после вызова `DoProgram`.

!!! предупреждение
    Вы можете указать только один из методов: `GetResultCondition`, `GetResultConditionTemplate` и `CheckResultCondition`. В противном случае ваш код не сможет быть скомпилирован.

--- 

## **Часто Задаваемые Вопросы**

<!-- no toc -->
- [Можно ли подписать агент более чем на одно sc-событие?](#is-it-possible-to-subscribe-an-agent-for-more-than-one-sc-event)
- [Что произойдет, если я не укажу полное условие инициализации в классе агента?](#what-happens-if-i-dont-specify-full-initiation-condition-in-agent-class)
- [Может ли существовать агент без первичного условия инициации?](#can-there-be-an-agent-without-primary-initiation-condition)
- [Можно ли сгенерировать объект класса `ScAgent` и вызвать любой из методов класса?](#is-it-possible-to-generate-object-of-scagent-class-and-call-any-of-class-methods)
- [Сохраняется ли протокол вызова агента?](#is-agents-call-protocol-preserved)
- [Что желательно делать агенту, а что нет?](#what-is-advisable-to-do-as-an-agent-and-what-is-not)
- [Какова цель условия результата? Для чего оно используется?](#whats-the-purpose-of-result-condition-what-is-it-used-for)

### **Можно ли подписать агент более чем на одно sc-событие?**

Будущие версии sc-машины будут реализовывать сложные sc-события. Сложные sc-события будут представлять собой набор элементарных событий. На такие sc-события можно будет подписывать агентов.

Если возникает вопрос, можно ли один и тот же агент подписать на два разных элементарных sc-события, то лучше этого не делать. Каждый агент должен быть подписан только на один тип sc-событий. Если вам нужно подписать агента на несколько типов sc-событий, возможно, вы делаете что-то неправильно.

Рассмотрим пример. Предположим, вы хотите реализовать агента для перерасчёта мощности множества, который будет реагировать на удаление sc-дуги из множества и на добавление sc-дуги в него. Не стоит создавать такого агента. Лучше разделить эту логику на два независимых объекта: агента, который будет реагировать на удаление sc-дуги из указанного множества, и агента, который будет реагировать на создание sc-дуги в этом множестве.

### **Что произойдет, если я не укажу полное условие инициализации в классе агента?**

Мы разрешаем не указывать полное условие инициализации агентов. Однако помните, что ваши агенты будут выполняться каждый раз, когда происходит событие в sc-элементе прослушивания, на который подписан ваш агент.

### **Может ли существовать агент без первичного условия инициации?**

Нет, агенты не могут существовать без первичного условия инициации. Агенты реагируют на события в sc-памяти. Первичное условие инициации указывает, на какое sc-событие подписан агент, т. е. когда агент будет вызван.

### **Можно ли сгенерировать объект класса `ScAgent` и вызвать любой из методов класса?**

Да, вы можете вызвать метод класса агента через объект этого класса. Но помните, что вы не можете генерировать необходимые аргументы для всех методов.

### **Сохраняется ли протокол вызова агента?**

Пока sc-машина не реализует функционал логирования процессов в sc-памяти. Он будет добавлен в следующих версиях. Однако sc-машина сама ничего не удаляет.

### **Что желательно делать агенту, а что нет?**

Это зависит от вашей цели. Если вы хотите сделать ostis-систему, то весь функционал вашей системы должен представлять собой коллектив агентов. Если вы хотите использовать machine в качестве базы данных для удобного и простого хранения и обработки информации, не все должны быть агентами. Для повышения производительности используйте агенты со статической спецификацией или без спецификации, объединяйте несколько агентов в один, оптимизируйте запросы sc-memory и т. д.

### **Какова цель условия результата? Для чего оно используется?**

На данный момент оно не влияет на завершение агента. Но в будущем это может быть использовано для проверки и отладки работы агентов.
