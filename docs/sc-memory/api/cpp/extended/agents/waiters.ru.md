# **C++ Waiters API**

!!! примечание
    Это верно только для версий sc-machine, которые >= 0.10.0.
--- 

**C++ Waiters API** предоставляет функциональные возможности для реализации условий ожидания в рабочих процессах агента. В этом разделе описывается, как создать waiters, которые приостанавливают выполнение агента до тех пор, пока не будут выполнены указанные условия или не будут запущены события. Это особенно полезно для синхронизации действий нескольких агентов или обеспечения выполнения определенных предварительных условий перед началом выполнения задач.

!!! примечание
    Чтобы подключить этот API, укажите "#include <sc-memory/sc_waiter.hpp>` в вашем исходном файле hpp.

## **ScWaiter** и **ScConditionWaiter**

Этот тип объектов используется для ожидания, пока не произойдет какое-либо событие, пока не истечет максимальное время ожидания. Обычно он используется, когда один из `ScAgent` хочет дождаться результата другого. Существует следующий тип объектов `ScWaiter`:

* `ScWaiter` блокирует поток выполнения до тех пор, пока не произойдет простое событие. Вы можете просмотреть список этих событий в [**C++ Events API**](events.md).
* `ScConditionWaiter` блокирует выполнение потока до тех пор, пока не произойдет простое событие и указанная условная проверка не вернет значение "true". Другими словами, это работает как "ScWaiter", но возвращается к выполнению потока, если функция специального условия возвращает значение `true`. Функция Condition принимает 3 параметра (см. [**C++ Events API**](events.md) для получения более подробной информации о них).

## **ScWaiter**

Чтобы создать объект этого класса, вы должны вызвать метод `CreateEventWaiter` из объекта класса `ScAgentContext`. Вы не можете использовать конструкторы класса `ScWaiter`, так как они являются закрытыми(private).

```cpp
...
// Сгенерировать, чтобы найти некоторый sc-узел и сгенерировать waiter, который будет ждать, пока 
// sc-коннектор указанного типа не будет сгенерирован из этого sc-узла или для этого sc-узла.
auto waiter = context.CreateEventWaiter<
  ScEventAfterGenerateConnector<ScType::ConstPermPosArc>>(
    nodeAddr,
    []() -> void
    {
      // Приведите здесь логику, которая должна вызываться точно в тот момент,
      // когда waiter начнет ждать появления sc-события.
    });
...
```

Мы рекомендуем использовать `auto` вместо полного типа waiter. В приведенном примере waiter имеет тип `std::shared_ptr<ScEventWaiter<ScEventAfterGenerateConnector<ScType::ConstPermPosArc>>>`.

### **Wait**

Вызовите этот метод из объекта класса `ScWaiter`, чтобы дождаться наступления sc-события.

```cpp
bool const isWaited = waiter.Wait(200); // миллисекунды.
// Здесь "200" - максимальное время ожидания наступления указанного события.
// Событие может произойти быстрее, чем за 200 миллисекунд, тогда результат 
// также будет получен раньше.
```

По умолчанию время ожидания этого метода равно 5000 миллисекундам.

Существует также версия этого метода с тремя аргументами. Вы можете указать функцию, которая будет вызвана после успешного завершения ожидания наступления события, и функцию, которая будет вызвана после неудачного завершения ожидания наступления события.

```cpp
bool const isWaited = waiter.Wait(
  200, 
  []() -> void
  {
    // Обработайте случай, если waiter дождался появления sc-события.
  },
  []() -> void
  {
    // Обработайте случай, если waiter не дождался появления sc-события.
  });
```

### **SetOnWaitStartDelegate**

Используйте этот метод, если вы хотите изменить или предоставить функцию, которая должна быть вызвана точно в то же время, когда waiter начнет ожидать наступления sc-события.

```cpp
waiter.SetOnWaitStartDelegate([]() -> void
{
  // Приведите логику этой функции здесь.
});
```

### **Resolve**

Вы можете сказать waiter, чтобы он перестал ждать.

```cpp
waiter.Resolve();
```

Тогда метод `Wait` перестанет ожидать наступления указанного события.

## **ScConditionWaiter**

Этот класс представляет waiter для условия, которое должно произойти. Чтобы создать объект этого класса, вы должны вызвать метод `CreateConditionWaiter` из объекта класса `ScAgentContext`. Вы также не можете использовать конструкторы класса `ScConditionWaiter`, так как они являются закрытыми(private).

```cpp
...
// Сгенерируйте или найдите какой-нибудь sc-узел и сгенерируйте waiter, который будет ждать, пока
// не будет сгенерирован sc-коннектор указанного типа от или к этому sc-узлу.
auto waiter = context.GenerateConditionWaiter<
  ScEventAfterGenerateConnector<ScType::ConstPermPosArc>>(
    nodeAddr,
    []() -> void
    {
     // Приведите здесь логику, которая должна быть вызвана точно в одно и то же время 
    // когда waiter начнет ожидать наступления sc-события.
    },
    [](ScEventAfterGenerateConnector<ScType::ConstPermPosArc>
        const & event) -> bool
    {
      // Проверьте здесь, что произошедшее sc-событие - это sc-событие, которого ждал этот waiter. 
    };
...
```

Класс `ScConditionWaiter` наследует класс `ScWaiter`. Вы можете использовать все методы класса ScWaiter для объектов класса `ScConditionWaiter`.

## **Примеры использования waiters**

Есть несколько примеров использования для указанных объектов `ScWaiter`:

* Подождите ввода sc-коннектора в sc-элемент с `nodeAddr`:

```cpp
auto waiter = context.CreateEventWaiter<
  ScEventAfterGenerateIncomingArc<ScType::ConstPermPosArc>>(nodeAddr);
waiter.Wait();
```

* Подождите ввода sc-коннектора в sc-элемент с `nodeAddr`, с условием:
```cpp
auto const CheckCallback 
  = [](ScEventAfterGenerateIncomingArc<
    ScType::ConstPermPosArc> const & event)
{
  // Проверьте условие здесь.
  // Возвращает значение true или false в зависимости от условия.
  return false;
};

auto waiter = context.CreateConditionWaiter<
  ScEventAfterGenerateIncomingArc<
    ScType::ConstPermPosArc>>(nodeAddr, CheckCallback);
// Укажите значение времени ожидания.
waiter.Wait(10000); // миллисекунды.
```

!!! предупреждение
   Все конструкторы этих классов являются закрытыми(private). Для создания waiters вам необходимо [**C++ Agent context API**](agent_context.md).

--- 

## **Часто Задаваемые Вопросы**

<!-- no toc -->
- [Почему я не могу вызвать конструктор waiter для sc-event?](#why-cant-i-call-the-constructor-of-a-waiter-for-sc-event)
- [Можно ли представить waiter в базе знаний для ожидания наступления sc-события?](#is-it-possible-to-represent-a-waiter-in-a-knowledge-base-to-wait-for-sc-event-to-occur)

### **Почему я не могу вызвать конструктор waiter для sc-event?**

Во-первых, это небезопасно. Нам нужно больше проверок входных аргументов, потому что их больше. Во-вторых, это правильно с точки зрения ООП. Конструкторы не должны генерировать исключения. В-третьих, это правильно с точки зрения архитектуры, которую мы используем в sc-машине. ScAgentContext - это внешний вид всех возможных объектов, используемых агентами.

### **Можно ли представить waiter в базе знаний для ожидания наступления sc-события?**

Да, вы можете сделать агента, который будет это делать.
