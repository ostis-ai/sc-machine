\scnheader{элемент sc-хранилища}
\scnidtf{ячейка sc-хранилища}
\scnidtf{элемент sc-хранилища, соответствующий sc-элементу}
\scnidtf{образ sc-элемента в рамках sc-хранилища}
\scnidtf{структура данных, каждый экземпляр которой соответствует одному sc-элементу в рамках sc-хранилища}
\scntext{пояснение}{Каждый элемент sc-хранилища, соответствующий некоторому sc-элементу, описывается его синтаксическим типом (меткой), а также независимо от типа указывается sc-адрес первой входящей в данный sc-элемент sc-дуги и первой выходящей из данного sc-элемента sc-дуги (могут быть пустыми, если таких sc-дуг нет).

Оставшиеся байты в зависимости от типа соответствующего sc-элемента (sc-узел или sc-дуга) могут использоваться либо для хранения содержимого внутреннего файла ostis-системы (может быть пустым, если sc-узел не является знаком файла), либо для хранения спецификации sc-дуги.}
\begin{scnrelfromset}{разбиение}
    \scnitem{элемент sc-хранилища, соответствующий sc-узлу}
    \begin{scnindent}
        \begin{scnrelfromset}{семейство отношений, однозначно задающих структуру заданной сущности}
            \scnitem{метка синтаксического типа sc-элемента*}
            \scnitem{метка уровня доступа sc-элемента*}
            \scnitem{sc-адрес первой sc-дуги, выходящей из данного sc-элемента*}
            \scnitem{sc-адрес первой sc-дуги, входящей в данный sc-элемент*}
            \scnitem{содержимое элемента sc-хранилища*}
            \begin{scnindent}
                \scnrelfrom{второй домен}{содержимое элемента sc-хранилища}
                \begin{scnindent}
                    \scnidtf{содержимое элемента sc-хранилища, соответствующего внутреннему файлу ostis-системы}
                \end{scnindent}
                \scntext{пояснение}{Каждый sc-узел в текущей реализации может иметь содержимое (может стать \textit{внутренним файлом ostis-системы}).
                В случае, если размер содержимого внутреннего файла ostis-системы не превышает 48 байт (размер \textit{спецификации sc-дуги в рамках sc-хранилища}, например небольшой \textit{строковый \mbox{sc-идентификатор}}), то это содержимое явно хранится в рамках элемента \mbox{sc-хранилища} в виде последовательности байт.
                В противном случае оно помещается в специальным образом организованную файловую память (за ее организацию отвечает отдельный модуль платформы, который в общем случае может быть устроен по-разному), а в рамках элемента sc-хранилища хранится уникальный адрес соответствующего файла, позволяющий быстро найти его на файловой системе.}
            \end{scnindent}
        \end{scnrelfromset}
        \begin{scnindent}
            \scntext{примечание}{\textit{sc-адрес первой sc-дуги, выходящей из данного sc-элемента*}, \textit{sc-адрес первой sc-дуги, входящей в данный sc-элемент*} и \textit{содержимое элемента sc-хранилища*} в общем случае могут отсутствовать (быть нулевыми, "пустыми"{}), но размер элемента в байтах останется тем же.}
        \end{scnindent}
    \end{scnindent}
    \scnitem{элемент sc-хранилища, соответствующий sc-дуге}
    \begin{scnindent}
        \begin{scnrelfromset}{семейство отношений, однозначно задающих структуру заданной сущности}
            \scnitem{метка синтаксического типа sc-элемента*}
            \scnitem{метка уровня доступа sc-элемента*}
            \scnitem{sc-адрес первой sc-дуги, выходящей из данного sc-элемента*}
            \scnitem{sc-адрес первой sc-дуги, входящей в данный sc-элемент*}
            \scnitem{спецификация sc-дуги в рамках sc-хранилища*}
            \begin{scnindent}
                \scnrelfrom{второй домен}{спецификация sc-дуги в рамках sc-хранилища}
                \begin{scnindent}
                    \begin{scnrelfromset}{семейство отношений, однозначно задающих структуру заданной сущности}
                        \scnitem{sc-адрес начального sc-элемента sc-дуги*}
                        \scnitem{sc-адрес конечного sc-элемента sc-дуги*}
                        \scnitem{sc-адрес следующей sc-дуги, выходящей из того же sc-элемента*}
                        \scnitem{sc-адрес следующей sc-дуги, входящей в тот же sc-элемент*}
                        \scnitem{sc-адрес предыдущей sc-дуги, выходящей из того же sc-элемента*}
                        \scnitem{sc-адрес предыдущей sc-дуги, входящей в тот же sc-элемент*}
                    \end{scnrelfromset}
                \end{scnindent}
            \end{scnindent}
        \end{scnrelfromset}
        \scntext{примечание}{sc-ребра в текущий момент хранятся так же, как sc-дуги, то есть имеют начальный и конечный sc-элементы, отличие заключается только в \textit{метке синтаксического типа sc-элемента}. Это приводит к ряду неудобств при обработке, но sc-ребра используются в настоящее время достаточно редко.}
    \end{scnindent}
\end{scnrelfromset}
\begin{scnindent}
    \scntext{примечание}{С точки зрения программной реализации структура данных для хранения sc-узла и sc-дуги остается остается та же, но в ней меняется список полей (компонентов).\\
    Кроме того, как можно заметить каждый элемент sc-хранилища (в том числе, \textit{элемент sc-хранилища, соответствующий sc-дуге}) не хранит список sc-адресов связанных с ним sc-элементов, а хранит sc-адреса одной выходящей и одной входящей дуги, каждая из которых в свою очередь хранит sc-адреса следующей и предыдущей дуг в списке исходящих и входящих sc-дуг для соответствующих элементов.
    Все перечисленное позволяет:
    \begin{scnitemize}
        \item сделать размер такой структуры фиксированным (в настоящее время 48 байт) и не зависящим от синтаксического типа хранимого sc-элемента;
        \item обеспечить возможность работы с sc-элементами без учета их синтаксического типа в случаях, когда это необходимо (например, при реализации поисковых запросов вида \scnqqi{Какие sc-элементы являются элементами данного множества}, \scnqqi{Какие sc-элементы непосредственно связаны с данным sc-элементом} и т.д.);
        \item обеспечить возможность доступа к \textit{элементу sc-хранилища} за константное время;
        \item обеспечить возможность помещения \textit{элемента sc-хранилища} в процессорный кэш, что в свою очередь, позволяет ускорить обработку sc-конструкций;
    \end{scnitemize}}
\end{scnindent}
\scntext{примечание}{Текущая \textit{Программная модель sc-памяти} предполагает, что вся sc-память физически расположена на одном компьютере. Для реализации распределенного варианта \textit{Программной модели sc-памяти} предполагается расширить \textit{sc-адрес} указанием адреса того физического устройства, где хранится соответствующий \textit{элемент sc-хранилища}.}
